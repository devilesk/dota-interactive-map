(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.InteractiveMap = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var PNG = require('png-js');

function ImageHandler(imagePath) {
    this.imagePath = imagePath;
    self.canvas = null;
    self.png = null;
}
ImageHandler.prototype.load = function (callback) {
    var self = this;
    var t1 = Date.now();
    try {
      self.canvas = document.createElement("canvas");
    }
    catch (e) {
      callback(e);
      return;
    }
    PNG.load(this.imagePath, self.canvas, function(err, png) {
        self.png = png;
        self.ctx = self.canvas.getContext("2d");
        callback(err);
    });
}
ImageHandler.prototype.scan = function (offset, width, height, pixelHandler, grid) {
    var imgData = this.ctx.getImageData(offset, 0, width, height);
    var data = imgData.data;

    for (var i = 0; i < data.length; i += 4) {
        var r = data[i];
        var g = data[i+1];
        var b = data[i+2];
        var alpha = data[i+3];
        var x = Math.floor((i/4) % width);
        var y = Math.floor((i/4) / height);
        pixelHandler(x, y, [r, g, b], grid);
    }
}

module.exports = ImageHandler;
},{"png-js":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0

/*
# MIT LICENSE
# Copyright (c) 2011 Devon Govett
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this 
# software and associated documentation files (the "Software"), to deal in the Software 
# without restriction, including without limitation the rights to use, copy, modify, merge, 
# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons 
# to whom the Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies or 
# substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING 
# BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

var FlateStream = require('./zlib');

  var PNG;

  PNG = (function() {
    PNG.load = function(url, canvas, callback) {
      var xhr,
        _this = this;
      if (typeof canvas === 'function') {
        callback = canvas;
      }
      xhr = new XMLHttpRequest;
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function() {
        var err, data, png;
        if (xhr.status == 200) {
          data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
          try {
            png = new PNG(data);
            if (typeof (canvas != null ? canvas.getContext : void 0) === 'function') {
              png.render(canvas);
            }
          }
          catch (e) {
            err = e;
          }
        }
        else {
          err = new Error("Image request failed " + xhr.status);
        }
        return typeof callback === "function" ? callback(err, png) : void 0;
      };
      return xhr.send(null);
    };

    function PNG(data) {
      var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, short, text, _i, _j, _ref;
      this.data = data;
      this.pos = 8;
      this.palette = [];
      this.imgData = [];
      this.transparency = {};
      this.text = {};
      frame = null;
      while (true) {
        chunkSize = this.readUInt32();
        section = ((function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i < 4; i = ++_i) {
            _results.push(String.fromCharCode(this.data[this.pos++]));
          }
          return _results;
        }).call(this)).join('');
        switch (section) {
          case 'IHDR':
            this.width = this.readUInt32();
            this.height = this.readUInt32();
            this.bits = this.data[this.pos++];
            this.colorType = this.data[this.pos++];
            this.compressionMethod = this.data[this.pos++];
            this.filterMethod = this.data[this.pos++];
            this.interlaceMethod = this.data[this.pos++];
            break;
          case 'PLTE':
            this.palette = this.read(chunkSize);
            break;
          case 'IDAT':
            if (section === 'fdAT') {
              this.pos += 4;
              chunkSize -= 4;
            }
            data = (frame != null ? frame.data : void 0) || this.imgData;
            for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {
              data.push(this.data[this.pos++]);
            }
            break;
          case 'tRNS':
            this.transparency = {};
            switch (this.colorType) {
              case 3:
                this.transparency.indexed = this.read(chunkSize);
                short = 255 - this.transparency.indexed.length;
                if (short > 0) {
                  for (i = _j = 0; 0 <= short ? _j < short : _j > short; i = 0 <= short ? ++_j : --_j) {
                    this.transparency.indexed.push(255);
                  }
                }
                break;
              case 0:
                this.transparency.grayscale = this.read(chunkSize)[0];
                break;
              case 2:
                this.transparency.rgb = this.read(chunkSize);
            }
            break;
          case 'tEXt':
            text = this.read(chunkSize);
            index = text.indexOf(0);
            key = String.fromCharCode.apply(String, text.slice(0, index));
            this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
            break;
          case 'IEND':
            if (frame) {
              this.animation.frames.push(frame);
            }
            this.colors = (function() {
              switch (this.colorType) {
                case 0:
                case 3:
                case 4:
                  return 1;
                case 2:
                case 6:
                  return 3;
              }
            }).call(this);
            this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
            colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
            this.pixelBitlength = this.bits * colors;
            this.colorSpace = (function() {
              switch (this.colors) {
                case 1:
                  return 'DeviceGray';
                case 3:
                  return 'DeviceRGB';
              }
            }).call(this);
            this.imgData = new Uint8Array(this.imgData);
            return;
          default:
            this.pos += chunkSize;
        }
        this.pos += 4;
        if (this.pos > this.data.length) {
          throw new Error("Incomplete or corrupt PNG file");
        }
      }
      return;
    }

    PNG.prototype.read = function(bytes) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
        _results.push(this.data[this.pos++]);
      }
      return _results;
    };

    PNG.prototype.readUInt32 = function() {
      var b1, b2, b3, b4;
      b1 = this.data[this.pos++] << 24;
      b2 = this.data[this.pos++] << 16;
      b3 = this.data[this.pos++] << 8;
      b4 = this.data[this.pos++];
      return b1 | b2 | b3 | b4;
    };

    PNG.prototype.readUInt16 = function() {
      var b1, b2;
      b1 = this.data[this.pos++] << 8;
      b2 = this.data[this.pos++];
      return b1 | b2;
    };

    PNG.prototype.decodePixels = function(data) {
      var byte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
      if (data == null) {
        data = this.imgData;
      }
      if (data.length === 0) {
        return new Uint8Array(0);
      }
      data = new FlateStream(data);
      data = data.getBytes();
      pixelBytes = this.pixelBitlength / 8;
      scanlineLength = pixelBytes * this.width;
      pixels = new Uint8Array(scanlineLength * this.height);
      length = data.length;
      row = 0;
      pos = 0;
      c = 0;
      while (pos < length) {
        switch (data[pos++]) {
          case 0:
            for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
              pixels[c++] = data[pos++];
            }
            break;
          case 1:
            for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
              byte = data[pos++];
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              pixels[c++] = (byte + left) % 256;
            }
            break;
          case 2:
            for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
              byte = data[pos++];
              col = (i - (i % pixelBytes)) / pixelBytes;
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
              pixels[c++] = (upper + byte) % 256;
            }
            break;
          case 3:
            for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
              byte = data[pos++];
              col = (i - (i % pixelBytes)) / pixelBytes;
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
              pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;
            }
            break;
          case 4:
            for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
              byte = data[pos++];
              col = (i - (i % pixelBytes)) / pixelBytes;
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              if (row === 0) {
                upper = upperLeft = 0;
              } else {
                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];
              }
              p = left + upper - upperLeft;
              pa = Math.abs(p - left);
              pb = Math.abs(p - upper);
              pc = Math.abs(p - upperLeft);
              if (pa <= pb && pa <= pc) {
                paeth = left;
              } else if (pb <= pc) {
                paeth = upper;
              } else {
                paeth = upperLeft;
              }
              pixels[c++] = (byte + paeth) % 256;
            }
            break;
          default:
            throw new Error("Invalid filter algorithm: " + data[pos - 1]);
        }
        row++;
      }
      return pixels;
    };

    PNG.prototype.decodePalette = function() {
      var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;
      palette = this.palette;
      transparency = this.transparency.indexed || [];
      ret = new Uint8Array((transparency.length || 0) + palette.length);
      pos = 0;
      length = palette.length;
      c = 0;
      for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
        ret[pos++] = palette[i];
        ret[pos++] = palette[i + 1];
        ret[pos++] = palette[i + 2];
        ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;
      }
      return ret;
    };

    PNG.prototype.copyToImageData = function(imageData, pixels) {
      var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
      colors = this.colors;
      palette = null;
      alpha = this.hasAlphaChannel;
      if (this.palette.length) {
        palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
        colors = 4;
        alpha = true;
      }
      data = imageData.data || imageData;
      length = data.length;
      input = palette || pixels;
      i = j = 0;
      if (colors === 1) {
        while (i < length) {
          k = palette ? pixels[i / 4] * 4 : j;
          v = input[k++];
          data[i++] = v;
          data[i++] = v;
          data[i++] = v;
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        }
      } else {
        while (i < length) {
          k = palette ? pixels[i / 4] * 4 : j;
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        }
      }
    };

    PNG.prototype.decode = function() {
      var ret;
      ret = new Uint8Array(this.width * this.height * 4);
      this.copyToImageData(ret, this.decodePixels());
      return ret;
    };

    PNG.prototype.render = function(canvas) {
      var ctx, data;
      canvas.width = this.width;
      canvas.height = this.height;
      ctx = canvas.getContext("2d");
      data = ctx.createImageData(this.width, this.height);
      this.copyToImageData(data, this.decodePixels());
      return ctx.putImageData(data, 0, 0);
    };

    return PNG;

  })();

  module.exports = PNG;
},{"./zlib":3}],3:[function(require,module,exports){
/*
 * Extracted from pdf.js
 * https://github.com/andreasgal/pdf.js
 *
 * Copyright (c) 2011 Mozilla Foundation
 *
 * Contributors: Andreas Gal <gal@mozilla.com>
 *               Chris G Jones <cjones@mozilla.com>
 *               Shaon Barman <shaon.barman@gmail.com>
 *               Vivien Nicolas <21@vingtetun.org>
 *               Justin D'Arcangelo <justindarc@gmail.com>
 *               Yury Delendik
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

var DecodeStream = (function() {
  function constructor() {
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = null;
  }

  constructor.prototype = {
    ensureBuffer: function decodestream_ensureBuffer(requested) {
      var buffer = this.buffer;
      var current = buffer ? buffer.byteLength : 0;
      if (requested < current)
        return buffer;
      var size = 512;
      while (size < requested)
        size <<= 1;
      var buffer2 = new Uint8Array(size);
      for (var i = 0; i < current; ++i)
        buffer2[i] = buffer[i];
      return this.buffer = buffer2;
    },
    getByte: function decodestream_getByte() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof)
          return null;
        this.readBlock();
      }
      return this.buffer[this.pos++];
    },
    getBytes: function decodestream_getBytes(length) {
      var pos = this.pos;

      if (length) {
        this.ensureBuffer(pos + length);
        var end = pos + length;

        while (!this.eof && this.bufferLength < end)
          this.readBlock();

        var bufEnd = this.bufferLength;
        if (end > bufEnd)
          end = bufEnd;
      } else {
        while (!this.eof)
          this.readBlock();

        var end = this.bufferLength;
      }

      this.pos = end;
      return this.buffer.subarray(pos, end);
    },
    lookChar: function decodestream_lookChar() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof)
          return null;
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos]);
    },
    getChar: function decodestream_getChar() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof)
          return null;
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos++]);
    },
    makeSubStream: function decodestream_makeSubstream(start, length, dict) {
      var end = start + length;
      while (this.bufferLength <= end && !this.eof)
        this.readBlock();
      return new Stream(this.buffer, start, length, dict);
    },
    skip: function decodestream_skip(n) {
      if (!n)
        n = 1;
      this.pos += n;
    },
    reset: function decodestream_reset() {
      this.pos = 0;
    }
  };

  return constructor;
})();

var FlateStream = (function() {
  var codeLenCodeMap = new Uint32Array([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
  ]);

  var lengthDecode = new Uint32Array([
    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
  ]);

  var distDecode = new Uint32Array([
    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
  ]);

  var fixedLitCodeTab = [new Uint32Array([
    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
    0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
    0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
    0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
    0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
    0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
    0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
    0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
    0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
    0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
    0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
    0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
    0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
    0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
    0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
    0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
    0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
    0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
    0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
    0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
    0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
    0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
    0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
    0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
    0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
    0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
    0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
    0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
    0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
    0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
    0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
    0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
    0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
    0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
    0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
    0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
    0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
    0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
    0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
    0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
    0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
    0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
    0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
    0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
    0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
    0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
    0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
    0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
    0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
  ]), 9];

  var fixedDistCodeTab = [new Uint32Array([
    0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
    0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
    0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
    0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
  ]), 5];
  
  function error(e) {
      throw new Error(e)
  }

  function constructor(bytes) {
    //var bytes = stream.getBytes();
    var bytesPos = 0;

    var cmf = bytes[bytesPos++];
    var flg = bytes[bytesPos++];
    if (cmf == -1 || flg == -1)
      error('Invalid header in flate stream');
    if ((cmf & 0x0f) != 0x08)
      error('Unknown compression method in flate stream');
    if ((((cmf << 8) + flg) % 31) != 0)
      error('Bad FCHECK in flate stream');
    if (flg & 0x20)
      error('FDICT bit set in flate stream');

    this.bytes = bytes;
    this.bytesPos = bytesPos;

    this.codeSize = 0;
    this.codeBuf = 0;

    DecodeStream.call(this);
  }

  constructor.prototype = Object.create(DecodeStream.prototype);

  constructor.prototype.getBits = function(bits) {
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var bytes = this.bytes;
    var bytesPos = this.bytesPos;

    var b;
    while (codeSize < bits) {
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad encoding in flate stream');
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    b = codeBuf & ((1 << bits) - 1);
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    this.bytesPos = bytesPos;
    return b;
  };

  constructor.prototype.getCode = function(table) {
    var codes = table[0];
    var maxLen = table[1];
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var bytes = this.bytes;
    var bytesPos = this.bytesPos;

    while (codeSize < maxLen) {
      var b;
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad encoding in flate stream');
      codeBuf |= (b << codeSize);
      codeSize += 8;
    }
    var code = codes[codeBuf & ((1 << maxLen) - 1)];
    var codeLen = code >> 16;
    var codeVal = code & 0xffff;
    if (codeSize == 0 || codeSize < codeLen || codeLen == 0)
      error('Bad encoding in flate stream');
    this.codeBuf = (codeBuf >> codeLen);
    this.codeSize = (codeSize - codeLen);
    this.bytesPos = bytesPos;
    return codeVal;
  };

  constructor.prototype.generateHuffmanTable = function(lengths) {
    var n = lengths.length;

    // find max code length
    var maxLen = 0;
    for (var i = 0; i < n; ++i) {
      if (lengths[i] > maxLen)
        maxLen = lengths[i];
    }

    // build the table
    var size = 1 << maxLen;
    var codes = new Uint32Array(size);
    for (var len = 1, code = 0, skip = 2;
         len <= maxLen;
         ++len, code <<= 1, skip <<= 1) {
      for (var val = 0; val < n; ++val) {
        if (lengths[val] == len) {
          // bit-reverse the code
          var code2 = 0;
          var t = code;
          for (var i = 0; i < len; ++i) {
            code2 = (code2 << 1) | (t & 1);
            t >>= 1;
          }

          // fill the table entries
          for (var i = code2; i < size; i += skip)
            codes[i] = (len << 16) | val;

          ++code;
        }
      }
    }

    return [codes, maxLen];
  };

  constructor.prototype.readBlock = function() {
    function repeat(stream, array, len, offset, what) {
      var repeat = stream.getBits(len) + offset;
      while (repeat-- > 0)
        array[i++] = what;
    }

    // read block header
    var hdr = this.getBits(3);
    if (hdr & 1)
      this.eof = true;
    hdr >>= 1;

    if (hdr == 0) { // uncompressed block
      var bytes = this.bytes;
      var bytesPos = this.bytesPos;
      var b;

      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      var blockLen = b;
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      blockLen |= (b << 8);
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      var check = b;
      if (typeof (b = bytes[bytesPos++]) == 'undefined')
        error('Bad block header in flate stream');
      check |= (b << 8);
      if (check != (~blockLen & 0xffff))
        error('Bad uncompressed block length in flate stream');

      this.codeBuf = 0;
      this.codeSize = 0;

      var bufferLength = this.bufferLength;
      var buffer = this.ensureBuffer(bufferLength + blockLen);
      var end = bufferLength + blockLen;
      this.bufferLength = end;
      for (var n = bufferLength; n < end; ++n) {
        if (typeof (b = bytes[bytesPos++]) == 'undefined') {
          this.eof = true;
          break;
        }
        buffer[n] = b;
      }
      this.bytesPos = bytesPos;
      return;
    }

    var litCodeTable;
    var distCodeTable;
    if (hdr == 1) { // compressed block, fixed codes
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr == 2) { // compressed block, dynamic codes
      var numLitCodes = this.getBits(5) + 257;
      var numDistCodes = this.getBits(5) + 1;
      var numCodeLenCodes = this.getBits(4) + 4;

      // build the code lengths code table
      var codeLenCodeLengths = Array(codeLenCodeMap.length);
      var i = 0;
      while (i < numCodeLenCodes)
        codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);
      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);

      // build the literal and distance code tables
      var len = 0;
      var i = 0;
      var codes = numLitCodes + numDistCodes;
      var codeLengths = new Array(codes);
      while (i < codes) {
        var code = this.getCode(codeLenCodeTab);
        if (code == 16) {
          repeat(this, codeLengths, 2, 3, len);
        } else if (code == 17) {
          repeat(this, codeLengths, 3, 3, len = 0);
        } else if (code == 18) {
          repeat(this, codeLengths, 7, 11, len = 0);
        } else {
          codeLengths[i++] = len = code;
        }
      }

      litCodeTable =
        this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));
      distCodeTable =
        this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));
    } else {
      error('Unknown block type in flate stream');
    }

    var buffer = this.buffer;
    var limit = buffer ? buffer.length : 0;
    var pos = this.bufferLength;
    while (true) {
      var code1 = this.getCode(litCodeTable);
      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }
        buffer[pos++] = code1;
        continue;
      }
      if (code1 == 256) {
        this.bufferLength = pos;
        return;
      }
      code1 -= 257;
      code1 = lengthDecode[code1];
      var code2 = code1 >> 16;
      if (code2 > 0)
        code2 = this.getBits(code2);
      var len = (code1 & 0xffff) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;
      if (code2 > 0)
        code2 = this.getBits(code2);
      var dist = (code1 & 0xffff) + code2;
      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }
      for (var k = 0; k < len; ++k, ++pos)
        buffer[pos] = buffer[pos - dist];
    }
  };

  return constructor;
})();

module.exports = FlateStream;
},{}],4:[function(require,module,exports){
/*
	This is rot.js, the ROguelike Toolkit in JavaScript.
	Version 0.6~dev, generated on Tue Mar 17 16:16:31 CET 2015.
*/
/**
 * @namespace Top-level ROT namespace
 */
var ROT = {
	/** Directional constants. Ordering is important! */
	DIRS: {
		"4": [
			[ 0, -1],
			[ 1,  0],
			[ 0,  1],
			[-1,  0]
		],
		"8": [
			[ 0, -1],
			[ 1, -1],
			[ 1,  0],
			[ 1,  1],
			[ 0,  1],
			[-1,  1],
			[-1,  0],
			[-1, -1]
		],
		"6": [
			[-1, -1],
			[ 1, -1],
			[ 2,  0],
			[ 1,  1],
			[-1,  1],
			[-2,  0]
		]
	}
};
/**
 * Always positive modulus
 * @param {int} n Modulus
 * @returns {int} this modulo n
 */
Number.prototype.mod = function(n) {
	return ((this%n)+n)%n;
}
if (!Object.create) {  
	/**
	 * ES5 Object.create
	 */
	Object.create = function(o) {  
		var tmp = function() {};
		tmp.prototype = o;
		return new tmp();
	};  
}  
/**
 * Sets prototype of this function to an instance of parent function
 * @param {function} parent
 */
Function.prototype.extend = function(parent) {
	this.prototype = Object.create(parent.prototype);
	this.prototype.constructor = this;
	return this;
}
if (typeof window != "undefined") {
	window.requestAnimationFrame =
		window.requestAnimationFrame
		|| window.mozRequestAnimationFrame
		|| window.webkitRequestAnimationFrame
		|| window.oRequestAnimationFrame
		|| window.msRequestAnimationFrame
		|| function(cb) { return setTimeout(cb, 1000/60); };

	window.cancelAnimationFrame =
		window.cancelAnimationFrame
		|| window.mozCancelAnimationFrame
		|| window.webkitCancelAnimationFrame
		|| window.oCancelAnimationFrame
		|| window.msCancelAnimationFrame
		|| function(id) { return clearTimeout(id); };
}
/**
 * @class Abstract FOV algorithm
 * @param {function} lightPassesCallback Does the light pass through x,y?
 * @param {object} [options]
 * @param {int} [options.topology=8] 4/6/8
 */
ROT.FOV = function(lightPassesCallback, options) {
	this._lightPasses = lightPassesCallback;
	this._options = {
		topology: 8
	}
	for (var p in options) { this._options[p] = options[p]; }
};

/**
 * Compute visibility for a 360-degree circle
 * @param {int} x
 * @param {int} y
 * @param {int} R Maximum visibility radius
 * @param {function} callback
 */
ROT.FOV.prototype.compute = function(x, y, R, callback) {}

/**
 * Return all neighbors in a concentric ring
 * @param {int} cx center-x
 * @param {int} cy center-y
 * @param {int} r range
 */
ROT.FOV.prototype._getCircle = function(cx, cy, r) {
	var result = [];
	var dirs, countFactor, startOffset;

	switch (this._options.topology) {
		case 4:
			countFactor = 1;
			startOffset = [0, 1];
			dirs = [
				ROT.DIRS[8][7],
				ROT.DIRS[8][1],
				ROT.DIRS[8][3],
				ROT.DIRS[8][5]
			]
		break;

		case 6:
			dirs = ROT.DIRS[6];
			countFactor = 1;
			startOffset = [-1, 1];
		break;

		case 8:
			dirs = ROT.DIRS[4];
			countFactor = 2;
			startOffset = [-1, 1];
		break;
	}

	/* starting neighbor */
	var x = cx + startOffset[0]*r;
	var y = cy + startOffset[1]*r;

	/* circle */
	for (var i=0;i<dirs.length;i++) {
		for (var j=0;j<r*countFactor;j++) {
			result.push([x, y]);
			x += dirs[i][0];
			y += dirs[i][1];

		}
	}

	return result;
}
/**
 * @class Precise shadowcasting algorithm
 * @augments ROT.FOV
 */
ROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {
	ROT.FOV.call(this, lightPassesCallback, options);
}
ROT.FOV.PreciseShadowcasting.extend(ROT.FOV);

ROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {
	/* this place is always visible */
	callback(x, y, 0, 1);
    
	callback(x-1, y-1, 0, 1);
	callback(x, y-1, 0, 1);
	callback(x+1, y-1, 0, 1);
	callback(x-1, y, 0, 1);
	callback(x+1, y, 0, 1);
	callback(x-1, y+1, 0, 1);
	callback(x, y+1, 0, 1);
	callback(x+1, y+1, 0, 1);
    
    callback(x-1, y-2, 0, 1);
    callback(x, y-2, 0, 1);
    callback(x+1, y-2, 0, 1);
    callback(x-2, y-1, 0, 1);
    callback(x-2, y, 0, 1);
    callback(x-2, y+1, 0, 1);
    callback(x+2, y-1, 0, 1);
    callback(x+2, y, 0, 1);
    callback(x+2, y+1, 0, 1);
    callback(x-1, y+2, 0, 1);
    callback(x, y+2, 0, 1);
    callback(x+1, y+2, 0, 1);

	/* standing in a dark place. FIXME is this a good idea?  */
	if (!this._lightPasses(x, y)) { return; }
	
	/* list of all shadows */
	var SHADOWS = [];
	var trees = {};
	var totalNeighborCount = 1;
    var cx, cy, blocks, A1, A2, visibility,
        dx, dy, dd, a, b, radius,
        cx2, cy2, dd1,
        obstacleType;

	/* analyze surrounding cells in concentric rings, starting from the center */
	for (var r=1; r<=R; r++) {
		var neighbors = this._getCircle(x, y, r);
		var neighborCount = neighbors.length;
        totalNeighborCount += neighborCount;
        trees = {};
		for (var i=0;i<neighborCount;i++) {
			cx = neighbors[i][0];
			cy = neighbors[i][1];
            var key = cx+","+cy;
            if ((x-cx)*(x-cx) + (y-cy)*(y-cy) >= R * R) {
                totalNeighborCount--;
                continue;
            }
            //if (key == "44,102") //console.log('KEY', key, !this._lightPasses(cx, cy));
            // if (key == "150,160") //console.log(key, obstacleType);
            // if (key == "151,161") //console.log(key, obstacleType);
            // if (key == "150,161") //console.log(key, obstacleType);
            var obstacleTypes = obstacleTypes = this.walls[key];
            if (obstacleTypes && obstacleTypes.length) {
                var skipVisibility = false;
                for (var j = 0; j < obstacleTypes.length; j++) {
                    var obstacleType = obstacleTypes[j];
                    cx2 = obstacleType[1];
                    cy2 = obstacleType[2];
                    radius = obstacleType[3];
                    
                    dx = cx2 - x;
                    dy = cy2 - y;
                    dd = Math.sqrt(dx * dx + dy * dy);
                    if (dd > 1/2) {
                        a = Math.asin(radius / dd);
                        b = Math.atan2(dy, dx),
                        A1 = normalize(b - a),
                        A2 = normalize(b + a);
                        blocks = !this._lightPasses(cx, cy);
                        
                        dx1 = cx - x;
                        dy1 = cy - y;
                        dd1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        if (dd1 < dd) {
                            trees[obstacleType[1]+","+obstacleType[2]] = [obstacleType[1], obstacleType[2]];
                        }
                        
                        dx = cx - x;
                        dy = cy - y;
                        dd = Math.sqrt(dx * dx + dy * dy);
                        a = Math.asin(radius / dd);
                        b = Math.atan2(dy, dx),
                        A1 = normalize(b - a),
                        A2 = normalize(b + a);
                        visibility = this._checkVisibility(b, A1, A2, false, SHADOWS);
                        if (!visibility) skipVisibility = true;
                    }
                }
                if (visibility && !skipVisibility) { callback(cx, cy, r, visibility); }
            }
            else {
                cx2 = cx;
                cy2 = cy;
                radius = Math.SQRT2 / 2;
                
                dx = cx2 - x;
                dy = cy2 - y;
                dd = Math.sqrt(dx * dx + dy * dy);
                if (dd > 1/2) {
                    a = Math.asin(radius / dd);
                    b = Math.atan2(dy, dx),
                    A1 = normalize(b - a),
                    A2 = normalize(b + a);
                    blocks = !this._lightPasses(cx, cy);
                    
                    visibility = this._checkVisibility(b, A1, A2, blocks, SHADOWS);
                    if (visibility) { callback(cx, cy, r, visibility); }
                    if (this.done) return;
                }
            }
            
            /*dx = cx2 - x;
            dy = cy2 - y;
            dd = Math.sqrt(dx * dx + dy * dy);
            if (dd > 1/2) {
                a = Math.asin(radius / dd);
                b = Math.atan2(dy, dx),
                A1 = normalize(b - a),
                A2 = normalize(b + a);
                blocks = !this._lightPasses(cx, cy);
                if (obstacleType && obstacleType[0] == 'tree') {
                    dx1 = cx - x;
                    dy1 = cy - y;
                    dd1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                    if (dd1 < dd) {
                        trees[obstacleType[1]+","+obstacleType[2]] = [obstacleType[1], obstacleType[2]];
                    }
                    
                    dx = cx - x;
                    dy = cy - y;
                    dd = Math.sqrt(dx * dx + dy * dy);
                    a = Math.asin(radius / dd);
                    b = Math.atan2(dy, dx),
                    A1 = normalize(b - a),
                    A2 = normalize(b + a);
                    visibility = this._checkVisibility(b, A1, A2, false, SHADOWS);
                    if (visibility) { callback(cx, cy, r, visibility); }
                }
                else {
                    //if (obstacleType) //console.log(obstacleType[0], radius);
                    //console.log('BLOCKS', cx, cy, blocks, b);
                    visibility = this._checkVisibility(b, A1, A2, blocks, SHADOWS);
                    if (visibility) { callback(cx, cy, r, visibility); }
                    if (this.done) return;
                }
            }*/

		} /* for all cells in this ring */
        
        // apply tree blockers
        for (var k in trees) {
            ////console.log('apply tree');
            cx2 = trees[k][0];
            cy2 = trees[k][1];
            dx = cx2 - x;
            dy = cy2 - y;
            dd = Math.sqrt(dx * dx + dy * dy);
            radius = Math.SQRT2 - .01;
            if (dd > 1/2) {
                a = Math.asin(radius / dd);
                b = Math.atan2(dy, dx),
                A1 = normalize(b - a),
                A2 = normalize(b + a);
                visibility = this._checkVisibility(b, A1, A2, true, SHADOWS);
                if (this.done) return;
            }
        }
	} /* for all rings */
    
    return totalNeighborCount;
}

/**
 * @param {int[2]} A1 arc start
 * @param {int[2]} A2 arc end
 * @param {bool} blocks Does current arc block visibility?
 * @param {int[][]} SHADOWS list of active shadows
 */
ROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(b, A1, A2, blocks, SHADOWS) {
    ////console.log('_checkVisibility', b, A1, A2, blocks, SHADOWS);
    // check if target center is inside a shadow
    var visible = !blocks;
    //console.log('_checkVisibility', b, visible);
	for (var i = 0; i < SHADOWS.length; i++) {
		var old = SHADOWS[i];
        if (isBetween(b, old[0], old[1])) {
            if (blocks) {
                ////console.log('blocks but not visible', SHADOWS.length);
                visible = false;
            }
            else {
                //console.log(i, b, JSON.stringify(SHADOWS));
                return false; // not visible, return
            }
        }
	}
    
    if (blocks) {
        if (A1 < 0 && A2 >= 0) {
            //console.log('splitting');
            this._mergeShadows(b, 0, A2, blocks, SHADOWS);
            this.done = false;
            this._mergeShadows(b, A1, 0, blocks, SHADOWS);
        }
        else {
            //console.log('not splitting', blocks, visible, b);
            this._mergeShadows(b, A1, A2, blocks, SHADOWS);
        }
        //console.log('end', A1, A2, JSON.stringify(SHADOWS), !isBetween(A1, SHADOWS[0][0], SHADOWS[0][1]), !isBetween(A2, SHADOWS[0][0], SHADOWS[0][1]));
        if (SHADOWS.length == 1 && (!isBetween(A1, SHADOWS[0][0], SHADOWS[0][1]) || !isBetween(A2, SHADOWS[0][0], SHADOWS[0][1])) && A1 != SHADOWS[0][0] && A2 != SHADOWS[0][1] ) {
            this.done = true;
        }
    }
    
    return visible;
}

ROT.FOV.PreciseShadowcasting.prototype._mergeShadows = function(b, A1, A2, blocks, SHADOWS) {
    ////console.log('merging', b, A1, A2);
    // check if target first edge is inside a shadow or which shadows it is between
    var index1 = 0,
        edge1 = false,
        firstIndex = 0;
    while (index1 < SHADOWS.length) {
        var old = SHADOWS[index1];
        firstIndex = index1;
        if (isBetween(A1, old[0], old[1])) {
            edge1 = true;
            break;
        }
        if (index1 > 0 && isBetween(A1, SHADOWS[index1 - 1][1], old[0])) {
            edge1 = false;
            break;
        }
        if (!isBefore(A1, old[1])) {
            index1++;
            firstIndex = index1;
            continue;
        }
        if (isBefore(A1, old[0])) {
            break;
        }
        index1++;
    }
    
    // check if target second edge is inside a shadow or which shadows it is between
    var index2 = SHADOWS.length - 1,
        edge2 = false,
        secondIndex = 0;
    while (index2 >= 0) {
        var old = SHADOWS[index2];
        secondIndex = index2;
        ////console.log(A2, old[0], old[1], isBetween(A2, old[0], old[1]))
        if (isBetween(A2, old[0], old[1])) {
            edge2 = true;
            break;
        }
        if (isBefore(A2, old[0])) {
            index2--;
            secondIndex = index2;
            continue;
        }
        if (!isBefore(A2, old[1])) {
            break;
        }
        index2--;
    }
    
    ////console.log(firstIndex, secondIndex, edge1, edge2, A1, A2);
    if (firstIndex == SHADOWS.length && !edge1 && secondIndex == 0 && edge2) firstIndex = 0;
    //if (secondIndex == -1) secondIndex = SHADOWS.length - 1;
    //console.log(firstIndex, secondIndex, edge1, edge2, A1, A2);
    //console.log(JSON.stringify(SHADOWS));
    if (SHADOWS.length == 0) {
        //console.log('empty shadows pushing', [A1, A2]);
        SHADOWS.push([A1, A2]);
    }
    /*else if (SHADOWS.length > 1 && firstIndex == SHADOWS.length && secondIndex == 0 && !edge1 && edge2) {
    
    }*/
    else {
        var new_shadow = [edge1 ? SHADOWS[firstIndex][0] : A1, edge2 ? SHADOWS[secondIndex][1] : A2];
        //console.log('new_shadow', new_shadow);
        secondIndex = Math.max(firstIndex, secondIndex);
        var sum1 = diff_sum(SHADOWS);
        var doShift = false;
        if (isBetween(0, new_shadow[0], new_shadow[1]) && new_shadow[0] != 0 && new_shadow[1] != 0) {
            //console.log('crosses 0');
            SHADOWS.splice(firstIndex, firstIndex == secondIndex && edge1 == edge2 && !edge1 ? 0 : secondIndex - firstIndex + 1, [new_shadow[0], 0]);
            //console.log([new_shadow[0], 0], JSON.stringify(SHADOWS));
            if (SHADOWS[0][0] != 0 && SHADOWS[0][1] != new_shadow[1]) {
                SHADOWS.splice(firstIndex + 1, 0, [0, new_shadow[1]]);
                //console.log([0, new_shadow[1]], JSON.stringify(SHADOWS));
            }
            //console.log(JSON.stringify(SHADOWS));
            doShift = true;
        }
        else {
            SHADOWS.splice(firstIndex, firstIndex == secondIndex && edge1 == edge2 && !edge1 ? 0 : secondIndex - firstIndex + 1, new_shadow);
        }
        var sum2 = diff_sum(SHADOWS);
        //console.log('sum1', sum1, 'sum2', sum2, sum2 < sum1, SHADOWS.length == 1 && (!isBetween(A1, SHADOWS[0][0], SHADOWS[0][1]) || !isBetween(A2, SHADOWS[0][0], SHADOWS[0][1])));
        if (sum2 < sum1) this.done = true;
        /*if (SHADOWS.length == 1 && (!isBetween(A1, SHADOWS[0][0], SHADOWS[0][1]) || !isBetween(A2, SHADOWS[0][0], SHADOWS[0][1]))) {
            this.done = true;
        }*/
        if (new_shadow[0] == 0 || doShift) {
            var count = 0;
            //console.log('shifting');
            while (SHADOWS[0][0] != 0) {
                SHADOWS.push(SHADOWS.shift());
                if (count >= SHADOWS.length) break;
                count++;
                //console.log(JSON.stringify(SHADOWS));
            }
            //console.log('end shifting', JSON.stringify(SHADOWS));
        }
        //console.log(JSON.stringify(SHADOWS));
        //console.log(diff_sum(SHADOWS));
    }
}

function isBefore(A1, A2) {
    if (A1 > 0 && A2 < 0) { // A1 in bottom half, A2 in top half
        return true;
    }
    else if (A2 > 0 && A1 < 0) { // A1 in top half, A2 in bottom half
        return false;
    }
    else {
        return A1 < A2;
    }
}

function isAfter(A1, A2) {
    return !isBefore(A1, A2);
}

function isBetween(b, A1, A2) {
    if (A1 < A2) {
        return ((A1 <= b) && (b <= A2));
    }
    else {
        return ((A1 <= b) && (b <= Math.PI)) || ((-Math.PI <= b) && (b <= A2));
    }
}

function normalize(x) {
    if (x > Math.PI) {
        return -(2 * Math.PI - x);
    }
    else if ( x < -Math.PI) {
        return 2 * Math.PI + x;
    }
    else {
        return x;
    }
}

function diff(A1, A2) {
    if (A1 > 0 && A2 < 0) { // A1 in bottom half, A2 in top half
        return Math.abs((Math.PI - A1) - (-Math.PI - A2));
    }
    else if (A2 > 0 && A1 < 0) { // A1 in top half, A2 in bottom half
        return Math.abs(-A1 + A2);
    }
    if (A1 <= 0 && A2 <= 0) { // A1,A2 in bottom half
        if (isAfter(A1, A2)) { // A1 after A2
            return -A1 + Math.PI - (-Math.PI - A2)
        }
        else {
            return Math.abs(A2 - A1);
        }
    }
    else {
        if (isAfter(A1, A2)) {
            return Math.PI + (Math.PI - A1) + A2
        }
        else {
            return Math.abs(A2 - A1);
        }
    }
}

function diff_sum(SHADOWS) {
    var sum = 0;
    for (var i = 0; i < SHADOWS.length; i++) {
        ////console.log(SHADOWS[i][0], SHADOWS[i][1], diff(SHADOWS[i][0], SHADOWS[i][1]));
        sum += diff(SHADOWS[i][0], SHADOWS[i][1]);
    }
    return sum;
}

module.exports = ROT;
},{}],5:[function(require,module,exports){
var ImageHandler = require("./imageHandler.js");
var ROT = require("./rot6.js");

var key2pt_cache = {};
function key2pt(key) {
    if (key in key2pt_cache) return key2pt_cache[key];
    var p = key.split(',').map(function (c) { return parseInt(c) });
    var pt = {x: p[0], y: p[1], key: key};
    key2pt_cache[key] = pt;
    return pt;
}

function xy2key(x, y) {
    return x + "," + y;
}

function xy2pt(x, y) {
    return {x: x, y: y, key: x + "," + y};
}

function pt2key(pt) {
    return pt.x + "," + pt.y;
}

function generateElevationWalls(data, elevation) {
    var t1 = Date.now();
    var walls = {};
    for (var key in data) {
        var pt = data[key];
        if (pt.z > elevation) {
            adjLoop:
            for (var i = -1; i <= 1; i++) {
                for (var j = -1; j <= 1; j++) {
                    if (0 !== i || 0 !== j) {
                        var k = (pt.x + i) + "," + (pt.y + j);
                        if (data[k] && data[k].z <= elevation) {
                            walls[pt.key] = pt;
                            break adjLoop;
                        }
                    }
                }
            }
        }
    }
    console.log('generateElevationWalls', Date.now() - t1 + 'ms');
    return walls;
}

function setElevationWalls(obj, data, elevation) {
    for (var i = 0; i < data[elevation].length; i++) {
        var el = data[elevation][i];
        obj[el[1] + "," + el[2]] = el;
    }
}

function setWalls(obj, data, id, r) {
    id = id || 'wall';
    r = r || (Math.SQRT2 / 2);
    for (var i in data) {
        obj[i] = [id, data[i].x, data[i].y, r];
    }
}

function setTreeWalls(obj, elevation, tree, tree_elevations, tree_state, tree_blocks) {
    for (var i in tree) {
        if (elevation < tree_elevations[i]) {
            if (tree_state[i]) {
                //obj[i] = ['tree', tree[i].x, tree[i].y, Math.SQRT2];
                tree_blocks[i].forEach(function (pt) {
                    var k = pt.x + "," + pt.y;
                    obj[k] = (obj[k] || []).concat([['tree', tree[i].x, tree[i].y, Math.SQRT2]]);
                });
            }
        }
    }
}

function VisionSimulation(worlddata, mapDataImagePath, onReady, opts) {
    var self = this;
    
    this.opts = opts || {};
    this.grid = [];
    this.gridnav = null;
    this.ent_fow_blocker_node = null;
    this.tools_no_wards = null;
    this.elevationValues = [];
    this.elevationGrid = null;
    this.elevationWalls = {};
    this.treeWalls = {};
    this.tree = {}; // center key to point map
    this.tree_blocks = {}; // center to corners map
    this.tree_relations = {}; // corner to center map
    this.tree_elevations = {};
    this.tree_state = {};
    this.walls = {};
    this.radius = this.opts.radius || parseInt(1600 / 64);
    this.lights = {};
    this.worldMinX = worlddata.worldMinX;
    this.worldMinY = worlddata.worldMinY;
    this.worldMaxX = worlddata.worldMaxX;
    this.worldMaxY = worlddata.worldMaxY;
    this.worldWidth = this.worldMaxX - this.worldMinX;
    this.worldHeight = this.worldMaxY - this.worldMinY;
    this.gridWidth = this.worldWidth / 64 + 1;
    this.gridHeight = this.worldHeight / 64 + 1;
    this.ready = false;
    this.area = 0;
    
    this.imageHandler = new ImageHandler(mapDataImagePath);
    var t1 = Date.now();
    this.imageHandler.load(function (err) {
        if (!err) {
            var t2 = Date.now();
            console.log('image load', t2 - t1 + 'ms');
            self.gridnav = parseImage(self.imageHandler, self.gridWidth * 2, self.gridWidth, self.gridHeight, blackPixelHandler);
            self.ent_fow_blocker_node = parseImage(self.imageHandler, self.gridWidth * 3, self.gridWidth, self.gridHeight, blackPixelHandler);
            self.tools_no_wards = parseImage(self.imageHandler, self.gridWidth * 4, self.gridWidth, self.gridHeight, blackPixelHandler);
            parseImage(self.imageHandler, self.gridWidth, self.gridWidth, self.gridHeight, treeElevationPixelHandler);
            self.elevationGrid = parseImage(self.imageHandler, 0, self.gridWidth, self.gridHeight, elevationPixelHandler);
            var t3 = Date.now();
            console.log('image process', t3 - t2 + 'ms');
            self.elevationValues.forEach(function (elevation) {
                //self.elevationWalls[elevation] = generateElevationWalls(self.elevationGrid, elevation);
                self.treeWalls[elevation] = {};
                setTreeWalls(self.treeWalls[elevation], elevation, self.tree, self.tree_elevations, self.tree_state, self.tree_blocks)
            });
            var t4 = Date.now();
            console.log('walls generation', t4 - t3 + 'ms');
            for (var i = 0; i < self.gridWidth; i++) {
                self.grid[i] = [];
                for (var j = 0; j < self.gridHeight; j++) {
                    var pt = xy2pt(i, j);
                    key2pt_cache[pt.key] = pt;
                    self.grid[i].push(pt);
                }
            }
            var t5 = Date.now();
            console.log('cache prime', t5 - t4 + 'ms');
            self.ready = true;
        }
        onReady(err);
    });

    function parseImage(imageHandler, offset, width, height, pixelHandler) {
        var grid = {};
        imageHandler.scan(offset, width, height, pixelHandler, grid);
        return grid;
    }

    function blackPixelHandler(x, y, p, grid) {
        var pt = self.ImageXYtoGridXY(x, y);
        if (p[0] === 0) {
            grid[pt.x + "," + pt.y] = pt;
        }
    }

    
    function elevationPixelHandler(x, y, p, grid) {
        var pt = self.ImageXYtoGridXY(x, y);
        pt.z = p[0];
        grid[pt.x + "," + pt.y] = pt;
        if (self.elevationValues.indexOf(p[0]) == -1) {
            self.elevationValues.push(p[0]);
        }
    }

    function treeElevationPixelHandler(x, y, p, grid) {
        var pt = self.ImageXYtoGridXY(x, y);
        if (p[1] == 0 && p[2] == 0) {
            // trees are 2x2 in grid
            // tree origins rounded up when converted to grid, so they represent top right corner. subtract 0.5 to get grid origin
            var treeOrigin = xy2pt(pt.x - 0.5, pt.y - 0.5);
            var treeElevation = p[0] + 40;
            var kC = treeOrigin.key;
            self.tree[kC] = treeOrigin;
            self.tree_elevations[kC] = treeElevation;
            self.tree_blocks[kC] = [];
            self.tree_state[kC] = true;
            // iterate through tree 2x2 by taking floor and ceil of tree grid origin
            [Math.floor, Math.ceil].forEach(function (i) {
                [Math.floor, Math.ceil].forEach(function (j) {
                    var treeCorner = xy2pt(i(treeOrigin.x), j(treeOrigin.y));
                    self.tree_relations[treeCorner.key] = (self.tree_relations[treeCorner.key] || []).concat(treeOrigin);
                    self.tree_blocks[kC].push(treeCorner);
                });
            });
        }
    }

    this.lightPassesCallback = function (x, y) {
        var key = x + ',' + y;
        return !(key in self.elevationWalls[self.elevation]) && !(key in self.ent_fow_blocker_node) && !(key in self.treeWalls[self.elevation] && self.treeWalls[self.elevation][key].length > 0) ;
    }
    
    this.fov = new ROT.FOV.PreciseShadowcasting(this.lightPassesCallback, {topology:8});
}
VisionSimulation.prototype.updateVisibility = function (gX, gY, radius) {
    var self = this,
        key = xy2key(gX, gY);

    radius = radius || self.radius;
    this.elevation = this.elevationGrid[key].z;
    this.walls = this.treeWalls[this.elevation];
    if (!this.elevationWalls[this.elevation]) this.elevationWalls[this.elevation] = generateElevationWalls(this.elevationGrid, this.elevation);
    //setElevationWalls(this.walls, this.elevationWalls, this.elevation)
    //setWalls(this.walls, this.ent_fow_blocker_node);
    //setWalls(this.walls, this.tools_no_wards);
    //setTreeWalls(this.walls, this.elevation, this.tree, this.tree_elevations, this.tree_state, this.tree_blocks);

    this.fov.walls = this.walls;
    this.lights = {};
    this.area = this.fov.compute(gX, gY, radius, function(x2, y2, r, vis) {
        var key = xy2key(x2, y2);
        if (!self.elevationGrid[key]) return;
        var treePts = self.tree_relations[key];
        var treeBlocking = false;
        if (treePts) {
            for (var i = 0; i < treePts.length; i++) {
                var treePt = treePts[i];
                treeBlocking = self.tree_state[treePt.key] && self.tree_elevations[treePt.key] > self.elevation;
                if (treeBlocking) break;
            }
        }
        if (vis == 1 && !self.ent_fow_blocker_node[key] && !treeBlocking) {
            self.lights[key] = 255;
        }
    });
    this.lightArea = Object.keys(this.lights).length;
}

VisionSimulation.prototype.isValidXY = function (x, y, bCheckGridnav, bCheckToolsNoWards, bCheckTreeState) {
    if (!this.ready) return false;
    
    var key = xy2key(x, y),
        treeBlocking = false;
        
    if (bCheckTreeState) {
        var treePts = this.tree_relations[key];
        if (treePts) {
            for (var i = 0; i < treePts.length; i++) {
                var treePt = treePts[i];
                treeBlocking = this.tree_state[treePt.key];
                if (treeBlocking) break;
            }
        }
    }
    
    return x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight && (!bCheckGridnav || !this.gridnav[key]) && (!bCheckToolsNoWards || !this.tools_no_wards[key]) && (!bCheckTreeState || !treeBlocking);
}

VisionSimulation.prototype.toggleTree = function (x, y) {
    var self = this;
    var key = xy2key(x, y);
    var isTree = !!this.tree_relations[key];
    if (isTree) {
        var treePts = this.tree_relations[key];
        for (var i = 0; i < treePts.length; i++) {
            var pt = treePts[i];
            this.tree_state[pt.key] = !this.tree_state[pt.key];
            
            this.elevationValues.forEach(function (elevation) {
                if (elevation < self.tree_elevations[pt.key]) {
                    self.tree_blocks[pt.key].forEach(function (ptB) {
                        for (var j = self.treeWalls[elevation][ptB.key].length - 1; j >= 0; j--) {
                            if (pt.x == self.treeWalls[elevation][ptB.key][j][1] && pt.y == self.treeWalls[elevation][ptB.key][j][2]) {
                                self.treeWalls[elevation][ptB.key].splice(j, 1);
                            }
                        }
                    });
                    if (self.tree_state[pt.key]) {
                        self.tree_blocks[pt.key].forEach(function (ptB) {
                            self.treeWalls[elevation][ptB.key] = (self.treeWalls[elevation][ptB.key] || []).concat([['tree', pt.x, pt.y, Math.SQRT2]]);
                        });
                    }
                }
            });
        }
    }

    return isTree;
}
VisionSimulation.prototype.setRadius = function (r) {
    this.radius = r;
}
VisionSimulation.prototype.WorldXYtoGridXY = function (wX, wY, bNoRound) {
    var x = (wX - this.worldMinX) / 64,
        y = (wY - this.worldMinY) / 64;
    if (!bNoRound) {
        x = parseInt(Math.round(x))
        y = parseInt(Math.round(y))
    }
    return {x: x, y: y, key: x + ',' + y};
}
VisionSimulation.prototype.GridXYtoWorldXY = function (gX, gY) {
    return {x: gX * 64 + this.worldMinX, y: gY * 64 + this.worldMinY};
}

VisionSimulation.prototype.GridXYtoImageXY = function (gX, gY) {
    return {x: gX, y: this.gridHeight - gY - 1};
}

VisionSimulation.prototype.ImageXYtoGridXY = function (x, y) {
    var gY = this.gridHeight - y - 1;
    return {x: x, y: gY, key: x + ',' + gY};
}

VisionSimulation.prototype.WorldXYtoImageXY = function (wX, wY) {
    var pt = this.WorldXYtoGridXY(wX, wY);
    return this.GridXYtoImageXY(pt.x, pt.y);
}

VisionSimulation.prototype.key2pt = key2pt;
VisionSimulation.prototype.xy2key = xy2key;
VisionSimulation.prototype.xy2pt = xy2pt;
VisionSimulation.prototype.pt2key = pt2key;

module.exports = VisionSimulation;
},{"./imageHandler.js":1,"./rot6.js":4}],6:[function(require,module,exports){
module.exports={"worldMinX":-8288,"worldMaxX":8288,"worldMinY":-8288,"worldMaxY":8288}
},{}],7:[function(require,module,exports){
(function (global){
'use strict';function getParameterByName(name){name=name.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var regex=new RegExp("[\\?&]"+name+"=([^&#]*)"),results=regex.exec(location.search);return results==null?"":decodeURIComponent(results[1].replace(/\+/g," "));}function setQueryString(key,value){if(history&&history.replaceState)history.replaceState(null,"",updateQueryString(key,value));}function updateQueryString(key,value,url){if(!url)url=window.location.href;var re=new RegExp("([?&])"+key+"=.*?(&|#|$)(.*)","gi"),hash;if(re.test(url)){if(typeof value!=='undefined'&&value!==null)return url.replace(re,'$1'+key+"="+value+'$2$3');else{hash=url.split('#');url=hash[0].replace(re,'$1$3').replace(/(&|\?)$/,'');if(typeof hash[1]!=='undefined'&&hash[1]!==null)url+='#'+hash[1];return url;}}else{if(typeof value!=='undefined'&&value!==null){var separator=url.indexOf('?')!==-1?'&':'?';hash=url.split('#');url=hash[0]+separator+key+'='+value;if(typeof hash[1]!=='undefined'&&hash[1]!==null)url+='#'+hash[1];return url;}else{return url;}}}var _ol_={};/**
 * Constants defined with the define tag cannot be changed in application
 * code, but can be set at compile time.
 * Some reduce the size of the build in advanced compile mode.
 *//**
 * @define {boolean} Assume touch.  Default is `false`.
 */_ol_.ASSUME_TOUCH=false;/**
 * TODO: rename this to something having to do with tile grids
 * see https://github.com/openlayers/openlayers/issues/2076
 * @define {number} Default maximum zoom for default tile grids.
 */_ol_.DEFAULT_MAX_ZOOM=42;/**
 * @define {number} Default min zoom level for the map view.  Default is `0`.
 */_ol_.DEFAULT_MIN_ZOOM=0;/**
 * @define {number} Default maximum allowed threshold  (in pixels) for
 *     reprojection triangulation. Default is `0.5`.
 */_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD=0.5;/**
 * @define {number} Default tile size.
 */_ol_.DEFAULT_TILE_SIZE=256;/**
 * @define {string} Default WMS version.
 */_ol_.DEFAULT_WMS_VERSION='1.3.0';/**
 * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the Canvas renderer from the build.
 */_ol_.ENABLE_CANVAS=true;/**
 * @define {boolean} Enable integration with the Proj4js library.  Default is
 *     `true`.
 */_ol_.ENABLE_PROJ4JS=true;/**
 * @define {boolean} Enable automatic reprojection of raster sources. Default is
 *     `true`.
 */_ol_.ENABLE_RASTER_REPROJECTION=true;/**
 * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the WebGL renderer from the build.
 */_ol_.ENABLE_WEBGL=true;/**
 * @define {boolean} Include debuggable shader sources.  Default is `true`.
 *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`
 *     is `true`).
 */_ol_.DEBUG_WEBGL=true;/**
 * @define {number} The size in pixels of the first atlas image. Default is
 * `256`.
 */_ol_.INITIAL_ATLAS_SIZE=256;/**
 * @define {number} The maximum size in pixels of atlas images. Default is
 * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is
 * used instead).
 */_ol_.MAX_ATLAS_SIZE=-1;/**
 * @define {number} Maximum mouse wheel delta.
 */_ol_.MOUSEWHEELZOOM_MAXDELTA=1;/**
 * @define {number} Maximum width and/or height extent ratio that determines
 * when the overview map should be zoomed out.
 */_ol_.OVERVIEWMAP_MAX_RATIO=0.75;/**
 * @define {number} Minimum width and/or height extent ratio that determines
 * when the overview map should be zoomed in.
 */_ol_.OVERVIEWMAP_MIN_RATIO=0.1;/**
 * @define {number} Maximum number of source tiles for raster reprojection of
 *     a single tile.
 *     If too many source tiles are determined to be loaded to create a single
 *     reprojected tile the browser can become unresponsive or even crash.
 *     This can happen if the developer defines projections improperly and/or
 *     with unlimited extents.
 *     If too many tiles are required, no tiles are loaded and
 *     `ol.TileState.ERROR` state is set. Default is `100`.
 */_ol_.RASTER_REPROJECTION_MAX_SOURCE_TILES=100;/**
 * @define {number} Maximum number of subdivision steps during raster
 *     reprojection triangulation. Prevents high memory usage and large
 *     number of proj4 calls (for certain transformations and areas).
 *     At most `2*(2^this)` triangles are created for each triangulated
 *     extent (tile/image). Default is `10`.
 */_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION=10;/**
 * @define {number} Maximum allowed size of triangle relative to world width.
 *     When transforming corners of world extent between certain projections,
 *     the resulting triangulation seems to have zero error and no subdivision
 *     is performed.
 *     If the triangle width is more than this (relative to world width; 0-1),
 *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).
 *     Default is `0.25`.
 */_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH=0.25;/**
 * @define {number} Tolerance for geometry simplification in device pixels.
 */_ol_.SIMPLIFY_TOLERANCE=0.5;/**
 * @define {number} Texture cache high water mark.
 */_ol_.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK=1024;/**
 * @define {string} OpenLayers version.
 */_ol_.VERSION='v4.3.1';/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     ol.inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */_ol_.inherits=function(childCtor,parentCtor){childCtor.prototype=Object.create(parentCtor.prototype);childCtor.prototype.constructor=childCtor;};/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */_ol_.nullFunction=function(){};/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */_ol_.getUid=function(obj){return obj.ol_uid||(obj.ol_uid=++_ol_.uidCounter_);};/**
 * Counter for getUid.
 * @type {number}
 * @private
 */_ol_.uidCounter_=0;/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @implements {oli.AssertionError}
 * @param {number} code Error code.
 */var _ol_AssertionError_=function(code){var path=_ol_.VERSION?_ol_.VERSION.split('-')[0]:'latest';/**
   * @type {string}
   */this.message='Assertion failed. See https://openlayers.org/en/'+path+'/doc/errors/#'+code+' for details.';/**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */this.code=code;this.name='AssertionError';};_ol_.inherits(_ol_AssertionError_,Error);var _ol_asserts_={};/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */_ol_asserts_.assert=function(assertion,errorCode){if(!assertion){throw new _ol_AssertionError_(errorCode);}};var _ol_math_={};/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */_ol_math_.clamp=function(value,min,max){return Math.min(Math.max(value,min),max);};/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */_ol_math_.cosh=function(){// Wrapped in a iife, to save the overhead of checking for the native
// implementation on every invocation.
var cosh;if('cosh'in Math){// The environment supports the native Math.cosh function, use it
cosh=Math.cosh;}else{//  else, use the reference implementation of MDN:
cosh=function(x){var y=Math.exp(x);return(y+1/y)/2;};}return cosh;}();/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */_ol_math_.roundUpToPowerOfTwo=function(x){_ol_asserts_.assert(0<x,29);// `x` must be greater than `0`
return Math.pow(2,Math.ceil(Math.log(x)/Math.LN2));};/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */_ol_math_.squaredSegmentDistance=function(x,y,x1,y1,x2,y2){var dx=x2-x1;var dy=y2-y1;if(dx!==0||dy!==0){var t=((x-x1)*dx+(y-y1)*dy)/(dx*dx+dy*dy);if(t>1){x1=x2;y1=y2;}else if(t>0){x1+=dx*t;y1+=dy*t;}}return _ol_math_.squaredDistance(x,y,x1,y1);};/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */_ol_math_.squaredDistance=function(x1,y1,x2,y2){var dx=x2-x1;var dy=y2-y1;return dx*dx+dy*dy;};/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */_ol_math_.solveLinearSystem=function(mat){var n=mat.length;for(var i=0;i<n;i++){// Find max in the i-th column (ignoring i - 1 first rows)
var maxRow=i;var maxEl=Math.abs(mat[i][i]);for(var r=i+1;r<n;r++){var absValue=Math.abs(mat[r][i]);if(absValue>maxEl){maxEl=absValue;maxRow=r;}}if(maxEl===0){return null;// matrix is singular
}// Swap max row with i-th (current) row
var tmp=mat[maxRow];mat[maxRow]=mat[i];mat[i]=tmp;// Subtract the i-th row to make all the remaining rows 0 in the i-th column
for(var j=i+1;j<n;j++){var coef=-mat[j][i]/mat[i][i];for(var k=i;k<n+1;k++){if(i==k){mat[j][k]=0;}else{mat[j][k]+=coef*mat[i][k];}}}}// Solve Ax=b for upper triangular matrix A (mat)
var x=new Array(n);for(var l=n-1;l>=0;l--){x[l]=mat[l][n]/mat[l][l];for(var m=l-1;m>=0;m--){mat[m][n]-=mat[m][l]*x[l];}}return x;};/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */_ol_math_.toDegrees=function(angleInRadians){return angleInRadians*180/Math.PI;};/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */_ol_math_.toRadians=function(angleInDegrees){return angleInDegrees*Math.PI/180;};/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */_ol_math_.modulo=function(a,b){var r=a%b;return r*b<0?r+b:r;};/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */_ol_math_.lerp=function(a,b,x){return a+x*(b-a);};/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */var _ol_geom_GeometryType_={POINT:'Point',LINE_STRING:'LineString',LINEAR_RING:'LinearRing',POLYGON:'Polygon',MULTI_POINT:'MultiPoint',MULTI_LINE_STRING:'MultiLineString',MULTI_POLYGON:'MultiPolygon',GEOMETRY_COLLECTION:'GeometryCollection',CIRCLE:'Circle'};/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 *//**
 * @classdesc
 * Class to create objects that can be used with {@link
 * ol.geom.Polygon.circular}.
 *
 * For example to create a sphere whose radius is equal to the semi-major
 * axis of the WGS84 ellipsoid:
 *
 * ```js
 * var wgs84Sphere= new ol.Sphere(6378137);
 * ```
 *
 * @constructor
 * @param {number} radius Radius.
 * @api
 */var _ol_Sphere_=function(radius){/**
   * @type {number}
   */this.radius=radius;};/**
 * Returns the geodesic area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @return {number} Area.
 * @api
 */_ol_Sphere_.prototype.geodesicArea=function(coordinates){return _ol_Sphere_.getArea_(coordinates,this.radius);};/**
 * Returns the distance from c1 to c2 using the haversine formula.
 *
 * @param {ol.Coordinate} c1 Coordinate 1.
 * @param {ol.Coordinate} c2 Coordinate 2.
 * @return {number} Haversine distance.
 * @api
 */_ol_Sphere_.prototype.haversineDistance=function(c1,c2){return _ol_Sphere_.getDistance_(c1,c2,this.radius);};/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @return {ol.Coordinate} The target point.
 */_ol_Sphere_.prototype.offset=function(c1,distance,bearing){var lat1=_ol_math_.toRadians(c1[1]);var lon1=_ol_math_.toRadians(c1[0]);var dByR=distance/this.radius;var lat=Math.asin(Math.sin(lat1)*Math.cos(dByR)+Math.cos(lat1)*Math.sin(dByR)*Math.cos(bearing));var lon=lon1+Math.atan2(Math.sin(bearing)*Math.sin(dByR)*Math.cos(lat1),Math.cos(dByR)-Math.sin(lat1)*Math.sin(lat));return[_ol_math_.toDegrees(lon),_ol_math_.toDegrees(lat)];};/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */_ol_Sphere_.DEFAULT_RADIUS=6371008.8;/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the length
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 */_ol_Sphere_.getLength=function(geometry,opt_options){var options=opt_options||{};var radius=options.radius||_ol_Sphere_.DEFAULT_RADIUS;var projection=options.projection||'EPSG:3857';geometry=geometry.clone().transform(projection,'EPSG:4326');var type=geometry.getType();var length=0;var coordinates,coords,i,ii,j,jj;switch(type){case _ol_geom_GeometryType_.POINT:case _ol_geom_GeometryType_.MULTI_POINT:{break;}case _ol_geom_GeometryType_.LINE_STRING:case _ol_geom_GeometryType_.LINEAR_RING:{coordinates=/** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();length=_ol_Sphere_.getLength_(coordinates,radius);break;}case _ol_geom_GeometryType_.MULTI_LINE_STRING:case _ol_geom_GeometryType_.POLYGON:{coordinates=/** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();for(i=0,ii=coordinates.length;i<ii;++i){length+=_ol_Sphere_.getLength_(coordinates[i],radius);}break;}case _ol_geom_GeometryType_.MULTI_POLYGON:{coordinates=/** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();for(i=0,ii=coordinates.length;i<ii;++i){coords=coordinates[i];for(j=0,jj=coords.length;j<jj;++j){length+=_ol_Sphere_.getLength_(coords[j],radius);}}break;}case _ol_geom_GeometryType_.GEOMETRY_COLLECTION:{var geometries=/** @type {ol.geom.GeometryCollection} */geometry.getGeometries();for(i=0,ii=geometries.length;i<ii;++i){length+=_ol_Sphere_.getLength(geometries[i],opt_options);}break;}default:{throw new Error('Unsupported geometry type: '+type);}}return length;};/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */_ol_Sphere_.getLength_=function(coordinates,radius){var length=0;for(var i=0,ii=coordinates.length;i<ii-1;++i){length+=_ol_Sphere_.getDistance_(coordinates[i],coordinates[i+1],radius);}return length;};/**
 * Get the great circle distance between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} radius The sphere radius to use.
 * @return {number} The great circle distance between the points (in meters).
 */_ol_Sphere_.getDistance_=function(c1,c2,radius){var lat1=_ol_math_.toRadians(c1[1]);var lat2=_ol_math_.toRadians(c2[1]);var deltaLatBy2=(lat2-lat1)/2;var deltaLonBy2=_ol_math_.toRadians(c2[0]-c1[0])/2;var a=Math.sin(deltaLatBy2)*Math.sin(deltaLatBy2)+Math.sin(deltaLonBy2)*Math.sin(deltaLonBy2)*Math.cos(lat1)*Math.cos(lat2);return 2*radius*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));};/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 */_ol_Sphere_.getArea=function(geometry,opt_options){var options=opt_options||{};var radius=options.radius||_ol_Sphere_.DEFAULT_RADIUS;var projection=options.projection||'EPSG:3857';geometry=geometry.clone().transform(projection,'EPSG:4326');var type=geometry.getType();var area=0;var coordinates,coords,i,ii,j,jj;switch(type){case _ol_geom_GeometryType_.POINT:case _ol_geom_GeometryType_.MULTI_POINT:case _ol_geom_GeometryType_.LINE_STRING:case _ol_geom_GeometryType_.MULTI_LINE_STRING:case _ol_geom_GeometryType_.LINEAR_RING:{break;}case _ol_geom_GeometryType_.POLYGON:{coordinates=/** @type {ol.geom.Polygon} */geometry.getCoordinates();area=Math.abs(_ol_Sphere_.getArea_(coordinates[0],radius));for(i=1,ii=coordinates.length;i<ii;++i){area-=Math.abs(_ol_Sphere_.getArea_(coordinates[i],radius));}break;}case _ol_geom_GeometryType_.MULTI_POLYGON:{coordinates=/** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();for(i=0,ii=coordinates.length;i<ii;++i){coords=coordinates[i];area+=Math.abs(_ol_Sphere_.getArea_(coords[0],radius));for(j=1,jj=coords.length;j<jj;++j){area-=Math.abs(_ol_Sphere_.getArea_(coords[j],radius));}}break;}case _ol_geom_GeometryType_.GEOMETRY_COLLECTION:{var geometries=/** @type {ol.geom.GeometryCollection} */geometry.getGeometries();for(i=0,ii=geometries.length;i<ii;++i){area+=_ol_Sphere_.getArea(geometries[i],opt_options);}break;}default:{throw new Error('Unsupported geometry type: '+type);}}return area;};/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */_ol_Sphere_.getArea_=function(coordinates,radius){var area=0,len=coordinates.length;var x1=coordinates[len-1][0];var y1=coordinates[len-1][1];for(var i=0;i<len;i++){var x2=coordinates[i][0],y2=coordinates[i][1];area+=_ol_math_.toRadians(x2-x1)*(2+Math.sin(_ol_math_.toRadians(y1))+Math.sin(_ol_math_.toRadians(y2)));x1=x2;y1=y2;}return area*radius*radius/2.0;};/**
 * Extent corner.
 * @enum {string}
 */var _ol_extent_Corner_={BOTTOM_LEFT:'bottom-left',BOTTOM_RIGHT:'bottom-right',TOP_LEFT:'top-left',TOP_RIGHT:'top-right'};/**
 * Relationship to an extent.
 * @enum {number}
 */var _ol_extent_Relationship_={UNKNOWN:0,INTERSECTING:1,ABOVE:2,RIGHT:4,BELOW:8,LEFT:16};var _ol_extent_={};/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Bounding extent.
 * @api
 */_ol_extent_.boundingExtent=function(coordinates){var extent=_ol_extent_.createEmpty();for(var i=0,ii=coordinates.length;i<ii;++i){_ol_extent_.extendCoordinate(extent,coordinates[i]);}return extent;};/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @private
 * @return {ol.Extent} Extent.
 */_ol_extent_.boundingExtentXYs_=function(xs,ys,opt_extent){var minX=Math.min.apply(null,xs);var minY=Math.min.apply(null,ys);var maxX=Math.max.apply(null,xs);var maxY=Math.max.apply(null,ys);return _ol_extent_.createOrUpdate(minX,minY,maxX,maxY,opt_extent);};/**
 * Return extent increased by the provided value.
 * @param {ol.Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 * @api
 */_ol_extent_.buffer=function(extent,value,opt_extent){if(opt_extent){opt_extent[0]=extent[0]-value;opt_extent[1]=extent[1]-value;opt_extent[2]=extent[2]+value;opt_extent[3]=extent[3]+value;return opt_extent;}else{return[extent[0]-value,extent[1]-value,extent[2]+value,extent[3]+value];}};/**
 * Creates a clone of an extent.
 *
 * @param {ol.Extent} extent Extent to clone.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} The clone.
 */_ol_extent_.clone=function(extent,opt_extent){if(opt_extent){opt_extent[0]=extent[0];opt_extent[1]=extent[1];opt_extent[2]=extent[2];opt_extent[3]=extent[3];return opt_extent;}else{return extent.slice();}};/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */_ol_extent_.closestSquaredDistanceXY=function(extent,x,y){var dx,dy;if(x<extent[0]){dx=extent[0]-x;}else if(extent[2]<x){dx=x-extent[2];}else{dx=0;}if(y<extent[1]){dy=extent[1]-y;}else if(extent[3]<y){dy=y-extent[3];}else{dy=0;}return dx*dx+dy*dy;};/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */_ol_extent_.containsCoordinate=function(extent,coordinate){return _ol_extent_.containsXY(extent,coordinate[0],coordinate[1]);};/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */_ol_extent_.containsExtent=function(extent1,extent2){return extent1[0]<=extent2[0]&&extent2[2]<=extent1[2]&&extent1[1]<=extent2[1]&&extent2[3]<=extent1[3];};/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */_ol_extent_.containsXY=function(extent,x,y){return extent[0]<=x&&x<=extent[2]&&extent[1]<=y&&y<=extent[3];};/**
 * Get the relationship between a coordinate and extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} coordinate The coordinate.
 * @return {number} The relationship (bitwise compare with
 *     ol.extent.Relationship).
 */_ol_extent_.coordinateRelationship=function(extent,coordinate){var minX=extent[0];var minY=extent[1];var maxX=extent[2];var maxY=extent[3];var x=coordinate[0];var y=coordinate[1];var relationship=_ol_extent_Relationship_.UNKNOWN;if(x<minX){relationship=relationship|_ol_extent_Relationship_.LEFT;}else if(x>maxX){relationship=relationship|_ol_extent_Relationship_.RIGHT;}if(y<minY){relationship=relationship|_ol_extent_Relationship_.BELOW;}else if(y>maxY){relationship=relationship|_ol_extent_Relationship_.ABOVE;}if(relationship===_ol_extent_Relationship_.UNKNOWN){relationship=_ol_extent_Relationship_.INTERSECTING;}return relationship;};/**
 * Create an empty extent.
 * @return {ol.Extent} Empty extent.
 * @api
 */_ol_extent_.createEmpty=function(){return[Infinity,Infinity,-Infinity,-Infinity];};/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.createOrUpdate=function(minX,minY,maxX,maxY,opt_extent){if(opt_extent){opt_extent[0]=minX;opt_extent[1]=minY;opt_extent[2]=maxX;opt_extent[3]=maxY;return opt_extent;}else{return[minX,minY,maxX,maxY];}};/**
 * Create a new empty extent or make the provided one empty.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.createOrUpdateEmpty=function(opt_extent){return _ol_extent_.createOrUpdate(Infinity,Infinity,-Infinity,-Infinity,opt_extent);};/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.createOrUpdateFromCoordinate=function(coordinate,opt_extent){var x=coordinate[0];var y=coordinate[1];return _ol_extent_.createOrUpdate(x,y,x,y,opt_extent);};/**
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.createOrUpdateFromCoordinates=function(coordinates,opt_extent){var extent=_ol_extent_.createOrUpdateEmpty(opt_extent);return _ol_extent_.extendCoordinates(extent,coordinates);};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.createOrUpdateFromFlatCoordinates=function(flatCoordinates,offset,end,stride,opt_extent){var extent=_ol_extent_.createOrUpdateEmpty(opt_extent);return _ol_extent_.extendFlatCoordinates(extent,flatCoordinates,offset,end,stride);};/**
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.createOrUpdateFromRings=function(rings,opt_extent){var extent=_ol_extent_.createOrUpdateEmpty(opt_extent);return _ol_extent_.extendRings(extent,rings);};/**
 * Determine if two extents are equivalent.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */_ol_extent_.equals=function(extent1,extent2){return extent1[0]==extent2[0]&&extent1[2]==extent2[2]&&extent1[1]==extent2[1]&&extent1[3]==extent2[3];};/**
 * Modify an extent to include another extent.
 * @param {ol.Extent} extent1 The extent to be modified.
 * @param {ol.Extent} extent2 The extent that will be included in the first.
 * @return {ol.Extent} A reference to the first (extended) extent.
 * @api
 */_ol_extent_.extend=function(extent1,extent2){if(extent2[0]<extent1[0]){extent1[0]=extent2[0];}if(extent2[2]>extent1[2]){extent1[2]=extent2[2];}if(extent2[1]<extent1[1]){extent1[1]=extent2[1];}if(extent2[3]>extent1[3]){extent1[3]=extent2[3];}return extent1;};/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 */_ol_extent_.extendCoordinate=function(extent,coordinate){if(coordinate[0]<extent[0]){extent[0]=coordinate[0];}if(coordinate[0]>extent[2]){extent[2]=coordinate[0];}if(coordinate[1]<extent[1]){extent[1]=coordinate[1];}if(coordinate[1]>extent[3]){extent[3]=coordinate[1];}};/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Extent.
 */_ol_extent_.extendCoordinates=function(extent,coordinates){var i,ii;for(i=0,ii=coordinates.length;i<ii;++i){_ol_extent_.extendCoordinate(extent,coordinates[i]);}return extent;};/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {ol.Extent} Extent.
 */_ol_extent_.extendFlatCoordinates=function(extent,flatCoordinates,offset,end,stride){for(;offset<end;offset+=stride){_ol_extent_.extendXY(extent,flatCoordinates[offset],flatCoordinates[offset+1]);}return extent;};/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @return {ol.Extent} Extent.
 */_ol_extent_.extendRings=function(extent,rings){var i,ii;for(i=0,ii=rings.length;i<ii;++i){_ol_extent_.extendCoordinates(extent,rings[i]);}return extent;};/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */_ol_extent_.extendXY=function(extent,x,y){extent[0]=Math.min(extent[0],x);extent[1]=Math.min(extent[1],y);extent[2]=Math.max(extent[2],x);extent[3]=Math.max(extent[3],y);};/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {ol.Extent} extent Extent.
 * @param {function(this:T, ol.Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */_ol_extent_.forEachCorner=function(extent,callback,opt_this){var val;val=callback.call(opt_this,_ol_extent_.getBottomLeft(extent));if(val){return val;}val=callback.call(opt_this,_ol_extent_.getBottomRight(extent));if(val){return val;}val=callback.call(opt_this,_ol_extent_.getTopRight(extent));if(val){return val;}val=callback.call(opt_this,_ol_extent_.getTopLeft(extent));if(val){return val;}return false;};/**
 * Get the size of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Area.
 * @api
 */_ol_extent_.getArea=function(extent){var area=0;if(!_ol_extent_.isEmpty(extent)){area=_ol_extent_.getWidth(extent)*_ol_extent_.getHeight(extent);}return area;};/**
 * Get the bottom left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom left coordinate.
 * @api
 */_ol_extent_.getBottomLeft=function(extent){return[extent[0],extent[1]];};/**
 * Get the bottom right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom right coordinate.
 * @api
 */_ol_extent_.getBottomRight=function(extent){return[extent[2],extent[1]];};/**
 * Get the center coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Center.
 * @api
 */_ol_extent_.getCenter=function(extent){return[(extent[0]+extent[2])/2,(extent[1]+extent[3])/2];};/**
 * Get a corner coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.extent.Corner} corner Corner.
 * @return {ol.Coordinate} Corner coordinate.
 */_ol_extent_.getCorner=function(extent,corner){var coordinate;if(corner===_ol_extent_Corner_.BOTTOM_LEFT){coordinate=_ol_extent_.getBottomLeft(extent);}else if(corner===_ol_extent_Corner_.BOTTOM_RIGHT){coordinate=_ol_extent_.getBottomRight(extent);}else if(corner===_ol_extent_Corner_.TOP_LEFT){coordinate=_ol_extent_.getTopLeft(extent);}else if(corner===_ol_extent_Corner_.TOP_RIGHT){coordinate=_ol_extent_.getTopRight(extent);}else{_ol_asserts_.assert(false,13);// Invalid corner
}return(/** @type {!ol.Coordinate} */coordinate);};/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */_ol_extent_.getEnlargedArea=function(extent1,extent2){var minX=Math.min(extent1[0],extent2[0]);var minY=Math.min(extent1[1],extent2[1]);var maxX=Math.max(extent1[2],extent2[2]);var maxY=Math.max(extent1[3],extent2[3]);return(maxX-minX)*(maxY-minY);};/**
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.getForViewAndSize=function(center,resolution,rotation,size,opt_extent){var dx=resolution*size[0]/2;var dy=resolution*size[1]/2;var cosRotation=Math.cos(rotation);var sinRotation=Math.sin(rotation);var xCos=dx*cosRotation;var xSin=dx*sinRotation;var yCos=dy*cosRotation;var ySin=dy*sinRotation;var x=center[0];var y=center[1];var x0=x-xCos+ySin;var x1=x-xCos-ySin;var x2=x+xCos-ySin;var x3=x+xCos+ySin;var y0=y-xSin-yCos;var y1=y-xSin+yCos;var y2=y+xSin+yCos;var y3=y+xSin-yCos;return _ol_extent_.createOrUpdate(Math.min(x0,x1,x2,x3),Math.min(y0,y1,y2,y3),Math.max(x0,x1,x2,x3),Math.max(y0,y1,y2,y3),opt_extent);};/**
 * Get the height of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Height.
 * @api
 */_ol_extent_.getHeight=function(extent){return extent[3]-extent[1];};/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */_ol_extent_.getIntersectionArea=function(extent1,extent2){var intersection=_ol_extent_.getIntersection(extent1,extent2);return _ol_extent_.getArea(intersection);};/**
 * Get the intersection of two extents.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @param {ol.Extent=} opt_extent Optional extent to populate with intersection.
 * @return {ol.Extent} Intersecting extent.
 * @api
 */_ol_extent_.getIntersection=function(extent1,extent2,opt_extent){var intersection=opt_extent?opt_extent:_ol_extent_.createEmpty();if(_ol_extent_.intersects(extent1,extent2)){if(extent1[0]>extent2[0]){intersection[0]=extent1[0];}else{intersection[0]=extent2[0];}if(extent1[1]>extent2[1]){intersection[1]=extent1[1];}else{intersection[1]=extent2[1];}if(extent1[2]<extent2[2]){intersection[2]=extent1[2];}else{intersection[2]=extent2[2];}if(extent1[3]<extent2[3]){intersection[3]=extent1[3];}else{intersection[3]=extent2[3];}}return intersection;};/**
 * @param {ol.Extent} extent Extent.
 * @return {number} Margin.
 */_ol_extent_.getMargin=function(extent){return _ol_extent_.getWidth(extent)+_ol_extent_.getHeight(extent);};/**
 * Get the size (width, height) of an extent.
 * @param {ol.Extent} extent The extent.
 * @return {ol.Size} The extent size.
 * @api
 */_ol_extent_.getSize=function(extent){return[extent[2]-extent[0],extent[3]-extent[1]];};/**
 * Get the top left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top left coordinate.
 * @api
 */_ol_extent_.getTopLeft=function(extent){return[extent[0],extent[3]];};/**
 * Get the top right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top right coordinate.
 * @api
 */_ol_extent_.getTopRight=function(extent){return[extent[2],extent[3]];};/**
 * Get the width of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Width.
 * @api
 */_ol_extent_.getWidth=function(extent){return extent[2]-extent[0];};/**
 * Determine if one extent intersects another.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */_ol_extent_.intersects=function(extent1,extent2){return extent1[0]<=extent2[2]&&extent1[2]>=extent2[0]&&extent1[1]<=extent2[3]&&extent1[3]>=extent2[1];};/**
 * Determine if an extent is empty.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */_ol_extent_.isEmpty=function(extent){return extent[2]<extent[0]||extent[3]<extent[1];};/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */_ol_extent_.returnOrUpdate=function(extent,opt_extent){if(opt_extent){opt_extent[0]=extent[0];opt_extent[1]=extent[1];opt_extent[2]=extent[2];opt_extent[3]=extent[3];return opt_extent;}else{return extent;}};/**
 * @param {ol.Extent} extent Extent.
 * @param {number} value Value.
 */_ol_extent_.scaleFromCenter=function(extent,value){var deltaX=(extent[2]-extent[0])/2*(value-1);var deltaY=(extent[3]-extent[1])/2*(value-1);extent[0]-=deltaX;extent[2]+=deltaX;extent[1]-=deltaY;extent[3]+=deltaY;};/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} start Segment start coordinate.
 * @param {ol.Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */_ol_extent_.intersectsSegment=function(extent,start,end){var intersects=false;var startRel=_ol_extent_.coordinateRelationship(extent,start);var endRel=_ol_extent_.coordinateRelationship(extent,end);if(startRel===_ol_extent_Relationship_.INTERSECTING||endRel===_ol_extent_Relationship_.INTERSECTING){intersects=true;}else{var minX=extent[0];var minY=extent[1];var maxX=extent[2];var maxY=extent[3];var startX=start[0];var startY=start[1];var endX=end[0];var endY=end[1];var slope=(endY-startY)/(endX-startX);var x,y;if(!!(endRel&_ol_extent_Relationship_.ABOVE)&&!(startRel&_ol_extent_Relationship_.ABOVE)){// potentially intersects top
x=endX-(endY-maxY)/slope;intersects=x>=minX&&x<=maxX;}if(!intersects&&!!(endRel&_ol_extent_Relationship_.RIGHT)&&!(startRel&_ol_extent_Relationship_.RIGHT)){// potentially intersects right
y=endY-(endX-maxX)*slope;intersects=y>=minY&&y<=maxY;}if(!intersects&&!!(endRel&_ol_extent_Relationship_.BELOW)&&!(startRel&_ol_extent_Relationship_.BELOW)){// potentially intersects bottom
x=endX-(endY-minY)/slope;intersects=x>=minX&&x<=maxX;}if(!intersects&&!!(endRel&_ol_extent_Relationship_.LEFT)&&!(startRel&_ol_extent_Relationship_.LEFT)){// potentially intersects left
y=endY-(endX-minX)*slope;intersects=y>=minY&&y<=maxY;}}return intersects;};/**
 * Apply a transform function to the extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.TransformFunction} transformFn Transform function.  Called with
 * [minX, minY, maxX, maxY] extent coordinates.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 * @api
 */_ol_extent_.applyTransform=function(extent,transformFn,opt_extent){var coordinates=[extent[0],extent[1],extent[0],extent[3],extent[2],extent[1],extent[2],extent[3]];transformFn(coordinates,coordinates,2);var xs=[coordinates[0],coordinates[2],coordinates[4],coordinates[6]];var ys=[coordinates[1],coordinates[3],coordinates[5],coordinates[7]];return _ol_extent_.boundingExtentXYs_(xs,ys,opt_extent);};/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */var _ol_proj_Units_={DEGREES:'degrees',FEET:'ft',METERS:'m',PIXELS:'pixels',TILE_PIXELS:'tile-pixels',USFEET:'us-ft'};/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */_ol_proj_Units_.METERS_PER_UNIT={};// use the radius of the Normal sphere
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES]=2*Math.PI*6370997/360;_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.FEET]=0.3048;_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.METERS]=1;_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.USFEET]=1200/3937;var _ol_proj_proj4_={};/**
 * @private
 * @type {Proj4}
 */_ol_proj_proj4_.cache_=null;/**
 * Store the proj4 function.
 * @param {Proj4} proj4 The proj4 function.
 */_ol_proj_proj4_.set=function(proj4){_ol_proj_proj4_.cache_=proj4;};/**
 * Get proj4.
 * @return {Proj4} The proj4 function set above or available globally.
 */_ol_proj_proj4_.get=function(){return _ol_proj_proj4_.cache_||window['proj4'];};/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link ol.proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link ol.ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link ol.proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {@link ol.proj.setProj4}.
 *
 * @constructor
 * @param {olx.ProjectionOptions} options Projection options.
 * @struct
 * @api
 */var _ol_proj_Projection_$1=function(options){/**
   * @private
   * @type {string}
   */this.code_=options.code;/**
   * @private
   * @type {ol.proj.Units}
   */this.units_=/** @type {ol.proj.Units} */options.units;/**
   * @private
   * @type {ol.Extent}
   */this.extent_=options.extent!==undefined?options.extent:null;/**
   * @private
   * @type {ol.Extent}
   */this.worldExtent_=options.worldExtent!==undefined?options.worldExtent:null;/**
   * @private
   * @type {string}
   */this.axisOrientation_=options.axisOrientation!==undefined?options.axisOrientation:'enu';/**
   * @private
   * @type {boolean}
   */this.global_=options.global!==undefined?options.global:false;/**
   * @private
   * @type {boolean}
   */this.canWrapX_=!!(this.global_&&this.extent_);/**
   * @private
   * @type {function(number, ol.Coordinate):number|undefined}
   */this.getPointResolutionFunc_=options.getPointResolution;/**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */this.defaultTileGrid_=null;/**
   * @private
   * @type {number|undefined}
   */this.metersPerUnit_=options.metersPerUnit;var code=options.code;if(_ol_.ENABLE_PROJ4JS){var proj4js=_ol_proj_proj4_.get();if(typeof proj4js=='function'){var def=proj4js.defs(code);if(def!==undefined){if(def.axis!==undefined&&options.axisOrientation===undefined){this.axisOrientation_=def.axis;}if(options.metersPerUnit===undefined){this.metersPerUnit_=def.to_meter;}if(options.units===undefined){this.units_=def.units;}}}}};/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */_ol_proj_Projection_$1.prototype.canWrapX=function(){return this.canWrapX_;};/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */_ol_proj_Projection_$1.prototype.getCode=function(){return this.code_;};/**
 * Get the validity extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */_ol_proj_Projection_$1.prototype.getExtent=function(){return this.extent_;};/**
 * Get the units of this projection.
 * @return {ol.proj.Units} Units.
 * @api
 */_ol_proj_Projection_$1.prototype.getUnits=function(){return this.units_;};/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */_ol_proj_Projection_$1.prototype.getMetersPerUnit=function(){return this.metersPerUnit_||_ol_proj_Units_.METERS_PER_UNIT[this.units_];};/**
 * Get the world extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */_ol_proj_Projection_$1.prototype.getWorldExtent=function(){return this.worldExtent_;};/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *     or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *     "west positive" coordinate systems
 * @return {string} Axis orientation.
 */_ol_proj_Projection_$1.prototype.getAxisOrientation=function(){return this.axisOrientation_;};/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */_ol_proj_Projection_$1.prototype.isGlobal=function(){return this.global_;};/**
* Set if the projection is a global projection which spans the whole world
* @param {boolean} global Whether the projection is global.
* @api
*/_ol_proj_Projection_$1.prototype.setGlobal=function(global){this.global_=global;this.canWrapX_=!!(global&&this.extent_);};/**
 * @return {ol.tilegrid.TileGrid} The default tile grid.
 */_ol_proj_Projection_$1.prototype.getDefaultTileGrid=function(){return this.defaultTileGrid_;};/**
 * @param {ol.tilegrid.TileGrid} tileGrid The default tile grid.
 */_ol_proj_Projection_$1.prototype.setDefaultTileGrid=function(tileGrid){this.defaultTileGrid_=tileGrid;};/**
 * Set the validity extent for this projection.
 * @param {ol.Extent} extent Extent.
 * @api
 */_ol_proj_Projection_$1.prototype.setExtent=function(extent){this.extent_=extent;this.canWrapX_=!!(this.global_&&extent);};/**
 * Set the world extent for this projection.
 * @param {ol.Extent} worldExtent World extent
 *     [minlon, minlat, maxlon, maxlat].
 * @api
 */_ol_proj_Projection_$1.prototype.setWorldExtent=function(worldExtent){this.worldExtent_=worldExtent;};/**
 * Set the getPointResolution function (see {@link ol.proj#getPointResolution}
 * for this projection.
 * @param {function(number, ol.Coordinate):number} func Function
 * @api
 */_ol_proj_Projection_$1.prototype.setGetPointResolution=function(func){this.getPointResolutionFunc_=func;};/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, ol.Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */_ol_proj_Projection_$1.prototype.getPointResolutionFunc=function(){return this.getPointResolutionFunc_;};var _ol_proj_EPSG3857_={};/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @private
 */_ol_proj_EPSG3857_.Projection_=function(code){_ol_proj_Projection_$1.call(this,{code:code,units:_ol_proj_Units_.METERS,extent:_ol_proj_EPSG3857_.EXTENT,global:true,worldExtent:_ol_proj_EPSG3857_.WORLD_EXTENT,getPointResolution:function(resolution,point){return resolution/_ol_math_.cosh(point[1]/_ol_proj_EPSG3857_.RADIUS);}});};_ol_.inherits(_ol_proj_EPSG3857_.Projection_,_ol_proj_Projection_$1);/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */_ol_proj_EPSG3857_.RADIUS=6378137;/**
 * @const
 * @type {number}
 */_ol_proj_EPSG3857_.HALF_SIZE=Math.PI*_ol_proj_EPSG3857_.RADIUS;/**
 * @const
 * @type {ol.Extent}
 */_ol_proj_EPSG3857_.EXTENT=[-_ol_proj_EPSG3857_.HALF_SIZE,-_ol_proj_EPSG3857_.HALF_SIZE,_ol_proj_EPSG3857_.HALF_SIZE,_ol_proj_EPSG3857_.HALF_SIZE];/**
 * @const
 * @type {ol.Extent}
 */_ol_proj_EPSG3857_.WORLD_EXTENT=[-180,-85,180,85];/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */_ol_proj_EPSG3857_.PROJECTIONS=[new _ol_proj_EPSG3857_.Projection_('EPSG:3857'),new _ol_proj_EPSG3857_.Projection_('EPSG:102100'),new _ol_proj_EPSG3857_.Projection_('EPSG:102113'),new _ol_proj_EPSG3857_.Projection_('EPSG:900913'),new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG:6.18:3:3857'),new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG::3857'),new _ol_proj_EPSG3857_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#3857')];/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */_ol_proj_EPSG3857_.fromEPSG4326=function(input,opt_output,opt_dimension){var length=input.length,dimension=opt_dimension>1?opt_dimension:2,output=opt_output;if(output===undefined){if(dimension>2){// preserve values beyond second dimension
output=input.slice();}else{output=new Array(length);}}var halfSize=_ol_proj_EPSG3857_.HALF_SIZE;for(var i=0;i<length;i+=dimension){output[i]=halfSize*input[i]/180;var y=_ol_proj_EPSG3857_.RADIUS*Math.log(Math.tan(Math.PI*(input[i+1]+90)/360));if(y>halfSize){y=halfSize;}else if(y<-halfSize){y=-halfSize;}output[i+1]=y;}return output;};/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */_ol_proj_EPSG3857_.toEPSG4326=function(input,opt_output,opt_dimension){var length=input.length,dimension=opt_dimension>1?opt_dimension:2,output=opt_output;if(output===undefined){if(dimension>2){// preserve values beyond second dimension
output=input.slice();}else{output=new Array(length);}}for(var i=0;i<length;i+=dimension){output[i]=180*input[i]/_ol_proj_EPSG3857_.HALF_SIZE;output[i+1]=360*Math.atan(Math.exp(input[i+1]/_ol_proj_EPSG3857_.RADIUS))/Math.PI-90;}return output;};var _ol_proj_EPSG4326_={};/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @param {string=} opt_axisOrientation Axis orientation.
 * @private
 */_ol_proj_EPSG4326_.Projection_=function(code,opt_axisOrientation){_ol_proj_Projection_$1.call(this,{code:code,units:_ol_proj_Units_.DEGREES,extent:_ol_proj_EPSG4326_.EXTENT,axisOrientation:opt_axisOrientation,global:true,metersPerUnit:_ol_proj_EPSG4326_.METERS_PER_UNIT,worldExtent:_ol_proj_EPSG4326_.EXTENT});};_ol_.inherits(_ol_proj_EPSG4326_.Projection_,_ol_proj_Projection_$1);/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */_ol_proj_EPSG4326_.RADIUS=6378137;/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {ol.Extent}
 */_ol_proj_EPSG4326_.EXTENT=[-180,-90,180,90];/**
 * @const
 * @type {number}
 */_ol_proj_EPSG4326_.METERS_PER_UNIT=Math.PI*_ol_proj_EPSG4326_.RADIUS/180;/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */_ol_proj_EPSG4326_.PROJECTIONS=[new _ol_proj_EPSG4326_.Projection_('CRS:84'),new _ol_proj_EPSG4326_.Projection_('EPSG:4326','neu'),new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG::4326','neu'),new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG:6.6:4326','neu'),new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:1.3:CRS84'),new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:2:84'),new _ol_proj_EPSG4326_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#4326','neu'),new _ol_proj_EPSG4326_.Projection_('urn:x-ogc:def:crs:EPSG:4326','neu')];var _ol_proj_projections_={};/**
 * @private
 * @type {Object.<string, ol.proj.Projection>}
 */_ol_proj_projections_.cache_={};/**
 * Clear the projections cache.
 */_ol_proj_projections_.clear=function(){_ol_proj_projections_.cache_={};};/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {ol.proj.Projection} The projection (if cached).
 */_ol_proj_projections_.get=function(code){var projections=_ol_proj_projections_.cache_;return projections[code]||null;};/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {ol.proj.Projection} projection The projection to cache.
 */_ol_proj_projections_.add=function(code,projection){var projections=_ol_proj_projections_.cache_;projections[code]=projection;};var _ol_obj_={};/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */_ol_obj_.assign=typeof Object.assign==='function'?Object.assign:function(target,var_sources){if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var i=1,ii=arguments.length;i<ii;++i){var source=arguments[i];if(source!==undefined&&source!==null){for(var key in source){if(source.hasOwnProperty(key)){output[key]=source[key];}}}}return output;};/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */_ol_obj_.clear=function(object){for(var property in object){delete object[property];}};/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */_ol_obj_.getValues=function(object){var values=[];for(var property in object){values.push(object[property]);}return values;};/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */_ol_obj_.isEmpty=function(object){var property;for(property in object){return false;}return!property;};var _ol_proj_transforms_={};/**
 * @private
 * @type {Object.<string, Object.<string, ol.TransformFunction>>}
 */_ol_proj_transforms_.cache_={};/**
 * Clear the transform cache.
 */_ol_proj_transforms_.clear=function(){_ol_proj_transforms_.cache_={};};/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {ol.proj.Projection} source Source.
 * @param {ol.proj.Projection} destination Destination.
 * @param {ol.TransformFunction} transformFn Transform.
 */_ol_proj_transforms_.add=function(source,destination,transformFn){var sourceCode=source.getCode();var destinationCode=destination.getCode();var transforms=_ol_proj_transforms_.cache_;if(!(sourceCode in transforms)){transforms[sourceCode]={};}transforms[sourceCode][destinationCode]=transformFn;};/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {ol.proj.Projection} source Source projection.
 * @param {ol.proj.Projection} destination Destination projection.
 * @return {ol.TransformFunction} transformFn The unregistered transform.
 */_ol_proj_transforms_.remove=function(source,destination){var sourceCode=source.getCode();var destinationCode=destination.getCode();var transforms=_ol_proj_transforms_.cache_;var transform=transforms[sourceCode][destinationCode];delete transforms[sourceCode][destinationCode];if(_ol_obj_.isEmpty(transforms[sourceCode])){delete transforms[sourceCode];}return transform;};/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {ol.TransformFunction|undefined} The transform function (if found).
 */_ol_proj_transforms_.get=function(sourceCode,destinationCode){var transform;var transforms=_ol_proj_transforms_.cache_;if(sourceCode in transforms&&destinationCode in transforms[sourceCode]){transform=transforms[sourceCode][destinationCode];}return transform;};var _ol_proj_={};/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */_ol_proj_.METERS_PER_UNIT=_ol_proj_Units_.METERS_PER_UNIT;/**
 * A place to store the mean radius of the Earth.
 * @private
 * @type {ol.Sphere}
 */_ol_proj_.SPHERE_=new _ol_Sphere_(_ol_Sphere_.DEFAULT_RADIUS);if(_ol_.ENABLE_PROJ4JS){/**
   * Register proj4. If not explicitly registered, it will be assumed that
   * proj4js will be loaded in the global namespace. For example in a
   * browserify ES6 environment you could use:
   *
   *     import ol from 'openlayers';
   *     import proj4 from 'proj4';
   *     ol.proj.setProj4(proj4);
   *
   * @param {Proj4} proj4 Proj4.
   * @api
   */_ol_proj_.setProj4=function(proj4){_ol_proj_proj4_.set(proj4);};}/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link ol.proj.Projection} constructor or by using
 * {@link ol.proj.Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ol.ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {ol.Coordinate} point Point to find adjusted resolution at.
 * @param {ol.proj.Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */_ol_proj_.getPointResolution=function(projection,resolution,point,opt_units){projection=_ol_proj_.get(projection);var pointResolution;var getter=projection.getPointResolutionFunc();if(getter){pointResolution=getter(resolution,point);}else{var units=projection.getUnits();if(units==_ol_proj_Units_.DEGREES&&!opt_units||opt_units==_ol_proj_Units_.DEGREES){pointResolution=resolution;}else{// Estimate point resolution by transforming the center pixel to EPSG:4326,
// measuring its width and height on the normal sphere, and taking the
// average of the width and height.
var toEPSG4326=_ol_proj_.getTransformFromProjections(projection,_ol_proj_.get('EPSG:4326'));var vertices=[point[0]-resolution/2,point[1],point[0]+resolution/2,point[1],point[0],point[1]-resolution/2,point[0],point[1]+resolution/2];vertices=toEPSG4326(vertices,vertices,2);var width=_ol_proj_.SPHERE_.haversineDistance(vertices.slice(0,2),vertices.slice(2,4));var height=_ol_proj_.SPHERE_.haversineDistance(vertices.slice(4,6),vertices.slice(6,8));pointResolution=(width+height)/2;var metersPerUnit=opt_units?_ol_proj_Units_.METERS_PER_UNIT[opt_units]:projection.getMetersPerUnit();if(metersPerUnit!==undefined){pointResolution/=metersPerUnit;}}}return pointResolution;};/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<ol.proj.Projection>} projections Projections.
 * @api
 */_ol_proj_.addEquivalentProjections=function(projections){_ol_proj_.addProjections(projections);projections.forEach(function(source){projections.forEach(function(destination){if(source!==destination){_ol_proj_transforms_.add(source,destination,_ol_proj_.cloneTransform);}});});};/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<ol.proj.Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<ol.proj.Projection>} projections2 Projections with equal
 *     meaning.
 * @param {ol.TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {ol.TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */_ol_proj_.addEquivalentTransforms=function(projections1,projections2,forwardTransform,inverseTransform){projections1.forEach(function(projection1){projections2.forEach(function(projection2){_ol_proj_transforms_.add(projection1,projection2,forwardTransform);_ol_proj_transforms_.add(projection2,projection1,inverseTransform);});});};/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {ol.proj.Projection} projection Projection instance.
 * @api
 */_ol_proj_.addProjection=function(projection){_ol_proj_projections_.add(projection.getCode(),projection);_ol_proj_transforms_.add(projection,projection,_ol_proj_.cloneTransform);};/**
 * @param {Array.<ol.proj.Projection>} projections Projections.
 */_ol_proj_.addProjections=function(projections){projections.forEach(_ol_proj_.addProjection);};/**
 * Clear all cached projections and transforms.
 */_ol_proj_.clearAllProjections=function(){_ol_proj_projections_.clear();_ol_proj_transforms_.clear();};/**
 * @param {ol.proj.Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {ol.proj.Projection} Projection.
 */_ol_proj_.createProjection=function(projection,defaultCode){if(!projection){return _ol_proj_.get(defaultCode);}else if(typeof projection==='string'){return _ol_proj_.get(projection);}else{return(/** @type {ol.proj.Projection} */projection);}};/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ol.ProjectionLike} source Source projection.
 * @param {ol.ProjectionLike} destination Destination projection.
 * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @api
 */_ol_proj_.addCoordinateTransforms=function(source,destination,forward,inverse){var sourceProj=_ol_proj_.get(source);var destProj=_ol_proj_.get(destination);_ol_proj_transforms_.add(sourceProj,destProj,_ol_proj_.createTransformFromCoordinateTransform(forward));_ol_proj_transforms_.add(destProj,sourceProj,_ol_proj_.createTransformFromCoordinateTransform(inverse));};/**
 * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate
 *     transform.
 * @return {ol.TransformFunction} Transform function.
 */_ol_proj_.createTransformFromCoordinateTransform=function(transform){return(/**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */function(input,opt_output,opt_dimension){var length=input.length;var dimension=opt_dimension!==undefined?opt_dimension:2;var output=opt_output!==undefined?opt_output:new Array(length);var point,i,j;for(i=0;i<length;i+=dimension){point=transform([input[i],input[i+1]]);output[i]=point[0];output[i+1]=point[1];for(j=dimension-1;j>=2;--j){output[i+j]=input[i+j];}}return output;});};/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ol.ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate projected to the target projection.
 * @api
 */_ol_proj_.fromLonLat=function(coordinate,opt_projection){return _ol_proj_.transform(coordinate,'EPSG:4326',opt_projection!==undefined?opt_projection:'EPSG:3857');};/**
 * Transforms a coordinate to longitude/latitude.
 * @param {ol.Coordinate} coordinate Projected coordinate.
 * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */_ol_proj_.toLonLat=function(coordinate,opt_projection){return _ol_proj_.transform(coordinate,opt_projection!==undefined?opt_projection:'EPSG:3857','EPSG:4326');};/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ol.ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {ol.proj.Projection} Projection object, or null if not in list.
 * @api
 */_ol_proj_.get=function(projectionLike){var projection=null;if(projectionLike instanceof _ol_proj_Projection_$1){projection=projectionLike;}else if(typeof projectionLike==='string'){var code=projectionLike;projection=_ol_proj_projections_.get(code);if(_ol_.ENABLE_PROJ4JS&&!projection){var proj4js=_ol_proj_proj4_.get();if(typeof proj4js=='function'&&proj4js.defs(code)!==undefined){projection=new _ol_proj_Projection_$1({code:code});_ol_proj_.addProjection(projection);}}}return projection;};/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {ol.proj.Projection} projection1 Projection 1.
 * @param {ol.proj.Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */_ol_proj_.equivalent=function(projection1,projection2){if(projection1===projection2){return true;}var equalUnits=projection1.getUnits()===projection2.getUnits();if(projection1.getCode()===projection2.getCode()){return equalUnits;}else{var transformFn=_ol_proj_.getTransformFromProjections(projection1,projection2);return transformFn===_ol_proj_.cloneTransform&&equalUnits;}};/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ol.ProjectionLike} source Source.
 * @param {ol.ProjectionLike} destination Destination.
 * @return {ol.TransformFunction} Transform function.
 * @api
 */_ol_proj_.getTransform=function(source,destination){var sourceProjection=_ol_proj_.get(source);var destinationProjection=_ol_proj_.get(destination);return _ol_proj_.getTransformFromProjections(sourceProjection,destinationProjection);};/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {ol.proj.Projection} sourceProjection Source Projection object.
 * @param {ol.proj.Projection} destinationProjection Destination Projection
 *     object.
 * @return {ol.TransformFunction} Transform function.
 */_ol_proj_.getTransformFromProjections=function(sourceProjection,destinationProjection){var sourceCode=sourceProjection.getCode();var destinationCode=destinationProjection.getCode();var transform=_ol_proj_transforms_.get(sourceCode,destinationCode);if(_ol_.ENABLE_PROJ4JS&&!transform){var proj4js=_ol_proj_proj4_.get();if(typeof proj4js=='function'){var sourceDef=proj4js.defs(sourceCode);var destinationDef=proj4js.defs(destinationCode);if(sourceDef!==undefined&&destinationDef!==undefined){if(sourceDef===destinationDef){_ol_proj_.addEquivalentProjections([destinationProjection,sourceProjection]);}else{var proj4Transform=proj4js(destinationCode,sourceCode);_ol_proj_.addCoordinateTransforms(destinationProjection,sourceProjection,proj4Transform.forward,proj4Transform.inverse);}transform=_ol_proj_transforms_.get(sourceCode,destinationCode);}}}if(!transform){transform=_ol_proj_.identityTransform;}return transform;};/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */_ol_proj_.identityTransform=function(input,opt_output,opt_dimension){if(opt_output!==undefined&&input!==opt_output){for(var i=0,ii=input.length;i<ii;++i){opt_output[i]=input[i];}input=opt_output;}return input;};/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */_ol_proj_.cloneTransform=function(input,opt_output,opt_dimension){var output;if(opt_output!==undefined){for(var i=0,ii=input.length;i<ii;++i){opt_output[i]=input[i];}output=opt_output;}else{output=input.slice();}return output;};/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link ol.proj.transformExtent} for extent transformation.
 * See the transform method of {@link ol.geom.Geometry} and its subclasses for
 * geometry transforms.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */_ol_proj_.transform=function(coordinate,source,destination){var transformFn=_ol_proj_.getTransform(source,destination);return transformFn(coordinate,undefined,coordinate.length);};/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {ol.Extent} extent The extent to transform.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Extent} The transformed extent.
 * @api
 */_ol_proj_.transformExtent=function(extent,source,destination){var transformFn=_ol_proj_.getTransform(source,destination);return _ol_extent_.applyTransform(extent,transformFn);};/**
 * Transforms the given point to the destination projection.
 *
 * @param {ol.Coordinate} point Point.
 * @param {ol.proj.Projection} sourceProjection Source projection.
 * @param {ol.proj.Projection} destinationProjection Destination projection.
 * @return {ol.Coordinate} Point.
 */_ol_proj_.transformWithProjections=function(point,sourceProjection,destinationProjection){var transformFn=_ol_proj_.getTransformFromProjections(sourceProjection,destinationProjection);return transformFn(point);};/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `ol.proj.clearAllProjections()` is called (e.g. in tests).
 */_ol_proj_.addCommon=function(){// Add transformations that don't alter coordinates to convert within set of
// projections with equal meaning.
_ol_proj_.addEquivalentProjections(_ol_proj_EPSG3857_.PROJECTIONS);_ol_proj_.addEquivalentProjections(_ol_proj_EPSG4326_.PROJECTIONS);// Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
// coordinates and back.
_ol_proj_.addEquivalentTransforms(_ol_proj_EPSG4326_.PROJECTIONS,_ol_proj_EPSG3857_.PROJECTIONS,_ol_proj_EPSG3857_.fromEPSG4326,_ol_proj_EPSG3857_.toEPSG4326);};_ol_proj_.addCommon();var mapConstants={map_w:16384,map_h:16384,map_x_boundaries:[-8507.4,9515],map_y_boundaries:[8888.12001679,-8953.45782627],resolutions:[16384/1024,16384/1024/2,16384/1024/4,16384/1024/8,16384/1024/16],visionRadius:{observer:1600,sentry:850,darkness:675},defaultMovementSpeed:300,creepBaseMovementSpeed:325,pullRangeTiming:[4,2.25,4.75]};mapConstants.imgCenter=[mapConstants.map_w/2,mapConstants.map_h/2];mapConstants.scale=Math.abs(mapConstants.map_x_boundaries[1]-mapConstants.map_x_boundaries[0])/mapConstants.map_w;function lerp(minVal,maxVal,pos_r){return pos_r*(maxVal-minVal)+minVal;}function reverseLerp(minVal,maxVal,pos){return(pos-minVal)/(maxVal-minVal);}function latLonToWorld(coordinate){var x_r=lerp(mapConstants.map_x_boundaries[0],mapConstants.map_x_boundaries[1],coordinate[0]/mapConstants.map_w),y_r=lerp(mapConstants.map_y_boundaries[0],mapConstants.map_y_boundaries[1],(mapConstants.map_h-coordinate[1])/mapConstants.map_h);return[x_r,y_r];}function worldToLatLon(coordinate){var x=reverseLerp(mapConstants.map_x_boundaries[0],mapConstants.map_x_boundaries[1],coordinate[0])*mapConstants.map_w,y=mapConstants.map_h-reverseLerp(mapConstants.map_y_boundaries[0],mapConstants.map_y_boundaries[1],coordinate[1])*mapConstants.map_h;return[x,y];}function getTileRadius(r){return parseInt(Math.floor(r/64));}function getScaledRadius(r){return r/(mapConstants.map_x_boundaries[1]-mapConstants.map_x_boundaries[0])*mapConstants.map_w;}var pixelProj=new _ol_proj_Projection_$1({code:'pixel',units:'pixels',extent:[0,0,mapConstants.map_w,mapConstants.map_h]});var dotaProj=new _ol_proj_Projection_$1({code:'dota',extent:[-8288,-8288,8288,8288],units:'units'});_ol_proj_.addProjection(pixelProj);_ol_proj_.addCoordinateTransforms('pixel',dotaProj,latLonToWorld,worldToLatLon);_ol_proj_.addProjection(dotaProj);_ol_proj_.addCoordinateTransforms('dota',pixelProj,worldToLatLon,latLonToWorld);function MenuPanel(panelId,openId,closeId,fullscreen){this.panelId=panelId;this.openId=openId;this.closeId=closeId;this.fullscreen=fullscreen;this.initialize();}MenuPanel.prototype.initialize=function(){this.panel=document.getElementById(this.panelId);this.openBtn=document.getElementById(this.openId);this.closeBtn=document.getElementById(this.closeId);this.openBtn.addEventListener("click",this.open.bind(this),false);this.closeHandler=this.close.bind(this);this.closeBtn.addEventListener("click",this.closeHandler,false);};MenuPanel.prototype.open=function(evt){this.panel.classList.add('expand-horizontal');this.panel.classList.remove('collapsed-horizontal');this.openBtn.classList.add('collapsed-horizontal');this.openBtn.classList.remove('expand-horizontal');this.otherMenu.close(evt);};MenuPanel.prototype.close=function(evt){this.panel.classList.remove('expand-horizontal');this.panel.classList.add('collapsed-horizontal');this.openBtn.classList.remove('collapsed-horizontal');this.openBtn.classList.add('expand-horizontal');};MenuPanel.prototype.createToggle=function(layerDef,handler){var toggle=document.createElement('div');toggle.classList.add('btn-toggle');var toggleCb=document.createElement('input');toggleCb.setAttribute("type","checkbox");toggleCb.id='toggle-'+layerDef.id;toggleCb.addEventListener("change",handler,false);toggle.appendChild(toggleCb);var toggleLbl=document.createElement('label');toggleLbl.setAttribute("for",toggleCb.id);toggle.appendChild(toggleLbl);return toggle;};MenuPanel.prototype.createMenuPanelItem=function(InteractiveMap,layerDef,handler,inputType,inputName){var optionId=layerDef.id;var menuItem=document.createElement('div');menuItem.classList.add('menu-item');menuItem.classList.add(inputName||'data-layer');var menuItemCb=document.createElement('input');menuItemCb.setAttribute("type",inputType||"checkbox");if(inputType=="radio"){optionId=layerDef.group+'-'+layerDef.id;menuItemCb.setAttribute("name",inputName);menuItemCb.setAttribute("value",optionId);}menuItemCb.id='option-'+optionId;menuItemCb.setAttribute("data-layer-id",optionId);menuItemCb.addEventListener("change",handler,false);menuItem.appendChild(menuItemCb);var menuItemLbl=document.createElement('label');menuItemLbl.classList.add('checkbox');menuItemLbl.setAttribute("for",menuItemCb.id);menuItemLbl.innerHTML=layerDef.name;menuItem.appendChild(menuItemLbl);if(layerDef.toggle){function toggleHandler(){var layer=InteractiveMap.getMapLayerIndex()[layerDef.id];if(layerDef.id=='ent_dota_tree'){InteractiveMap.treeControl.toggleAllTrees(this.checked);}else{InteractiveMap.wardControl.toggleAll(layer,this.checked);}}var toggle=MenuPanel.prototype.createToggle(layerDef,toggleHandler);menuItem.appendChild(toggle);}return menuItem;};function MenuControl(InteractiveMap){this.InteractiveMap=InteractiveMap;this.leftPanel=new MenuPanel("menu-left","menu-left-open-btn","menu-left-close-btn");this.rightPanel=new MenuPanel("menu-right","menu-right-open-btn","menu-right-close-btn");this.leftPanel.otherMenu=this.rightPanel;this.rightPanel.otherMenu=this.leftPanel;}MenuControl.prototype.initialize=function(layerToggleHandler,baseLayerToggleHandler){var self=this;this.InteractiveMap.layerDefs.forEach(function(layerDef){var group=layerDef.group;var menu=document.querySelector('#'+group+'-menu');var menuItem=MenuPanel.prototype.createMenuPanelItem(self.InteractiveMap,layerDef,layerToggleHandler);menu.appendChild(menuItem);});this.InteractiveMap.baseLayerDefs.forEach(function(layerDef){var group=layerDef.group;var menu=document.querySelector('#base-'+group+'-menu');var menuItem=MenuPanel.prototype.createMenuPanelItem(self.InteractiveMap,layerDef,baseLayerToggleHandler,'radio','base-layer');menu.appendChild(menuItem);});};var _ol_events_={};/**
 * @param {ol.EventsKey} listenerObj Listener object.
 * @return {ol.EventsListenerFunctionType} Bound listener.
 */_ol_events_.bindListener_=function(listenerObj){var boundListener=function(evt){var listener=listenerObj.listener;var bindTo=listenerObj.bindTo||listenerObj.target;if(listenerObj.callOnce){_ol_events_.unlistenByKey(listenerObj);}return listener.call(bindTo,evt);};listenerObj.boundListener=boundListener;return boundListener;};/**
 * Finds the matching {@link ol.EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!ol.EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link ol.events.unlistenByKey}.
 * @return {ol.EventsKey|undefined} The matching listener object.
 * @private
 */_ol_events_.findListener_=function(listeners,listener,opt_this,opt_setDeleteIndex){var listenerObj;for(var i=0,ii=listeners.length;i<ii;++i){listenerObj=listeners[i];if(listenerObj.listener===listener&&listenerObj.bindTo===opt_this){if(opt_setDeleteIndex){listenerObj.deleteIndex=i;}return listenerObj;}}return undefined;};/**
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<ol.EventsKey>|undefined} Listeners.
 */_ol_events_.getListeners=function(target,type){var listenerMap=target.ol_lm;return listenerMap?listenerMap[type]:undefined;};/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {ol.EventTargetLike} target Target.
 * @return {!Object.<string, Array.<ol.EventsKey>>} Map of
 *     listeners by event type.
 * @private
 */_ol_events_.getListenerMap_=function(target){var listenerMap=target.ol_lm;if(!listenerMap){listenerMap=target.ol_lm={};}return listenerMap;};/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @private
 */_ol_events_.removeListeners_=function(target,type){var listeners=_ol_events_.getListeners(target,type);if(listeners){for(var i=0,ii=listeners.length;i<ii;++i){target.removeEventListener(type,listeners[i].boundListener);_ol_obj_.clear(listeners[i]);}listeners.length=0;var listenerMap=target.ol_lm;if(listenerMap){delete listenerMap[type];if(Object.keys(listenerMap).length===0){delete target.ol_lm;}}}};/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link ol.events.unlistenByKey}.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {ol.EventsKey} Unique key for the listener.
 */_ol_events_.listen=function(target,type,listener,opt_this,opt_once){var listenerMap=_ol_events_.getListenerMap_(target);var listeners=listenerMap[type];if(!listeners){listeners=listenerMap[type]=[];}var listenerObj=_ol_events_.findListener_(listeners,listener,opt_this,false);if(listenerObj){if(!opt_once){// Turn one-off listener into a permanent one.
listenerObj.callOnce=false;}}else{listenerObj=/** @type {ol.EventsKey} */{bindTo:opt_this,callOnce:!!opt_once,listener:listener,target:target,type:type};target.addEventListener(type,_ol_events_.bindListener_(listenerObj));listeners.push(listenerObj);}return listenerObj;};/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered
 * before it is called.
 *
 * When {@link ol.events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {ol.EventsKey} Key for unlistenByKey.
 */_ol_events_.listenOnce=function(target,type,listener,opt_this){return _ol_events_.listen(target,type,listener,opt_this,true);};/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link ol.events.listen} call.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */_ol_events_.unlisten=function(target,type,listener,opt_this){var listeners=_ol_events_.getListeners(target,type);if(listeners){var listenerObj=_ol_events_.findListener_(listeners,listener,opt_this,true);if(listenerObj){_ol_events_.unlistenByKey(listenerObj);}}};/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link ol.events.listen} or {@link ol.events.listenOnce}.
 *
 * @param {ol.EventsKey} key The key.
 */_ol_events_.unlistenByKey=function(key){if(key&&key.target){key.target.removeEventListener(key.type,key.boundListener);var listeners=_ol_events_.getListeners(key.target,key.type);if(listeners){var i='deleteIndex'in key?key.deleteIndex:listeners.indexOf(key);if(i!==-1){listeners.splice(i,1);}if(listeners.length===0){_ol_events_.removeListeners_(key.target,key.type);}}_ol_obj_.clear(key);}};/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {ol.EventTargetLike} target Target.
 */_ol_events_.unlistenAll=function(target){var listenerMap=_ol_events_.getListenerMap_(target);for(var type in listenerMap){_ol_events_.removeListeners_(target,type);}};/**
 * Objects that need to clean up after themselves.
 * @constructor
 */var _ol_Disposable_=function(){};/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */_ol_Disposable_.prototype.disposed_=false;/**
 * Clean up.
 */_ol_Disposable_.prototype.dispose=function(){if(!this.disposed_){this.disposed_=true;this.disposeInternal();}};/**
 * Extension point for disposable objects.
 * @protected
 */_ol_Disposable_.prototype.disposeInternal=_ol_.nullFunction;/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link ol.events.EventTarget}.
 *
 * @constructor
 * @implements {oli.events.Event}
 * @param {string} type Type.
 */var _ol_events_Event_=function(type){/**
   * @type {boolean}
   */this.propagationStopped;/**
   * The event type.
   * @type {string}
   * @api
   */this.type=type;/**
   * The event target.
   * @type {Object}
   * @api
   */this.target=null;};/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */_ol_events_Event_.prototype.preventDefault=/**
   * Stop event propagation.
   * @function
   * @override
   * @api
   */_ol_events_Event_.prototype.stopPropagation=function(){this.propagationStopped=true;};/**
 * @param {Event|ol.events.Event} evt Event
 */_ol_events_Event_.stopPropagation=function(evt){evt.stopPropagation();};/**
 * @param {Event|ol.events.Event} evt Event
 */_ol_events_Event_.preventDefault=function(evt){evt.preventDefault();};/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {ol.Disposable}
 */var _ol_events_EventTarget_=function(){_ol_Disposable_.call(this);/**
   * @private
   * @type {!Object.<string, number>}
   */this.pendingRemovals_={};/**
   * @private
   * @type {!Object.<string, number>}
   */this.dispatching_={};/**
   * @private
   * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}
   */this.listeners_={};};_ol_.inherits(_ol_events_EventTarget_,_ol_Disposable_);/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */_ol_events_EventTarget_.prototype.addEventListener=function(type,listener){var listeners=this.listeners_[type];if(!listeners){listeners=this.listeners_[type]=[];}if(listeners.indexOf(listener)===-1){listeners.push(listener);}};/**
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */_ol_events_EventTarget_.prototype.dispatchEvent=function(event){var evt=typeof event==='string'?new _ol_events_Event_(event):event;var type=evt.type;evt.target=this;var listeners=this.listeners_[type];var propagate;if(listeners){if(!(type in this.dispatching_)){this.dispatching_[type]=0;this.pendingRemovals_[type]=0;}++this.dispatching_[type];for(var i=0,ii=listeners.length;i<ii;++i){if(listeners[i].call(this,evt)===false||evt.propagationStopped){propagate=false;break;}}--this.dispatching_[type];if(this.dispatching_[type]===0){var pendingRemovals=this.pendingRemovals_[type];delete this.pendingRemovals_[type];while(pendingRemovals--){this.removeEventListener(type,_ol_.nullFunction);}delete this.dispatching_[type];}return propagate;}};/**
 * @inheritDoc
 */_ol_events_EventTarget_.prototype.disposeInternal=function(){_ol_events_.unlistenAll(this);};/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<ol.EventsListenerFunctionType>} Listeners.
 */_ol_events_EventTarget_.prototype.getListeners=function(type){return this.listeners_[type];};/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */_ol_events_EventTarget_.prototype.hasListener=function(opt_type){return opt_type?opt_type in this.listeners_:Object.keys(this.listeners_).length>0;};/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */_ol_events_EventTarget_.prototype.removeEventListener=function(type,listener){var listeners=this.listeners_[type];if(listeners){var index=listeners.indexOf(listener);if(type in this.pendingRemovals_){// make listener a no-op, and remove later in #dispatchEvent()
listeners[index]=_ol_.nullFunction;++this.pendingRemovals_[type];}else{listeners.splice(index,1);if(listeners.length===0){delete this.listeners_[type];}}}};/**
 * @enum {string}
 * @const
 */var _ol_events_EventType_={/**
   * Generic change event. Triggered when the revision counter is increased.
   * @event ol.events.Event#change
   * @api
   */CHANGE:'change',CLICK:'click',DBLCLICK:'dblclick',DRAGENTER:'dragenter',DRAGOVER:'dragover',DROP:'drop',ERROR:'error',KEYDOWN:'keydown',KEYPRESS:'keypress',LOAD:'load',MOUSEDOWN:'mousedown',MOUSEMOVE:'mousemove',MOUSEOUT:'mouseout',MOUSEUP:'mouseup',MOUSEWHEEL:'mousewheel',MSPOINTERDOWN:'MSPointerDown',RESIZE:'resize',TOUCHSTART:'touchstart',TOUCHMOVE:'touchmove',TOUCHEND:'touchend',WHEEL:'wheel'};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link ol.Observable#changed}.
 *
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @api
 */var _ol_Observable_=function(){_ol_events_EventTarget_.call(this);/**
   * @private
   * @type {number}
   */this.revision_=0;};_ol_.inherits(_ol_Observable_,_ol_events_EventTarget_);/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {ol.EventsKey|Array.<ol.EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */_ol_Observable_.unByKey=function(key){if(Array.isArray(key)){for(var i=0,ii=key.length;i<ii;++i){_ol_events_.unlistenByKey(key[i]);}}else{_ol_events_.unlistenByKey(/** @type {ol.EventsKey} */key);}};/**
 * Increases the revision counter and dispatches a 'change' event.
 * @api
 */_ol_Observable_.prototype.changed=function(){++this.revision_;this.dispatchEvent(_ol_events_EventType_.CHANGE);};/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * @return {number} Revision.
 * @api
 */_ol_Observable_.prototype.getRevision=function(){return this.revision_;};/**
 * Listen for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */_ol_Observable_.prototype.on=function(type,listener,opt_this){if(Array.isArray(type)){var len=type.length;var keys=new Array(len);for(var i=0;i<len;++i){keys[i]=_ol_events_.listen(this,type[i],listener,opt_this);}return keys;}else{return _ol_events_.listen(this,/** @type {string} */type,listener,opt_this);}};/**
 * Listen once for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */_ol_Observable_.prototype.once=function(type,listener,opt_this){if(Array.isArray(type)){var len=type.length;var keys=new Array(len);for(var i=0;i<len;++i){keys[i]=_ol_events_.listenOnce(this,type[i],listener,opt_this);}return keys;}else{return _ol_events_.listenOnce(this,/** @type {string} */type,listener,opt_this);}};/**
 * Unlisten for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object which was used as `this` by the
 * `listener`.
 * @api
 */_ol_Observable_.prototype.un=function(type,listener,opt_this){if(Array.isArray(type)){for(var i=0,ii=type.length;i<ii;++i){_ol_events_.unlisten(this,type[i],listener,opt_this);}return;}else{_ol_events_.unlisten(this,/** @type {string} */type,listener,opt_this);}};var _ol_array_={};/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */_ol_array_.binarySearch=function(haystack,needle,opt_comparator){var mid,cmp;var comparator=opt_comparator||_ol_array_.numberSafeCompareFunction;var low=0;var high=haystack.length;var found=false;while(low<high){/* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */mid=low+(high-low>>1);cmp=+comparator(haystack[mid],needle);if(cmp<0.0){/* Too low. */low=mid+1;}else{/* Key found or too high */high=mid;found=!cmp;}}/* Key not found. */return found?low:~low;};/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */_ol_array_.numberSafeCompareFunction=function(a,b){return a>b?1:a<b?-1:0;};/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */_ol_array_.includes=function(arr,obj){return arr.indexOf(obj)>=0;};/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */_ol_array_.linearFindNearest=function(arr,target,direction){var n=arr.length;if(arr[0]<=target){return 0;}else if(target<=arr[n-1]){return n-1;}else{var i;if(direction>0){for(i=1;i<n;++i){if(arr[i]<target){return i-1;}}}else if(direction<0){for(i=1;i<n;++i){if(arr[i]<=target){return i;}}}else{for(i=1;i<n;++i){if(arr[i]==target){return i;}else if(arr[i]<target){if(arr[i-1]-target<target-arr[i]){return i-1;}else{return i;}}}}return n-1;}};/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */_ol_array_.reverseSubArray=function(arr,begin,end){while(begin<end){var tmp=arr[begin];arr[begin]=arr[end];arr[end]=tmp;++begin;--end;}};/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {Array.<VALUE>|VALUE} data The elements or arrays of elements
 *     to add to arr.
 * @template VALUE
 */_ol_array_.extend=function(arr,data){var i;var extension=Array.isArray(data)?data:[data];var length=extension.length;for(i=0;i<length;i++){arr[arr.length]=extension[i];}};/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */_ol_array_.remove=function(arr,obj){var i=arr.indexOf(obj);var found=i>-1;if(found){arr.splice(i,1);}return found;};/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE} The element found.
 */_ol_array_.find=function(arr,func){var length=arr.length>>>0;var value;for(var i=0;i<length;i++){value=arr[i];if(func(value,i,arr)){return value;}}return null;};/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */_ol_array_.equals=function(arr1,arr2){var len1=arr1.length;if(len1!==arr2.length){return false;}for(var i=0;i<len1;i++){if(arr1[i]!==arr2[i]){return false;}}return true;};/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */_ol_array_.stableSort=function(arr,compareFnc){var length=arr.length;var tmp=Array(arr.length);var i;for(i=0;i<length;i++){tmp[i]={index:i,value:arr[i]};}tmp.sort(function(a,b){return compareFnc(a.value,b.value)||a.index-b.index;});for(i=0;i<arr.length;i++){arr[i]=tmp[i].value;}};/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */_ol_array_.findIndex=function(arr,func){var index;var found=!arr.every(function(el,idx){index=idx;return!func(el,idx,arr);});return found?index:-1;};/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */_ol_array_.isSorted=function(arr,opt_func,opt_strict){var compare=opt_func||_ol_array_.numberSafeCompareFunction;return arr.every(function(currentVal,index){if(index===0){return true;}var res=compare(arr[index-1],currentVal);return!(res>0||opt_strict&&res===0);});};/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */var _ol_geom_GeometryLayout_={XY:'XY',XYZ:'XYZ',XYM:'XYM',XYZM:'XYZM'};var _ol_functions_={};/**
 * Always returns true.
 * @returns {boolean} true.
 */_ol_functions_.TRUE=function(){return true;};/**
 * Always returns false.
 * @returns {boolean} false.
 */_ol_functions_.FALSE=function(){return false;};/**
 * @enum {string}
 */var _ol_ObjectEventType_={/**
   * Triggered when a property is changed.
   * @event ol.Object.Event#propertychange
   * @api
   */PROPERTYCHANGE:'propertychange'};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link ol.Observable} with observable properties, where each
 * property is observable as well as the object as a whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link ol.Map} has a `target` property, accessed with `getTarget()`  and
 * changed with `setTarget()`. Not all properties are however settable. There
 * are also general-purpose accessors `get()` and `set()`. For example,
 * `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link ol.View} has a `center`
 * property, so `view.on('change:center', function(evt) {...});` would call the
 * function whenever the value of the center property changes. Within the
 * function, `evt.target` would be the view, so `evt.target.getCenter()` would
 * return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link ol.Object#getProperties object.getProperties()}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @constructor
 * @extends {ol.Observable}
 * @param {Object.<string, *>=} opt_values An object with key-value pairs.
 * @fires ol.Object.Event
 * @api
 */var _ol_Object_=function(opt_values){_ol_Observable_.call(this);// Call ol.getUid to ensure that the order of objects' ids is the same as
// the order in which they were created.  This also helps to ensure that
// object properties are always added in the same order, which helps many
// JavaScript engines generate faster code.
_ol_.getUid(this);/**
   * @private
   * @type {!Object.<string, *>}
   */this.values_={};if(opt_values!==undefined){this.setProperties(opt_values);}};_ol_.inherits(_ol_Object_,_ol_Observable_);/**
 * @private
 * @type {Object.<string, string>}
 */_ol_Object_.changeEventTypeCache_={};/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */_ol_Object_.getChangeEventType=function(key){return _ol_Object_.changeEventTypeCache_.hasOwnProperty(key)?_ol_Object_.changeEventTypeCache_[key]:_ol_Object_.changeEventTypeCache_[key]='change:'+key;};/**
 * Gets a value.
 * @param {string} key Key name.
 * @return {*} Value.
 * @api
 */_ol_Object_.prototype.get=function(key){var value;if(this.values_.hasOwnProperty(key)){value=this.values_[key];}return value;};/**
 * Get a list of object property names.
 * @return {Array.<string>} List of property names.
 * @api
 */_ol_Object_.prototype.getKeys=function(){return Object.keys(this.values_);};/**
 * Get an object of all property names and values.
 * @return {Object.<string, *>} Object.
 * @api
 */_ol_Object_.prototype.getProperties=function(){return _ol_obj_.assign({},this.values_);};/**
 * @param {string} key Key name.
 * @param {*} oldValue Old value.
 */_ol_Object_.prototype.notify=function(key,oldValue){var eventType;eventType=_ol_Object_.getChangeEventType(key);this.dispatchEvent(new _ol_Object_.Event(eventType,key,oldValue));eventType=_ol_ObjectEventType_.PROPERTYCHANGE;this.dispatchEvent(new _ol_Object_.Event(eventType,key,oldValue));};/**
 * Sets a value.
 * @param {string} key Key name.
 * @param {*} value Value.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */_ol_Object_.prototype.set=function(key,value,opt_silent){if(opt_silent){this.values_[key]=value;}else{var oldValue=this.values_[key];this.values_[key]=value;if(oldValue!==value){this.notify(key,oldValue);}}};/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * @param {Object.<string, *>} values Values.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */_ol_Object_.prototype.setProperties=function(values,opt_silent){var key;for(key in values){this.set(key,values[key],opt_silent);}};/**
 * Unsets a property.
 * @param {string} key Key name.
 * @param {boolean=} opt_silent Unset without triggering an event.
 * @api
 */_ol_Object_.prototype.unset=function(key,opt_silent){if(key in this.values_){var oldValue=this.values_[key];delete this.values_[key];if(!opt_silent){this.notify(key,oldValue);}}};/**
 * @classdesc
 * Events emitted by {@link ol.Object} instances are instances of this type.
 *
 * @param {string} type The event type.
 * @param {string} key The property name.
 * @param {*} oldValue The old value for `key`.
 * @extends {ol.events.Event}
 * @implements {oli.Object.Event}
 * @constructor
 */_ol_Object_.Event=function(type,key,oldValue){_ol_events_Event_.call(this,type);/**
   * The name of the property whose value is changing.
   * @type {string}
   * @api
   */this.key=key;/**
   * The old value. To get the new value use `e.target.get(e.key)` where
   * `e` is the event object.
   * @type {*}
   * @api
   */this.oldValue=oldValue;};_ol_.inherits(_ol_Object_.Event,_ol_events_Event_);/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @api
 */var _ol_geom_Geometry_=function(){_ol_Object_.call(this);/**
   * @private
   * @type {ol.Extent}
   */this.extent_=_ol_extent_.createEmpty();/**
   * @private
   * @type {number}
   */this.extentRevision_=-1;/**
   * @protected
   * @type {Object.<string, ol.geom.Geometry>}
   */this.simplifiedGeometryCache={};/**
   * @protected
   * @type {number}
   */this.simplifiedGeometryMaxMinSquaredTolerance=0;/**
   * @protected
   * @type {number}
   */this.simplifiedGeometryRevision=0;};_ol_.inherits(_ol_geom_Geometry_,_ol_Object_);/**
 * Make a complete copy of the geometry.
 * @abstract
 * @return {!ol.geom.Geometry} Clone.
 */_ol_geom_Geometry_.prototype.clone=function(){};/**
 * @abstract
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.Coordinate} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @return {number} Minimum squared distance.
 */_ol_geom_Geometry_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){};/**
 * Return the closest point of the geometry to the passed point as
 * {@link ol.Coordinate coordinate}.
 * @param {ol.Coordinate} point Point.
 * @param {ol.Coordinate=} opt_closestPoint Closest point.
 * @return {ol.Coordinate} Closest point.
 * @api
 */_ol_geom_Geometry_.prototype.getClosestPoint=function(point,opt_closestPoint){var closestPoint=opt_closestPoint?opt_closestPoint:[NaN,NaN];this.closestPointXY(point[0],point[1],closestPoint,Infinity);return closestPoint;};/**
 * Returns true if this geometry includes the specified coordinate. If the
 * coordinate is on the boundary of the geometry, returns false.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} Contains coordinate.
 * @api
 */_ol_geom_Geometry_.prototype.intersectsCoordinate=function(coordinate){return this.containsXY(coordinate[0],coordinate[1]);};/**
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @protected
 * @return {ol.Extent} extent Extent.
 */_ol_geom_Geometry_.prototype.computeExtent=function(extent){};/**
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */_ol_geom_Geometry_.prototype.containsXY=_ol_functions_.FALSE;/**
 * Get the extent of the geometry.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} extent Extent.
 * @api
 */_ol_geom_Geometry_.prototype.getExtent=function(opt_extent){if(this.extentRevision_!=this.getRevision()){this.extent_=this.computeExtent(this.extent_);this.extentRevision_=this.getRevision();}return _ol_extent_.returnOrUpdate(this.extent_,opt_extent);};/**
 * Rotate the geometry around a given coordinate. This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} angle Rotation angle in radians.
 * @param {ol.Coordinate} anchor The rotation center.
 * @api
 */_ol_geom_Geometry_.prototype.rotate=function(angle,anchor){};/**
 * Scale the geometry (with an optional origin).  This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} sx The scaling factor in the x-direction.
 * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
 *     sx).
 * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center
 *     of the geometry extent).
 * @api
 */_ol_geom_Geometry_.prototype.scale=function(sx,opt_sy,opt_anchor){};/**
 * Create a simplified version of this geometry.  For linestrings, this uses
 * the the {@link
 * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * Douglas Peucker} algorithm.  For polygons, a quantization-based
 * simplification is used to preserve topology.
 * @function
 * @param {number} tolerance The tolerance distance for simplification.
 * @return {ol.geom.Geometry} A new, simplified version of the original
 *     geometry.
 * @api
 */_ol_geom_Geometry_.prototype.simplify=function(tolerance){return this.getSimplifiedGeometry(tolerance*tolerance);};/**
 * Create a simplified version of this geometry using the Douglas Peucker
 * algorithm.
 * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * @abstract
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.Geometry} Simplified geometry.
 */_ol_geom_Geometry_.prototype.getSimplifiedGeometry=function(squaredTolerance){};/**
 * Get the type of this geometry.
 * @abstract
 * @return {ol.geom.GeometryType} Geometry type.
 */_ol_geom_Geometry_.prototype.getType=function(){};/**
 * Apply a transform function to each coordinate of the geometry.
 * The geometry is modified in place.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 * @abstract
 * @param {ol.TransformFunction} transformFn Transform.
 */_ol_geom_Geometry_.prototype.applyTransform=function(transformFn){};/**
 * Test if the geometry and the passed extent intersect.
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @return {boolean} `true` if the geometry and the extent intersect.
 */_ol_geom_Geometry_.prototype.intersectsExtent=function(extent){};/**
 * Translate the geometry.  This modifies the geometry coordinates in place.  If
 * instead you want a new geometry, first `clone()` this geometry.
 * @abstract
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 */_ol_geom_Geometry_.prototype.translate=function(deltaX,deltaY){};/**
 * Transform each coordinate of the geometry from one coordinate reference
 * system to another. The geometry is modified in place.
 * For example, a line will be transformed to a line and a circle to a circle.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 *
 * @param {ol.ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @param {ol.ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @return {ol.geom.Geometry} This geometry.  Note that original geometry is
 *     modified in place.
 * @api
 */_ol_geom_Geometry_.prototype.transform=function(source,destination){this.applyTransform(_ol_proj_.getTransform(source,destination));return this;};var _ol_geom_flat_transform_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */_ol_geom_flat_transform_.transform2D=function(flatCoordinates,offset,end,stride,transform,opt_dest){var dest=opt_dest?opt_dest:[];var i=0;var j;for(j=offset;j<end;j+=stride){var x=flatCoordinates[j];var y=flatCoordinates[j+1];dest[i++]=transform[0]*x+transform[2]*y+transform[4];dest[i++]=transform[1]*x+transform[3]*y+transform[5];}if(opt_dest&&dest.length!=i){dest.length=i;}return dest;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array.<number>} anchor Rotation anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */_ol_geom_flat_transform_.rotate=function(flatCoordinates,offset,end,stride,angle,anchor,opt_dest){var dest=opt_dest?opt_dest:[];var cos=Math.cos(angle);var sin=Math.sin(angle);var anchorX=anchor[0];var anchorY=anchor[1];var i=0;for(var j=offset;j<end;j+=stride){var deltaX=flatCoordinates[j]-anchorX;var deltaY=flatCoordinates[j+1]-anchorY;dest[i++]=anchorX+deltaX*cos-deltaY*sin;dest[i++]=anchorY+deltaX*sin+deltaY*cos;for(var k=j+2;k<j+stride;++k){dest[i++]=flatCoordinates[k];}}if(opt_dest&&dest.length!=i){dest.length=i;}return dest;};/**
 * Scale the coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array.<number>} anchor Scale anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */_ol_geom_flat_transform_.scale=function(flatCoordinates,offset,end,stride,sx,sy,anchor,opt_dest){var dest=opt_dest?opt_dest:[];var anchorX=anchor[0];var anchorY=anchor[1];var i=0;for(var j=offset;j<end;j+=stride){var deltaX=flatCoordinates[j]-anchorX;var deltaY=flatCoordinates[j+1]-anchorY;dest[i++]=anchorX+sx*deltaX;dest[i++]=anchorY+sy*deltaY;for(var k=j+2;k<j+stride;++k){dest[i++]=flatCoordinates[k];}}if(opt_dest&&dest.length!=i){dest.length=i;}return dest;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */_ol_geom_flat_transform_.translate=function(flatCoordinates,offset,end,stride,deltaX,deltaY,opt_dest){var dest=opt_dest?opt_dest:[];var i=0;var j,k;for(j=offset;j<end;j+=stride){dest[i++]=flatCoordinates[j]+deltaX;dest[i++]=flatCoordinates[j+1]+deltaY;for(k=j+2;k<j+stride;++k){dest[i++]=flatCoordinates[k];}}if(opt_dest&&dest.length!=i){dest.length=i;}return dest;};/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @constructor
 * @abstract
 * @extends {ol.geom.Geometry}
 * @api
 */var _ol_geom_SimpleGeometry_=function(){_ol_geom_Geometry_.call(this);/**
   * @protected
   * @type {ol.geom.GeometryLayout}
   */this.layout=_ol_geom_GeometryLayout_.XY;/**
   * @protected
   * @type {number}
   */this.stride=2;/**
   * @protected
   * @type {Array.<number>}
   */this.flatCoordinates=null;};_ol_.inherits(_ol_geom_SimpleGeometry_,_ol_geom_Geometry_);/**
 * @param {number} stride Stride.
 * @private
 * @return {ol.geom.GeometryLayout} layout Layout.
 */_ol_geom_SimpleGeometry_.getLayoutForStride_=function(stride){var layout;if(stride==2){layout=_ol_geom_GeometryLayout_.XY;}else if(stride==3){layout=_ol_geom_GeometryLayout_.XYZ;}else if(stride==4){layout=_ol_geom_GeometryLayout_.XYZM;}return(/** @type {ol.geom.GeometryLayout} */layout);};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @return {number} Stride.
 */_ol_geom_SimpleGeometry_.getStrideForLayout=function(layout){var stride;if(layout==_ol_geom_GeometryLayout_.XY){stride=2;}else if(layout==_ol_geom_GeometryLayout_.XYZ||layout==_ol_geom_GeometryLayout_.XYM){stride=3;}else if(layout==_ol_geom_GeometryLayout_.XYZM){stride=4;}return(/** @type {number} */stride);};/**
 * @inheritDoc
 */_ol_geom_SimpleGeometry_.prototype.containsXY=_ol_functions_.FALSE;/**
 * @inheritDoc
 */_ol_geom_SimpleGeometry_.prototype.computeExtent=function(extent){return _ol_extent_.createOrUpdateFromFlatCoordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,extent);};/**
 * @abstract
 * @return {Array} Coordinates.
 */_ol_geom_SimpleGeometry_.prototype.getCoordinates=function(){};/**
 * Return the first coordinate of the geometry.
 * @return {ol.Coordinate} First coordinate.
 * @api
 */_ol_geom_SimpleGeometry_.prototype.getFirstCoordinate=function(){return this.flatCoordinates.slice(0,this.stride);};/**
 * @return {Array.<number>} Flat coordinates.
 */_ol_geom_SimpleGeometry_.prototype.getFlatCoordinates=function(){return this.flatCoordinates;};/**
 * Return the last coordinate of the geometry.
 * @return {ol.Coordinate} Last point.
 * @api
 */_ol_geom_SimpleGeometry_.prototype.getLastCoordinate=function(){return this.flatCoordinates.slice(this.flatCoordinates.length-this.stride);};/**
 * Return the {@link ol.geom.GeometryLayout layout} of the geometry.
 * @return {ol.geom.GeometryLayout} Layout.
 * @api
 */_ol_geom_SimpleGeometry_.prototype.getLayout=function(){return this.layout;};/**
 * @inheritDoc
 */_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometry=function(squaredTolerance){if(this.simplifiedGeometryRevision!=this.getRevision()){_ol_obj_.clear(this.simplifiedGeometryCache);this.simplifiedGeometryMaxMinSquaredTolerance=0;this.simplifiedGeometryRevision=this.getRevision();}// If squaredTolerance is negative or if we know that simplification will not
// have any effect then just return this.
if(squaredTolerance<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&squaredTolerance<=this.simplifiedGeometryMaxMinSquaredTolerance){return this;}var key=squaredTolerance.toString();if(this.simplifiedGeometryCache.hasOwnProperty(key)){return this.simplifiedGeometryCache[key];}else{var simplifiedGeometry=this.getSimplifiedGeometryInternal(squaredTolerance);var simplifiedFlatCoordinates=simplifiedGeometry.getFlatCoordinates();if(simplifiedFlatCoordinates.length<this.flatCoordinates.length){this.simplifiedGeometryCache[key]=simplifiedGeometry;return simplifiedGeometry;}else{// Simplification did not actually remove any coordinates.  We now know
// that any calls to getSimplifiedGeometry with a squaredTolerance less
// than or equal to the current squaredTolerance will also not have any
// effect.  This allows us to short circuit simplification (saving CPU
// cycles) and prevents the cache of simplified geometries from filling
// up with useless identical copies of this geometry (saving memory).
this.simplifiedGeometryMaxMinSquaredTolerance=squaredTolerance;return this;}}};/**
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.SimpleGeometry} Simplified geometry.
 * @protected
 */_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometryInternal=function(squaredTolerance){return this;};/**
 * @return {number} Stride.
 */_ol_geom_SimpleGeometry_.prototype.getStride=function(){return this.stride;};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @protected
 */_ol_geom_SimpleGeometry_.prototype.setFlatCoordinatesInternal=function(layout,flatCoordinates){this.stride=_ol_geom_SimpleGeometry_.getStrideForLayout(layout);this.layout=layout;this.flatCoordinates=flatCoordinates;};/**
 * @abstract
 * @param {Array} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 */_ol_geom_SimpleGeometry_.prototype.setCoordinates=function(coordinates,opt_layout){};/**
 * @param {ol.geom.GeometryLayout|undefined} layout Layout.
 * @param {Array} coordinates Coordinates.
 * @param {number} nesting Nesting.
 * @protected
 */_ol_geom_SimpleGeometry_.prototype.setLayout=function(layout,coordinates,nesting){/** @type {number} */var stride;if(layout){stride=_ol_geom_SimpleGeometry_.getStrideForLayout(layout);}else{var i;for(i=0;i<nesting;++i){if(coordinates.length===0){this.layout=_ol_geom_GeometryLayout_.XY;this.stride=2;return;}else{coordinates=/** @type {Array} */coordinates[0];}}stride=coordinates.length;layout=_ol_geom_SimpleGeometry_.getLayoutForStride_(stride);}this.layout=layout;this.stride=stride;};/**
 * @inheritDoc
 * @api
 */_ol_geom_SimpleGeometry_.prototype.applyTransform=function(transformFn){if(this.flatCoordinates){transformFn(this.flatCoordinates,this.flatCoordinates,this.stride);this.changed();}};/**
 * @inheritDoc
 * @api
 */_ol_geom_SimpleGeometry_.prototype.rotate=function(angle,anchor){var flatCoordinates=this.getFlatCoordinates();if(flatCoordinates){var stride=this.getStride();_ol_geom_flat_transform_.rotate(flatCoordinates,0,flatCoordinates.length,stride,angle,anchor,flatCoordinates);this.changed();}};/**
 * @inheritDoc
 * @api
 */_ol_geom_SimpleGeometry_.prototype.scale=function(sx,opt_sy,opt_anchor){var sy=opt_sy;if(sy===undefined){sy=sx;}var anchor=opt_anchor;if(!anchor){anchor=_ol_extent_.getCenter(this.getExtent());}var flatCoordinates=this.getFlatCoordinates();if(flatCoordinates){var stride=this.getStride();_ol_geom_flat_transform_.scale(flatCoordinates,0,flatCoordinates.length,stride,sx,sy,anchor,flatCoordinates);this.changed();}};/**
 * @inheritDoc
 * @api
 */_ol_geom_SimpleGeometry_.prototype.translate=function(deltaX,deltaY){var flatCoordinates=this.getFlatCoordinates();if(flatCoordinates){var stride=this.getStride();_ol_geom_flat_transform_.translate(flatCoordinates,0,flatCoordinates.length,stride,deltaX,deltaY,flatCoordinates);this.changed();}};/**
 * @param {ol.geom.SimpleGeometry} simpleGeometry Simple geometry.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed flat coordinates.
 */_ol_geom_SimpleGeometry_.transform2D=function(simpleGeometry,transform,opt_dest){var flatCoordinates=simpleGeometry.getFlatCoordinates();if(!flatCoordinates){return null;}else{var stride=simpleGeometry.getStride();return _ol_geom_flat_transform_.transform2D(flatCoordinates,0,flatCoordinates.length,stride,transform,opt_dest);}};var _ol_geom_flat_area_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */_ol_geom_flat_area_.linearRing=function(flatCoordinates,offset,end,stride){var twiceArea=0;var x1=flatCoordinates[end-stride];var y1=flatCoordinates[end-stride+1];for(;offset<end;offset+=stride){var x2=flatCoordinates[offset];var y2=flatCoordinates[offset+1];twiceArea+=y1*x2-x1*y2;x1=x2;y1=y2;}return twiceArea/2;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */_ol_geom_flat_area_.linearRings=function(flatCoordinates,offset,ends,stride){var area=0;var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];area+=_ol_geom_flat_area_.linearRing(flatCoordinates,offset,end,stride);offset=end;}return area;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */_ol_geom_flat_area_.linearRingss=function(flatCoordinates,offset,endss,stride){var area=0;var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];area+=_ol_geom_flat_area_.linearRings(flatCoordinates,offset,ends,stride);offset=ends[ends.length-1];}return area;};var _ol_geom_flat_closest_={};/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 */_ol_geom_flat_closest_.point=function(flatCoordinates,offset1,offset2,stride,x,y,closestPoint){var x1=flatCoordinates[offset1];var y1=flatCoordinates[offset1+1];var dx=flatCoordinates[offset2]-x1;var dy=flatCoordinates[offset2+1]-y1;var i,offset;if(dx===0&&dy===0){offset=offset1;}else{var t=((x-x1)*dx+(y-y1)*dy)/(dx*dx+dy*dy);if(t>1){offset=offset2;}else if(t>0){for(i=0;i<stride;++i){closestPoint[i]=_ol_math_.lerp(flatCoordinates[offset1+i],flatCoordinates[offset2+i],t);}closestPoint.length=stride;return;}else{offset=offset1;}}for(i=0;i<stride;++i){closestPoint[i]=flatCoordinates[offset+i];}closestPoint.length=stride;};/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */_ol_geom_flat_closest_.getMaxSquaredDelta=function(flatCoordinates,offset,end,stride,maxSquaredDelta){var x1=flatCoordinates[offset];var y1=flatCoordinates[offset+1];for(offset+=stride;offset<end;offset+=stride){var x2=flatCoordinates[offset];var y2=flatCoordinates[offset+1];var squaredDelta=_ol_math_.squaredDistance(x1,y1,x2,y2);if(squaredDelta>maxSquaredDelta){maxSquaredDelta=squaredDelta;}x1=x2;y1=y2;}return maxSquaredDelta;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */_ol_geom_flat_closest_.getsMaxSquaredDelta=function(flatCoordinates,offset,ends,stride,maxSquaredDelta){var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];maxSquaredDelta=_ol_geom_flat_closest_.getMaxSquaredDelta(flatCoordinates,offset,end,stride,maxSquaredDelta);offset=end;}return maxSquaredDelta;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */_ol_geom_flat_closest_.getssMaxSquaredDelta=function(flatCoordinates,offset,endss,stride,maxSquaredDelta){var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];maxSquaredDelta=_ol_geom_flat_closest_.getsMaxSquaredDelta(flatCoordinates,offset,ends,stride,maxSquaredDelta);offset=ends[ends.length-1];}return maxSquaredDelta;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */_ol_geom_flat_closest_.getClosestPoint=function(flatCoordinates,offset,end,stride,maxDelta,isRing,x,y,closestPoint,minSquaredDistance,opt_tmpPoint){if(offset==end){return minSquaredDistance;}var i,squaredDistance;if(maxDelta===0){// All points are identical, so just test the first point.
squaredDistance=_ol_math_.squaredDistance(x,y,flatCoordinates[offset],flatCoordinates[offset+1]);if(squaredDistance<minSquaredDistance){for(i=0;i<stride;++i){closestPoint[i]=flatCoordinates[offset+i];}closestPoint.length=stride;return squaredDistance;}else{return minSquaredDistance;}}var tmpPoint=opt_tmpPoint?opt_tmpPoint:[NaN,NaN];var index=offset+stride;while(index<end){_ol_geom_flat_closest_.point(flatCoordinates,index-stride,index,stride,x,y,tmpPoint);squaredDistance=_ol_math_.squaredDistance(x,y,tmpPoint[0],tmpPoint[1]);if(squaredDistance<minSquaredDistance){minSquaredDistance=squaredDistance;for(i=0;i<stride;++i){closestPoint[i]=tmpPoint[i];}closestPoint.length=stride;index+=stride;}else{// Skip ahead multiple points, because we know that all the skipped
// points cannot be any closer than the closest point we have found so
// far.  We know this because we know how close the current point is, how
// close the closest point we have found so far is, and the maximum
// distance between consecutive points.  For example, if we're currently
// at distance 10, the best we've found so far is 3, and that the maximum
// distance between consecutive points is 2, then we'll need to skip at
// least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
// finding a closer point.  We use Math.max(..., 1) to ensure that we
// always advance at least one point, to avoid an infinite loop.
index+=stride*Math.max((Math.sqrt(squaredDistance)-Math.sqrt(minSquaredDistance))/maxDelta|0,1);}}if(isRing){// Check the closing segment.
_ol_geom_flat_closest_.point(flatCoordinates,end-stride,offset,stride,x,y,tmpPoint);squaredDistance=_ol_math_.squaredDistance(x,y,tmpPoint[0],tmpPoint[1]);if(squaredDistance<minSquaredDistance){minSquaredDistance=squaredDistance;for(i=0;i<stride;++i){closestPoint[i]=tmpPoint[i];}closestPoint.length=stride;}}return minSquaredDistance;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */_ol_geom_flat_closest_.getsClosestPoint=function(flatCoordinates,offset,ends,stride,maxDelta,isRing,x,y,closestPoint,minSquaredDistance,opt_tmpPoint){var tmpPoint=opt_tmpPoint?opt_tmpPoint:[NaN,NaN];var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];minSquaredDistance=_ol_geom_flat_closest_.getClosestPoint(flatCoordinates,offset,end,stride,maxDelta,isRing,x,y,closestPoint,minSquaredDistance,tmpPoint);offset=end;}return minSquaredDistance;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */_ol_geom_flat_closest_.getssClosestPoint=function(flatCoordinates,offset,endss,stride,maxDelta,isRing,x,y,closestPoint,minSquaredDistance,opt_tmpPoint){var tmpPoint=opt_tmpPoint?opt_tmpPoint:[NaN,NaN];var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];minSquaredDistance=_ol_geom_flat_closest_.getsClosestPoint(flatCoordinates,offset,ends,stride,maxDelta,isRing,x,y,closestPoint,minSquaredDistance,tmpPoint);offset=ends[ends.length-1];}return minSquaredDistance;};var _ol_geom_flat_deflate_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */_ol_geom_flat_deflate_.coordinate=function(flatCoordinates,offset,coordinate,stride){var i,ii;for(i=0,ii=coordinate.length;i<ii;++i){flatCoordinates[offset++]=coordinate[i];}return offset;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */_ol_geom_flat_deflate_.coordinates=function(flatCoordinates,offset,coordinates,stride){var i,ii;for(i=0,ii=coordinates.length;i<ii;++i){var coordinate=coordinates[i];var j;for(j=0;j<stride;++j){flatCoordinates[offset++]=coordinate[j];}}return offset;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<ol.Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array.<number>=} opt_ends Ends.
 * @return {Array.<number>} Ends.
 */_ol_geom_flat_deflate_.coordinatess=function(flatCoordinates,offset,coordinatess,stride,opt_ends){var ends=opt_ends?opt_ends:[];var i=0;var j,jj;for(j=0,jj=coordinatess.length;j<jj;++j){var end=_ol_geom_flat_deflate_.coordinates(flatCoordinates,offset,coordinatess[j],stride);ends[i++]=end;offset=end;}ends.length=i;return ends;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<number>>=} opt_endss Endss.
 * @return {Array.<Array.<number>>} Endss.
 */_ol_geom_flat_deflate_.coordinatesss=function(flatCoordinates,offset,coordinatesss,stride,opt_endss){var endss=opt_endss?opt_endss:[];var i=0;var j,jj;for(j=0,jj=coordinatesss.length;j<jj;++j){var ends=_ol_geom_flat_deflate_.coordinatess(flatCoordinates,offset,coordinatesss[j],stride,endss[i]);endss[i++]=ends;offset=ends[ends.length-1];}endss.length=i;return endss;};var _ol_geom_flat_inflate_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array.<ol.Coordinate>=} opt_coordinates Coordinates.
 * @return {Array.<ol.Coordinate>} Coordinates.
 */_ol_geom_flat_inflate_.coordinates=function(flatCoordinates,offset,end,stride,opt_coordinates){var coordinates=opt_coordinates!==undefined?opt_coordinates:[];var i=0;var j;for(j=offset;j<end;j+=stride){coordinates[i++]=flatCoordinates.slice(j,j+stride);}coordinates.length=i;return coordinates;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<Array.<ol.Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinatess.
 */_ol_geom_flat_inflate_.coordinatess=function(flatCoordinates,offset,ends,stride,opt_coordinatess){var coordinatess=opt_coordinatess!==undefined?opt_coordinatess:[];var i=0;var j,jj;for(j=0,jj=ends.length;j<jj;++j){var end=ends[j];coordinatess[i++]=_ol_geom_flat_inflate_.coordinates(flatCoordinates,offset,end,stride,coordinatess[i]);offset=end;}coordinatess.length=i;return coordinatess;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinatesss.
 */_ol_geom_flat_inflate_.coordinatesss=function(flatCoordinates,offset,endss,stride,opt_coordinatesss){var coordinatesss=opt_coordinatesss!==undefined?opt_coordinatesss:[];var i=0;var j,jj;for(j=0,jj=endss.length;j<jj;++j){var ends=endss[j];coordinatesss[i++]=_ol_geom_flat_inflate_.coordinatess(flatCoordinates,offset,ends,stride,coordinatesss[i]);offset=ends[ends.length-1];}coordinatesss.length=i;return coordinatesss;};// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
var _ol_geom_flat_simplify_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array.<number>} Simplified line string.
 */_ol_geom_flat_simplify_.lineString=function(flatCoordinates,offset,end,stride,squaredTolerance,highQuality,opt_simplifiedFlatCoordinates){var simplifiedFlatCoordinates=opt_simplifiedFlatCoordinates!==undefined?opt_simplifiedFlatCoordinates:[];if(!highQuality){end=_ol_geom_flat_simplify_.radialDistance(flatCoordinates,offset,end,stride,squaredTolerance,simplifiedFlatCoordinates,0);flatCoordinates=simplifiedFlatCoordinates;offset=0;stride=2;}simplifiedFlatCoordinates.length=_ol_geom_flat_simplify_.douglasPeucker(flatCoordinates,offset,end,stride,squaredTolerance,simplifiedFlatCoordinates,0);return simplifiedFlatCoordinates;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */_ol_geom_flat_simplify_.douglasPeucker=function(flatCoordinates,offset,end,stride,squaredTolerance,simplifiedFlatCoordinates,simplifiedOffset){var n=(end-offset)/stride;if(n<3){for(;offset<end;offset+=stride){simplifiedFlatCoordinates[simplifiedOffset++]=flatCoordinates[offset];simplifiedFlatCoordinates[simplifiedOffset++]=flatCoordinates[offset+1];}return simplifiedOffset;}/** @type {Array.<number>} */var markers=new Array(n);markers[0]=1;markers[n-1]=1;/** @type {Array.<number>} */var stack=[offset,end-stride];var index=0;var i;while(stack.length>0){var last=stack.pop();var first=stack.pop();var maxSquaredDistance=0;var x1=flatCoordinates[first];var y1=flatCoordinates[first+1];var x2=flatCoordinates[last];var y2=flatCoordinates[last+1];for(i=first+stride;i<last;i+=stride){var x=flatCoordinates[i];var y=flatCoordinates[i+1];var squaredDistance=_ol_math_.squaredSegmentDistance(x,y,x1,y1,x2,y2);if(squaredDistance>maxSquaredDistance){index=i;maxSquaredDistance=squaredDistance;}}if(maxSquaredDistance>squaredTolerance){markers[(index-offset)/stride]=1;if(first+stride<index){stack.push(first,index);}if(index+stride<last){stack.push(index,last);}}}for(i=0;i<n;++i){if(markers[i]){simplifiedFlatCoordinates[simplifiedOffset++]=flatCoordinates[offset+i*stride];simplifiedFlatCoordinates[simplifiedOffset++]=flatCoordinates[offset+i*stride+1];}}return simplifiedOffset;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */_ol_geom_flat_simplify_.douglasPeuckers=function(flatCoordinates,offset,ends,stride,squaredTolerance,simplifiedFlatCoordinates,simplifiedOffset,simplifiedEnds){var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];simplifiedOffset=_ol_geom_flat_simplify_.douglasPeucker(flatCoordinates,offset,end,stride,squaredTolerance,simplifiedFlatCoordinates,simplifiedOffset);simplifiedEnds.push(simplifiedOffset);offset=end;}return simplifiedOffset;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */_ol_geom_flat_simplify_.douglasPeuckerss=function(flatCoordinates,offset,endss,stride,squaredTolerance,simplifiedFlatCoordinates,simplifiedOffset,simplifiedEndss){var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];var simplifiedEnds=[];simplifiedOffset=_ol_geom_flat_simplify_.douglasPeuckers(flatCoordinates,offset,ends,stride,squaredTolerance,simplifiedFlatCoordinates,simplifiedOffset,simplifiedEnds);simplifiedEndss.push(simplifiedEnds);offset=ends[ends.length-1];}return simplifiedOffset;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */_ol_geom_flat_simplify_.radialDistance=function(flatCoordinates,offset,end,stride,squaredTolerance,simplifiedFlatCoordinates,simplifiedOffset){if(end<=offset+stride){// zero or one point, no simplification possible, so copy and return
for(;offset<end;offset+=stride){simplifiedFlatCoordinates[simplifiedOffset++]=flatCoordinates[offset];simplifiedFlatCoordinates[simplifiedOffset++]=flatCoordinates[offset+1];}return simplifiedOffset;}var x1=flatCoordinates[offset];var y1=flatCoordinates[offset+1];// copy first point
simplifiedFlatCoordinates[simplifiedOffset++]=x1;simplifiedFlatCoordinates[simplifiedOffset++]=y1;var x2=x1;var y2=y1;for(offset+=stride;offset<end;offset+=stride){x2=flatCoordinates[offset];y2=flatCoordinates[offset+1];if(_ol_math_.squaredDistance(x1,y1,x2,y2)>squaredTolerance){// copy point at offset
simplifiedFlatCoordinates[simplifiedOffset++]=x2;simplifiedFlatCoordinates[simplifiedOffset++]=y2;x1=x2;y1=y2;}}if(x2!=x1||y2!=y1){// copy last point
simplifiedFlatCoordinates[simplifiedOffset++]=x2;simplifiedFlatCoordinates[simplifiedOffset++]=y2;}return simplifiedOffset;};/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */_ol_geom_flat_simplify_.snap=function(value,tolerance){return tolerance*Math.round(value/tolerance);};/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */_ol_geom_flat_simplify_.quantize=function(flatCoordinates,offset,end,stride,tolerance,simplifiedFlatCoordinates,simplifiedOffset){// do nothing if the line is empty
if(offset==end){return simplifiedOffset;}// snap the first coordinate (P1)
var x1=_ol_geom_flat_simplify_.snap(flatCoordinates[offset],tolerance);var y1=_ol_geom_flat_simplify_.snap(flatCoordinates[offset+1],tolerance);offset+=stride;// add the first coordinate to the output
simplifiedFlatCoordinates[simplifiedOffset++]=x1;simplifiedFlatCoordinates[simplifiedOffset++]=y1;// find the next coordinate that does not snap to the same value as the first
// coordinate (P2)
var x2,y2;do{x2=_ol_geom_flat_simplify_.snap(flatCoordinates[offset],tolerance);y2=_ol_geom_flat_simplify_.snap(flatCoordinates[offset+1],tolerance);offset+=stride;if(offset==end){// all coordinates snap to the same value, the line collapses to a point
// push the last snapped value anyway to ensure that the output contains
// at least two points
// FIXME should we really return at least two points anyway?
simplifiedFlatCoordinates[simplifiedOffset++]=x2;simplifiedFlatCoordinates[simplifiedOffset++]=y2;return simplifiedOffset;}}while(x2==x1&&y2==y1);while(offset<end){var x3,y3;// snap the next coordinate (P3)
x3=_ol_geom_flat_simplify_.snap(flatCoordinates[offset],tolerance);y3=_ol_geom_flat_simplify_.snap(flatCoordinates[offset+1],tolerance);offset+=stride;// skip P3 if it is equal to P2
if(x3==x2&&y3==y2){continue;}// calculate the delta between P1 and P2
var dx1=x2-x1;var dy1=y2-y1;// calculate the delta between P3 and P1
var dx2=x3-x1;var dy2=y3-y1;// if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
// P1 in the same direction then P2 is on the straight line between P1 and
// P3
if(dx1*dy2==dy1*dx2&&(dx1<0&&dx2<dx1||dx1==dx2||dx1>0&&dx2>dx1)&&(dy1<0&&dy2<dy1||dy1==dy2||dy1>0&&dy2>dy1)){// discard P2 and set P2 = P3
x2=x3;y2=y3;continue;}// either P1, P2, and P3 are not colinear, or they are colinear but P3 is
// between P3 and P1 or on the opposite half of the line to P2.  add P2,
// and continue with P1 = P2 and P2 = P3
simplifiedFlatCoordinates[simplifiedOffset++]=x2;simplifiedFlatCoordinates[simplifiedOffset++]=y2;x1=x2;y1=y2;x2=x3;y2=y3;}// add the last point (P2)
simplifiedFlatCoordinates[simplifiedOffset++]=x2;simplifiedFlatCoordinates[simplifiedOffset++]=y2;return simplifiedOffset;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */_ol_geom_flat_simplify_.quantizes=function(flatCoordinates,offset,ends,stride,tolerance,simplifiedFlatCoordinates,simplifiedOffset,simplifiedEnds){var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];simplifiedOffset=_ol_geom_flat_simplify_.quantize(flatCoordinates,offset,end,stride,tolerance,simplifiedFlatCoordinates,simplifiedOffset);simplifiedEnds.push(simplifiedOffset);offset=end;}return simplifiedOffset;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */_ol_geom_flat_simplify_.quantizess=function(flatCoordinates,offset,endss,stride,tolerance,simplifiedFlatCoordinates,simplifiedOffset,simplifiedEndss){var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];var simplifiedEnds=[];simplifiedOffset=_ol_geom_flat_simplify_.quantizes(flatCoordinates,offset,ends,stride,tolerance,simplifiedFlatCoordinates,simplifiedOffset,simplifiedEnds);simplifiedEndss.push(simplifiedEnds);offset=ends[ends.length-1];}return simplifiedOffset;};/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_LinearRing_=function(coordinates,opt_layout){_ol_geom_SimpleGeometry_.call(this);/**
   * @private
   * @type {number}
   */this.maxDelta_=-1;/**
   * @private
   * @type {number}
   */this.maxDeltaRevision_=-1;this.setCoordinates(coordinates,opt_layout);};_ol_.inherits(_ol_geom_LinearRing_,_ol_geom_SimpleGeometry_);/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LinearRing} Clone.
 * @override
 * @api
 */_ol_geom_LinearRing_.prototype.clone=function(){var linearRing=new _ol_geom_LinearRing_(null);linearRing.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return linearRing;};/**
 * @inheritDoc
 */_ol_geom_LinearRing_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){if(minSquaredDistance<_ol_extent_.closestSquaredDistanceXY(this.getExtent(),x,y)){return minSquaredDistance;}if(this.maxDeltaRevision_!=this.getRevision()){this.maxDelta_=Math.sqrt(_ol_geom_flat_closest_.getMaxSquaredDelta(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0));this.maxDeltaRevision_=this.getRevision();}return _ol_geom_flat_closest_.getClosestPoint(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,true,x,y,closestPoint,minSquaredDistance);};/**
 * Return the area of the linear ring on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */_ol_geom_LinearRing_.prototype.getArea=function(){return _ol_geom_flat_area_.linearRing(this.flatCoordinates,0,this.flatCoordinates.length,this.stride);};/**
 * Return the coordinates of the linear ring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */_ol_geom_LinearRing_.prototype.getCoordinates=function(){return _ol_geom_flat_inflate_.coordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride);};/**
 * @inheritDoc
 */_ol_geom_LinearRing_.prototype.getSimplifiedGeometryInternal=function(squaredTolerance){var simplifiedFlatCoordinates=[];simplifiedFlatCoordinates.length=_ol_geom_flat_simplify_.douglasPeucker(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,squaredTolerance,simplifiedFlatCoordinates,0);var simplifiedLinearRing=new _ol_geom_LinearRing_(null);simplifiedLinearRing.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,simplifiedFlatCoordinates);return simplifiedLinearRing;};/**
 * @inheritDoc
 * @api
 */_ol_geom_LinearRing_.prototype.getType=function(){return _ol_geom_GeometryType_.LINEAR_RING;};/**
 * @inheritDoc
 */_ol_geom_LinearRing_.prototype.intersectsExtent=function(extent){};/**
 * Set the coordinates of the linear ring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */_ol_geom_LinearRing_.prototype.setCoordinates=function(coordinates,opt_layout){if(!coordinates){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null);}else{this.setLayout(opt_layout,coordinates,1);if(!this.flatCoordinates){this.flatCoordinates=[];}this.flatCoordinates.length=_ol_geom_flat_deflate_.coordinates(this.flatCoordinates,0,coordinates,this.stride);this.changed();}};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */_ol_geom_LinearRing_.prototype.setFlatCoordinates=function(layout,flatCoordinates){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.changed();};/**
 * @classdesc
 * Point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {ol.Coordinate} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_Point_=function(coordinates,opt_layout){_ol_geom_SimpleGeometry_.call(this);this.setCoordinates(coordinates,opt_layout);};_ol_.inherits(_ol_geom_Point_,_ol_geom_SimpleGeometry_);/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Point} Clone.
 * @override
 * @api
 */_ol_geom_Point_.prototype.clone=function(){var point=new _ol_geom_Point_(null);point.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return point;};/**
 * @inheritDoc
 */_ol_geom_Point_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){var flatCoordinates=this.flatCoordinates;var squaredDistance=_ol_math_.squaredDistance(x,y,flatCoordinates[0],flatCoordinates[1]);if(squaredDistance<minSquaredDistance){var stride=this.stride;var i;for(i=0;i<stride;++i){closestPoint[i]=flatCoordinates[i];}closestPoint.length=stride;return squaredDistance;}else{return minSquaredDistance;}};/**
 * Return the coordinate of the point.
 * @return {ol.Coordinate} Coordinates.
 * @override
 * @api
 */_ol_geom_Point_.prototype.getCoordinates=function(){return!this.flatCoordinates?[]:this.flatCoordinates.slice();};/**
 * @inheritDoc
 */_ol_geom_Point_.prototype.computeExtent=function(extent){return _ol_extent_.createOrUpdateFromCoordinate(this.flatCoordinates,extent);};/**
 * @inheritDoc
 * @api
 */_ol_geom_Point_.prototype.getType=function(){return _ol_geom_GeometryType_.POINT;};/**
 * @inheritDoc
 * @api
 */_ol_geom_Point_.prototype.intersectsExtent=function(extent){return _ol_extent_.containsXY(extent,this.flatCoordinates[0],this.flatCoordinates[1]);};/**
 * @inheritDoc
 * @api
 */_ol_geom_Point_.prototype.setCoordinates=function(coordinates,opt_layout){if(!coordinates){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null);}else{this.setLayout(opt_layout,coordinates,0);if(!this.flatCoordinates){this.flatCoordinates=[];}this.flatCoordinates.length=_ol_geom_flat_deflate_.coordinate(this.flatCoordinates,0,coordinates,this.stride);this.changed();}};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */_ol_geom_Point_.prototype.setFlatCoordinates=function(layout,flatCoordinates){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.changed();};var _ol_geom_flat_contains_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Contains extent.
 */_ol_geom_flat_contains_.linearRingContainsExtent=function(flatCoordinates,offset,end,stride,extent){var outside=_ol_extent_.forEachCorner(extent,/**
       * @param {ol.Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */function(coordinate){return!_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,offset,end,stride,coordinate[0],coordinate[1]);});return!outside;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */_ol_geom_flat_contains_.linearRingContainsXY=function(flatCoordinates,offset,end,stride,x,y){// http://geomalgorithms.com/a03-_inclusion.html
// Copyright 2000 softSurfer, 2012 Dan Sunday
// This code may be freely used and modified for any purpose
// providing that this copyright notice is included with it.
// SoftSurfer makes no warranty for this code, and cannot be held
// liable for any real or imagined damage resulting from its use.
// Users of this code must verify correctness for their application.
var wn=0;var x1=flatCoordinates[end-stride];var y1=flatCoordinates[end-stride+1];for(;offset<end;offset+=stride){var x2=flatCoordinates[offset];var y2=flatCoordinates[offset+1];if(y1<=y){if(y2>y&&(x2-x1)*(y-y1)-(x-x1)*(y2-y1)>0){wn++;}}else if(y2<=y&&(x2-x1)*(y-y1)-(x-x1)*(y2-y1)<0){wn--;}x1=x2;y1=y2;}return wn!==0;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */_ol_geom_flat_contains_.linearRingsContainsXY=function(flatCoordinates,offset,ends,stride,x,y){if(ends.length===0){return false;}if(!_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,offset,ends[0],stride,x,y)){return false;}var i,ii;for(i=1,ii=ends.length;i<ii;++i){if(_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,ends[i-1],ends[i],stride,x,y)){return false;}}return true;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */_ol_geom_flat_contains_.linearRingssContainsXY=function(flatCoordinates,offset,endss,stride,x,y){if(endss.length===0){return false;}var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];if(_ol_geom_flat_contains_.linearRingsContainsXY(flatCoordinates,offset,ends,stride,x,y)){return true;}offset=ends[ends.length-1];}return false;};var _ol_geom_flat_interiorpoint_={};/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination.
 */_ol_geom_flat_interiorpoint_.linearRings=function(flatCoordinates,offset,ends,stride,flatCenters,flatCentersOffset,opt_dest){var i,ii,x,x1,x2,y1,y2;var y=flatCenters[flatCentersOffset+1];/** @type {Array.<number>} */var intersections=[];// Calculate intersections with the horizontal line
var end=ends[0];x1=flatCoordinates[end-stride];y1=flatCoordinates[end-stride+1];for(i=offset;i<end;i+=stride){x2=flatCoordinates[i];y2=flatCoordinates[i+1];if(y<=y1&&y2<=y||y1<=y&&y<=y2){x=(y-y1)/(y2-y1)*(x2-x1)+x1;intersections.push(x);}x1=x2;y1=y2;}// Find the longest segment of the horizontal line that has its center point
// inside the linear ring.
var pointX=NaN;var maxSegmentLength=-Infinity;intersections.sort(_ol_array_.numberSafeCompareFunction);x1=intersections[0];for(i=1,ii=intersections.length;i<ii;++i){x2=intersections[i];var segmentLength=Math.abs(x2-x1);if(segmentLength>maxSegmentLength){x=(x1+x2)/2;if(_ol_geom_flat_contains_.linearRingsContainsXY(flatCoordinates,offset,ends,stride,x,y)){pointX=x;maxSegmentLength=segmentLength;}}x1=x2;}if(isNaN(pointX)){// There is no horizontal line that has its center point inside the linear
// ring.  Use the center of the the linear ring's extent.
pointX=flatCenters[flatCentersOffset];}if(opt_dest){opt_dest.push(pointX,y);return opt_dest;}else{return[pointX,y];}};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @return {Array.<number>} Interior points.
 */_ol_geom_flat_interiorpoint_.linearRingss=function(flatCoordinates,offset,endss,stride,flatCenters){var interiorPoints=[];var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];interiorPoints=_ol_geom_flat_interiorpoint_.linearRings(flatCoordinates,offset,ends,stride,flatCenters,2*i,interiorPoints);offset=ends[ends.length-1];}return interiorPoints;};var _ol_geom_flat_segments_={};/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */_ol_geom_flat_segments_.forEach=function(flatCoordinates,offset,end,stride,callback,opt_this){var point1=[flatCoordinates[offset],flatCoordinates[offset+1]];var point2=[];var ret;for(;offset+stride<end;offset+=stride){point2[0]=flatCoordinates[offset+stride];point2[1]=flatCoordinates[offset+stride+1];ret=callback.call(opt_this,point1,point2);if(ret){return ret;}point1[0]=point2[0];point1[1]=point2[1];}return false;};var _ol_geom_flat_intersectsextent_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */_ol_geom_flat_intersectsextent_.lineString=function(flatCoordinates,offset,end,stride,extent){var coordinatesExtent=_ol_extent_.extendFlatCoordinates(_ol_extent_.createEmpty(),flatCoordinates,offset,end,stride);if(!_ol_extent_.intersects(extent,coordinatesExtent)){return false;}if(_ol_extent_.containsExtent(extent,coordinatesExtent)){return true;}if(coordinatesExtent[0]>=extent[0]&&coordinatesExtent[2]<=extent[2]){return true;}if(coordinatesExtent[1]>=extent[1]&&coordinatesExtent[3]<=extent[3]){return true;}return _ol_geom_flat_segments_.forEach(flatCoordinates,offset,end,stride,/**
       * @param {ol.Coordinate} point1 Start point.
       * @param {ol.Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */function(point1,point2){return _ol_extent_.intersectsSegment(extent,point1,point2);});};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */_ol_geom_flat_intersectsextent_.lineStrings=function(flatCoordinates,offset,ends,stride,extent){var i,ii;for(i=0,ii=ends.length;i<ii;++i){if(_ol_geom_flat_intersectsextent_.lineString(flatCoordinates,offset,ends[i],stride,extent)){return true;}offset=ends[i];}return false;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */_ol_geom_flat_intersectsextent_.linearRing=function(flatCoordinates,offset,end,stride,extent){if(_ol_geom_flat_intersectsextent_.lineString(flatCoordinates,offset,end,stride,extent)){return true;}if(_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,offset,end,stride,extent[0],extent[1])){return true;}if(_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,offset,end,stride,extent[0],extent[3])){return true;}if(_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,offset,end,stride,extent[2],extent[1])){return true;}if(_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates,offset,end,stride,extent[2],extent[3])){return true;}return false;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */_ol_geom_flat_intersectsextent_.linearRings=function(flatCoordinates,offset,ends,stride,extent){if(!_ol_geom_flat_intersectsextent_.linearRing(flatCoordinates,offset,ends[0],stride,extent)){return false;}if(ends.length===1){return true;}var i,ii;for(i=1,ii=ends.length;i<ii;++i){if(_ol_geom_flat_contains_.linearRingContainsExtent(flatCoordinates,ends[i-1],ends[i],stride,extent)){return false;}}return true;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */_ol_geom_flat_intersectsextent_.linearRingss=function(flatCoordinates,offset,endss,stride,extent){var i,ii;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];if(_ol_geom_flat_intersectsextent_.linearRings(flatCoordinates,offset,ends,stride,extent)){return true;}offset=ends[ends.length-1];}return false;};var _ol_geom_flat_reverse_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */_ol_geom_flat_reverse_.coordinates=function(flatCoordinates,offset,end,stride){while(offset<end-stride){var i;for(i=0;i<stride;++i){var tmp=flatCoordinates[offset+i];flatCoordinates[offset+i]=flatCoordinates[end-stride+i];flatCoordinates[end-stride+i]=tmp;}offset+=stride;end-=stride;}};var _ol_geom_flat_orient_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */_ol_geom_flat_orient_.linearRingIsClockwise=function(flatCoordinates,offset,end,stride){// http://tinyurl.com/clockwise-method
// https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
var edge=0;var x1=flatCoordinates[end-stride];var y1=flatCoordinates[end-stride+1];for(;offset<end;offset+=stride){var x2=flatCoordinates[offset];var y2=flatCoordinates[offset+1];edge+=(x2-x1)*(y2+y1);x1=x2;y1=y2;}return edge>0;};/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */_ol_geom_flat_orient_.linearRingsAreOriented=function(flatCoordinates,offset,ends,stride,opt_right){var right=opt_right!==undefined?opt_right:false;var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];var isClockwise=_ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates,offset,end,stride);if(i===0){if(right&&isClockwise||!right&&!isClockwise){return false;}}else{if(right&&!isClockwise||!right&&isClockwise){return false;}}offset=end;}return true;};/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */_ol_geom_flat_orient_.linearRingssAreOriented=function(flatCoordinates,offset,endss,stride,opt_right){var i,ii;for(i=0,ii=endss.length;i<ii;++i){if(!_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates,offset,endss[i],stride,opt_right)){return false;}}return true;};/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */_ol_geom_flat_orient_.orientLinearRings=function(flatCoordinates,offset,ends,stride,opt_right){var right=opt_right!==undefined?opt_right:false;var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];var isClockwise=_ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates,offset,end,stride);var reverse=i===0?right&&isClockwise||!right&&!isClockwise:right&&!isClockwise||!right&&isClockwise;if(reverse){_ol_geom_flat_reverse_.coordinates(flatCoordinates,offset,end,stride);}offset=end;}return offset;};/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */_ol_geom_flat_orient_.orientLinearRingss=function(flatCoordinates,offset,endss,stride,opt_right){var i,ii;for(i=0,ii=endss.length;i<ii;++i){offset=_ol_geom_flat_orient_.orientLinearRings(flatCoordinates,offset,endss[i],stride,opt_right);}return offset;};/**
 * @classdesc
 * Polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear
 *     rings that define the polygon. The first linear ring of the array
 *     defines the outer-boundary or surface of the polygon. Each subsequent
 *     linear ring defines a hole in the surface of the polygon. A linear ring
 *     is an array of vertices' coordinates where the first coordinate and the
 *     last are equivalent.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_Polygon_=function(coordinates,opt_layout){_ol_geom_SimpleGeometry_.call(this);/**
   * @type {Array.<number>}
   * @private
   */this.ends_=[];/**
   * @private
   * @type {number}
   */this.flatInteriorPointRevision_=-1;/**
   * @private
   * @type {ol.Coordinate}
   */this.flatInteriorPoint_=null;/**
   * @private
   * @type {number}
   */this.maxDelta_=-1;/**
   * @private
   * @type {number}
   */this.maxDeltaRevision_=-1;/**
   * @private
   * @type {number}
   */this.orientedRevision_=-1;/**
   * @private
   * @type {Array.<number>}
   */this.orientedFlatCoordinates_=null;this.setCoordinates(coordinates,opt_layout);};_ol_.inherits(_ol_geom_Polygon_,_ol_geom_SimpleGeometry_);/**
 * Append the passed linear ring to this polygon.
 * @param {ol.geom.LinearRing} linearRing Linear ring.
 * @api
 */_ol_geom_Polygon_.prototype.appendLinearRing=function(linearRing){if(!this.flatCoordinates){this.flatCoordinates=linearRing.getFlatCoordinates().slice();}else{_ol_array_.extend(this.flatCoordinates,linearRing.getFlatCoordinates());}this.ends_.push(this.flatCoordinates.length);this.changed();};/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Polygon} Clone.
 * @override
 * @api
 */_ol_geom_Polygon_.prototype.clone=function(){var polygon=new _ol_geom_Polygon_(null);polygon.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),this.ends_.slice());return polygon;};/**
 * @inheritDoc
 */_ol_geom_Polygon_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){if(minSquaredDistance<_ol_extent_.closestSquaredDistanceXY(this.getExtent(),x,y)){return minSquaredDistance;}if(this.maxDeltaRevision_!=this.getRevision()){this.maxDelta_=Math.sqrt(_ol_geom_flat_closest_.getsMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0));this.maxDeltaRevision_=this.getRevision();}return _ol_geom_flat_closest_.getsClosestPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,true,x,y,closestPoint,minSquaredDistance);};/**
 * @inheritDoc
 */_ol_geom_Polygon_.prototype.containsXY=function(x,y){return _ol_geom_flat_contains_.linearRingsContainsXY(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,x,y);};/**
 * Return the area of the polygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */_ol_geom_Polygon_.prototype.getArea=function(){return _ol_geom_flat_area_.linearRings(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride);};/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */_ol_geom_Polygon_.prototype.getCoordinates=function(opt_right){var flatCoordinates;if(opt_right!==undefined){flatCoordinates=this.getOrientedFlatCoordinates().slice();_ol_geom_flat_orient_.orientLinearRings(flatCoordinates,0,this.ends_,this.stride,opt_right);}else{flatCoordinates=this.flatCoordinates;}return _ol_geom_flat_inflate_.coordinatess(flatCoordinates,0,this.ends_,this.stride);};/**
 * @return {Array.<number>} Ends.
 */_ol_geom_Polygon_.prototype.getEnds=function(){return this.ends_;};/**
 * @return {Array.<number>} Interior point.
 */_ol_geom_Polygon_.prototype.getFlatInteriorPoint=function(){if(this.flatInteriorPointRevision_!=this.getRevision()){var flatCenter=_ol_extent_.getCenter(this.getExtent());this.flatInteriorPoint_=_ol_geom_flat_interiorpoint_.linearRings(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,flatCenter,0);this.flatInteriorPointRevision_=this.getRevision();}return this.flatInteriorPoint_;};/**
 * Return an interior point of the polygon.
 * @return {ol.geom.Point} Interior point.
 * @api
 */_ol_geom_Polygon_.prototype.getInteriorPoint=function(){return new _ol_geom_Point_(this.getFlatInteriorPoint());};/**
 * Return the number of rings of the polygon,  this includes the exterior
 * ring and any interior rings.
 *
 * @return {number} Number of rings.
 * @api
 */_ol_geom_Polygon_.prototype.getLinearRingCount=function(){return this.ends_.length;};/**
 * Return the Nth linear ring of the polygon geometry. Return `null` if the
 * given index is out of range.
 * The exterior linear ring is available at index `0` and the interior rings
 * at index `1` and beyond.
 *
 * @param {number} index Index.
 * @return {ol.geom.LinearRing} Linear ring.
 * @api
 */_ol_geom_Polygon_.prototype.getLinearRing=function(index){if(index<0||this.ends_.length<=index){return null;}var linearRing=new _ol_geom_LinearRing_(null);linearRing.setFlatCoordinates(this.layout,this.flatCoordinates.slice(index===0?0:this.ends_[index-1],this.ends_[index]));return linearRing;};/**
 * Return the linear rings of the polygon.
 * @return {Array.<ol.geom.LinearRing>} Linear rings.
 * @api
 */_ol_geom_Polygon_.prototype.getLinearRings=function(){var layout=this.layout;var flatCoordinates=this.flatCoordinates;var ends=this.ends_;var linearRings=[];var offset=0;var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];var linearRing=new _ol_geom_LinearRing_(null);linearRing.setFlatCoordinates(layout,flatCoordinates.slice(offset,end));linearRings.push(linearRing);offset=end;}return linearRings;};/**
 * @return {Array.<number>} Oriented flat coordinates.
 */_ol_geom_Polygon_.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var flatCoordinates=this.flatCoordinates;if(_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates,0,this.ends_,this.stride)){this.orientedFlatCoordinates_=flatCoordinates;}else{this.orientedFlatCoordinates_=flatCoordinates.slice();this.orientedFlatCoordinates_.length=_ol_geom_flat_orient_.orientLinearRings(this.orientedFlatCoordinates_,0,this.ends_,this.stride);}this.orientedRevision_=this.getRevision();}return this.orientedFlatCoordinates_;};/**
 * @inheritDoc
 */_ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal=function(squaredTolerance){var simplifiedFlatCoordinates=[];var simplifiedEnds=[];simplifiedFlatCoordinates.length=_ol_geom_flat_simplify_.quantizes(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(squaredTolerance),simplifiedFlatCoordinates,0,simplifiedEnds);var simplifiedPolygon=new _ol_geom_Polygon_(null);simplifiedPolygon.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,simplifiedFlatCoordinates,simplifiedEnds);return simplifiedPolygon;};/**
 * @inheritDoc
 * @api
 */_ol_geom_Polygon_.prototype.getType=function(){return _ol_geom_GeometryType_.POLYGON;};/**
 * @inheritDoc
 * @api
 */_ol_geom_Polygon_.prototype.intersectsExtent=function(extent){return _ol_geom_flat_intersectsextent_.linearRings(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,extent);};/**
 * Set the coordinates of the polygon.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */_ol_geom_Polygon_.prototype.setCoordinates=function(coordinates,opt_layout){if(!coordinates){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null,this.ends_);}else{this.setLayout(opt_layout,coordinates,2);if(!this.flatCoordinates){this.flatCoordinates=[];}var ends=_ol_geom_flat_deflate_.coordinatess(this.flatCoordinates,0,coordinates,this.stride,this.ends_);this.flatCoordinates.length=ends.length===0?0:ends[ends.length-1];this.changed();}};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */_ol_geom_Polygon_.prototype.setFlatCoordinates=function(layout,flatCoordinates,ends){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.ends_=ends;this.changed();};/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {ol.Sphere} sphere The sphere.
 * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @return {ol.geom.Polygon} The "circular" polygon.
 * @api
 */_ol_geom_Polygon_.circular=function(sphere,center,radius,opt_n){var n=opt_n?opt_n:32;/** @type {Array.<number>} */var flatCoordinates=[];var i;for(i=0;i<n;++i){_ol_array_.extend(flatCoordinates,sphere.offset(center,radius,2*Math.PI*i/n));}flatCoordinates.push(flatCoordinates[0],flatCoordinates[1]);var polygon=new _ol_geom_Polygon_(null);polygon.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,flatCoordinates,[flatCoordinates.length]);return polygon;};/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {ol.Extent} extent The extent.
 * @return {ol.geom.Polygon} The polygon.
 * @api
 */_ol_geom_Polygon_.fromExtent=function(extent){var minX=extent[0];var minY=extent[1];var maxX=extent[2];var maxY=extent[3];var flatCoordinates=[minX,minY,minX,maxY,maxX,maxY,maxX,minY,minX,minY];var polygon=new _ol_geom_Polygon_(null);polygon.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,flatCoordinates,[flatCoordinates.length]);return polygon;};/**
 * Create a regular polygon from a circle.
 * @param {ol.geom.Circle} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {ol.geom.Polygon} Polygon geometry.
 * @api
 */_ol_geom_Polygon_.fromCircle=function(circle,opt_sides,opt_angle){var sides=opt_sides?opt_sides:32;var stride=circle.getStride();var layout=circle.getLayout();var polygon=new _ol_geom_Polygon_(null,layout);var arrayLength=stride*(sides+1);var flatCoordinates=new Array(arrayLength);for(var i=0;i<arrayLength;i++){flatCoordinates[i]=0;}var ends=[flatCoordinates.length];polygon.setFlatCoordinates(layout,flatCoordinates,ends);_ol_geom_Polygon_.makeRegular(polygon,circle.getCenter(),circle.getRadius(),opt_angle);return polygon;};/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {ol.geom.Polygon} polygon Polygon geometry.
 * @param {ol.Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */_ol_geom_Polygon_.makeRegular=function(polygon,center,radius,opt_angle){var flatCoordinates=polygon.getFlatCoordinates();var layout=polygon.getLayout();var stride=polygon.getStride();var ends=polygon.getEnds();var sides=flatCoordinates.length/stride-1;var startAngle=opt_angle?opt_angle:0;var angle,offset;for(var i=0;i<=sides;++i){offset=i*stride;angle=startAngle+_ol_math_.modulo(i,sides)*2*Math.PI/sides;flatCoordinates[offset]=center[0]+radius*Math.cos(angle);flatCoordinates[offset+1]=center[1]+radius*Math.sin(angle);}polygon.setFlatCoordinates(layout,flatCoordinates,ends);};var _ol_color_={};/**
 * This RegExp matches # followed by 3 or 6 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */_ol_color_.HEX_COLOR_RE_=/^#(?:[0-9a-f]{3}){1,2}$/i;/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */_ol_color_.NAMED_COLOR_RE_=/^([a-z]*)$/i;/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {ol.Color|string} color Color.
 * @return {ol.Color} Color.
 * @api
 */_ol_color_.asArray=function(color){if(Array.isArray(color)){return color;}else{return _ol_color_.fromString(/** @type {string} */color);}};/**
 * Return the color as an rgba string.
 * @param {ol.Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */_ol_color_.asString=function(color){if(typeof color==='string'){return color;}else{return _ol_color_.toString(color);}};/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */_ol_color_.fromNamed=function(color){var el=document.createElement('div');el.style.color=color;document.body.appendChild(el);var rgb=getComputedStyle(el).color;document.body.removeChild(el);return rgb;};/**
 * @param {string} s String.
 * @return {ol.Color} Color.
 */_ol_color_.fromString=function(){// We maintain a small cache of parsed strings.  To provide cheap LRU-like
// semantics, whenever the cache grows too large we simply delete an
// arbitrary 25% of the entries.
/**
     * @const
     * @type {number}
     */var MAX_CACHE_SIZE=1024;/**
     * @type {Object.<string, ol.Color>}
     */var cache={};/**
     * @type {number}
     */var cacheSize=0;return(/**
       * @param {string} s String.
       * @return {ol.Color} Color.
       */function(s){var color;if(cache.hasOwnProperty(s)){color=cache[s];}else{if(cacheSize>=MAX_CACHE_SIZE){var i=0;var key;for(key in cache){if((i++&3)===0){delete cache[key];--cacheSize;}}}color=_ol_color_.fromStringInternal_(s);cache[s]=color;++cacheSize;}return color;});}();/**
 * @param {string} s String.
 * @private
 * @return {ol.Color} Color.
 */_ol_color_.fromStringInternal_=function(s){var r,g,b,a,color,parts;if(_ol_color_.NAMED_COLOR_RE_.exec(s)){s=_ol_color_.fromNamed(s);}if(_ol_color_.HEX_COLOR_RE_.exec(s)){// hex
var n=s.length-1;// number of hex digits
_ol_asserts_.assert(n==3||n==6,54);// Hex color should have 3 or 6 digits
var d=n==3?1:2;// number of digits per channel
r=parseInt(s.substr(1+0*d,d),16);g=parseInt(s.substr(1+1*d,d),16);b=parseInt(s.substr(1+2*d,d),16);if(d==1){r=(r<<4)+r;g=(g<<4)+g;b=(b<<4)+b;}a=1;color=[r,g,b,a];}else if(s.indexOf('rgba(')==0){// rgba()
parts=s.slice(5,-1).split(',').map(Number);color=_ol_color_.normalize(parts);}else if(s.indexOf('rgb(')==0){// rgb()
parts=s.slice(4,-1).split(',').map(Number);parts.push(1);color=_ol_color_.normalize(parts);}else{_ol_asserts_.assert(false,14);// Invalid color
}return(/** @type {ol.Color} */color);};/**
 * @param {ol.Color} color Color.
 * @param {ol.Color=} opt_color Color.
 * @return {ol.Color} Clamped color.
 */_ol_color_.normalize=function(color,opt_color){var result=opt_color||[];result[0]=_ol_math_.clamp(color[0]+0.5|0,0,255);result[1]=_ol_math_.clamp(color[1]+0.5|0,0,255);result[2]=_ol_math_.clamp(color[2]+0.5|0,0,255);result[3]=_ol_math_.clamp(color[3],0,1);return result;};/**
 * @param {ol.Color} color Color.
 * @return {string} String.
 */_ol_color_.toString=function(color){var r=color[0];if(r!=(r|0)){r=r+0.5|0;}var g=color[1];if(g!=(g|0)){g=g+0.5|0;}var b=color[2];if(b!=(b|0)){b=b+0.5|0;}var a=color[3]===undefined?1:color[3];return'rgba('+r+','+g+','+b+','+a+')';};var _ol_colorlike_={};/**
 * @param {ol.Color|ol.ColorLike} color Color.
 * @return {ol.ColorLike} The color as an ol.ColorLike
 * @api
 */_ol_colorlike_.asColorLike=function(color){if(_ol_colorlike_.isColorLike(color)){return(/** @type {string|CanvasPattern|CanvasGradient} */color);}else{return _ol_color_.asString(/** @type {ol.Color} */color);}};/**
 * @param {?} color The value that is potentially an ol.ColorLike
 * @return {boolean} Whether the color is an ol.ColorLike
 */_ol_colorlike_.isColorLike=function(color){return typeof color==='string'||color instanceof CanvasPattern||color instanceof CanvasGradient;};var _ol_dom_={};/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */_ol_dom_.createCanvasContext2D=function(opt_width,opt_height){var canvas=document.createElement('CANVAS');if(opt_width){canvas.width=opt_width;}if(opt_height){canvas.height=opt_height;}return canvas.getContext('2d');};/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */_ol_dom_.outerWidth=function(element){var width=element.offsetWidth;var style=getComputedStyle(element);width+=parseInt(style.marginLeft,10)+parseInt(style.marginRight,10);return width;};/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */_ol_dom_.outerHeight=function(element){var height=element.offsetHeight;var style=getComputedStyle(element);height+=parseInt(style.marginTop,10)+parseInt(style.marginBottom,10);return height;};/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */_ol_dom_.replaceNode=function(newNode,oldNode){var parent=oldNode.parentNode;if(parent){parent.replaceChild(newNode,oldNode);}};/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */_ol_dom_.removeNode=function(node){return node&&node.parentNode?node.parentNode.removeChild(node):null;};/**
 * @param {Node} node The node to remove the children from.
 */_ol_dom_.removeChildren=function(node){while(node.lastChild){node.removeChild(node.lastChild);}};var _ol_has_={};var ua=typeof navigator!=='undefined'?navigator.userAgent.toLowerCase():'';/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */_ol_has_.FIREFOX=ua.indexOf('firefox')!==-1;/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */_ol_has_.SAFARI=ua.indexOf('safari')!==-1&&ua.indexOf('chrom')==-1;/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */_ol_has_.WEBKIT=ua.indexOf('webkit')!==-1&&ua.indexOf('edge')==-1;/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */_ol_has_.MAC=ua.indexOf('macintosh')!==-1;/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */_ol_has_.DEVICE_PIXEL_RATIO=window.devicePixelRatio||1;/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */_ol_has_.CANVAS_LINE_DASH=false;/**
 * True if both the library and browser support Canvas.  Always `false`
 * if `ol.ENABLE_CANVAS` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */_ol_has_.CANVAS=_ol_.ENABLE_CANVAS&&/**
   * @return {boolean} Canvas supported.
   */function(){if(!('HTMLCanvasElement'in window)){return false;}try{var context=document.createElement('CANVAS').getContext('2d');if(!context){return false;}else{if(context.setLineDash!==undefined){_ol_has_.CANVAS_LINE_DASH=true;}return true;}}catch(e){return false;}}();/**
 * Indicates if DeviceOrientation is supported in the user's browser.
 * @const
 * @type {boolean}
 * @api
 */_ol_has_.DEVICE_ORIENTATION='DeviceOrientationEvent'in window;/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */_ol_has_.GEOLOCATION='geolocation'in navigator;/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */_ol_has_.TOUCH=_ol_.ASSUME_TOUCH||'ontouchstart'in window;/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */_ol_has_.POINTER='PointerEvent'in window;/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */_ol_has_.MSPOINTER=!!navigator.msPointerEnabled;/**
 * @enum {number}
 */var _ol_ImageState_={IDLE:0,LOADING:1,LOADED:2,ERROR:3};var _ol_render_canvas_={};/**
 * @const
 * @type {string}
 */_ol_render_canvas_.defaultFont='10px sans-serif';/**
 * @const
 * @type {ol.Color}
 */_ol_render_canvas_.defaultFillStyle=[0,0,0,1];/**
 * @const
 * @type {string}
 */_ol_render_canvas_.defaultLineCap='round';/**
 * @const
 * @type {Array.<number>}
 */_ol_render_canvas_.defaultLineDash=[];/**
 * @const
 * @type {number}
 */_ol_render_canvas_.defaultLineDashOffset=0;/**
 * @const
 * @type {string}
 */_ol_render_canvas_.defaultLineJoin='round';/**
 * @const
 * @type {number}
 */_ol_render_canvas_.defaultMiterLimit=10;/**
 * @const
 * @type {ol.Color}
 */_ol_render_canvas_.defaultStrokeStyle=[0,0,0,1];/**
 * @const
 * @type {string}
 */_ol_render_canvas_.defaultTextAlign='center';/**
 * @const
 * @type {string}
 */_ol_render_canvas_.defaultTextBaseline='middle';/**
 * @const
 * @type {number}
 */_ol_render_canvas_.defaultLineWidth=1;/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */_ol_render_canvas_.rotateAtOffset=function(context,rotation,offsetX,offsetY){if(rotation!==0){context.translate(offsetX,offsetY);context.rotate(rotation);context.translate(-offsetX,-offsetY);}};/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and
 * {@link ol.style.RegularShape}.
 *
 * @constructor
 * @abstract
 * @param {ol.StyleImageOptions} options Options.
 * @api
 */var _ol_style_Image_=function(options){/**
   * @private
   * @type {number}
   */this.opacity_=options.opacity;/**
   * @private
   * @type {boolean}
   */this.rotateWithView_=options.rotateWithView;/**
   * @private
   * @type {number}
   */this.rotation_=options.rotation;/**
   * @private
   * @type {number}
   */this.scale_=options.scale;/**
   * @private
   * @type {boolean}
   */this.snapToPixel_=options.snapToPixel;};/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */_ol_style_Image_.prototype.getOpacity=function(){return this.opacity_;};/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */_ol_style_Image_.prototype.getRotateWithView=function(){return this.rotateWithView_;};/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */_ol_style_Image_.prototype.getRotation=function(){return this.rotation_;};/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */_ol_style_Image_.prototype.getScale=function(){return this.scale_;};/**
 * Determine whether the symbolizer should be snapped to a pixel.
 * @return {boolean} The symbolizer should snap to a pixel.
 * @api
 */_ol_style_Image_.prototype.getSnapToPixel=function(){return this.snapToPixel_;};/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array.<number>} Anchor.
 */_ol_style_Image_.prototype.getAnchor=function(){};/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */_ol_style_Image_.prototype.getImage=function(pixelRatio){};/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */_ol_style_Image_.prototype.getHitDetectionImage=function(pixelRatio){};/**
 * @abstract
 * @return {ol.ImageState} Image state.
 */_ol_style_Image_.prototype.getImageState=function(){};/**
 * @abstract
 * @return {ol.Size} Image size.
 */_ol_style_Image_.prototype.getImageSize=function(){};/**
 * @abstract
 * @return {ol.Size} Size of the hit-detection image.
 */_ol_style_Image_.prototype.getHitDetectionImageSize=function(){};/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array.<number>} Origin.
 */_ol_style_Image_.prototype.getOrigin=function(){};/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {ol.Size} Size.
 */_ol_style_Image_.prototype.getSize=function(){};/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */_ol_style_Image_.prototype.setOpacity=function(opacity){this.opacity_=opacity;};/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 */_ol_style_Image_.prototype.setRotateWithView=function(rotateWithView){this.rotateWithView_=rotateWithView;};/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */_ol_style_Image_.prototype.setRotation=function(rotation){this.rotation_=rotation;};/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */_ol_style_Image_.prototype.setScale=function(scale){this.scale_=scale;};/**
 * Set whether to snap the image to the closest pixel.
 *
 * @param {boolean} snapToPixel Snap to pixel?
 */_ol_style_Image_.prototype.setSnapToPixel=function(snapToPixel){this.snapToPixel_=snapToPixel;};/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {ol.EventsKey|undefined} Listener key.
 * @template T
 */_ol_style_Image_.prototype.listenImageChange=function(listener,thisArg){};/**
 * Load not yet loaded URI.
 * @abstract
 */_ol_style_Image_.prototype.load=function(){};/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */_ol_style_Image_.prototype.unlistenImageChange=function(listener,thisArg){};/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 *
 * @constructor
 * @param {olx.style.RegularShapeOptions} options Options.
 * @extends {ol.style.Image}
 * @api
 */var _ol_style_RegularShape_=function(options){/**
   * @private
   * @type {Array.<string>}
   */this.checksums_=null;/**
   * @private
   * @type {HTMLCanvasElement}
   */this.canvas_=null;/**
   * @private
   * @type {HTMLCanvasElement}
   */this.hitDetectionCanvas_=null;/**
   * @private
   * @type {ol.style.Fill}
   */this.fill_=options.fill!==undefined?options.fill:null;/**
   * @private
   * @type {Array.<number>}
   */this.origin_=[0,0];/**
   * @private
   * @type {number}
   */this.points_=options.points;/**
   * @protected
   * @type {number}
   */this.radius_=/** @type {number} */options.radius!==undefined?options.radius:options.radius1;/**
   * @private
   * @type {number|undefined}
   */this.radius2_=options.radius2;/**
   * @private
   * @type {number}
   */this.angle_=options.angle!==undefined?options.angle:0;/**
   * @private
   * @type {ol.style.Stroke}
   */this.stroke_=options.stroke!==undefined?options.stroke:null;/**
   * @private
   * @type {Array.<number>}
   */this.anchor_=null;/**
   * @private
   * @type {ol.Size}
   */this.size_=null;/**
   * @private
   * @type {ol.Size}
   */this.imageSize_=null;/**
   * @private
   * @type {ol.Size}
   */this.hitDetectionImageSize_=null;/**
   * @protected
   * @type {ol.style.AtlasManager|undefined}
   */this.atlasManager_=options.atlasManager;this.render_(this.atlasManager_);/**
   * @type {boolean}
   */var snapToPixel=options.snapToPixel!==undefined?options.snapToPixel:true;/**
   * @type {boolean}
   */var rotateWithView=options.rotateWithView!==undefined?options.rotateWithView:false;_ol_style_Image_.call(this,{opacity:1,rotateWithView:rotateWithView,rotation:options.rotation!==undefined?options.rotation:0,scale:1,snapToPixel:snapToPixel});};_ol_.inherits(_ol_style_RegularShape_,_ol_style_Image_);/**
 * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.RegularShape} The cloned style.
 * @api
 */_ol_style_RegularShape_.prototype.clone=function(){var style=new _ol_style_RegularShape_({fill:this.getFill()?this.getFill().clone():undefined,points:this.getPoints(),radius:this.getRadius(),radius2:this.getRadius2(),angle:this.getAngle(),snapToPixel:this.getSnapToPixel(),stroke:this.getStroke()?this.getStroke().clone():undefined,rotation:this.getRotation(),rotateWithView:this.getRotateWithView(),atlasManager:this.atlasManager_});style.setOpacity(this.getOpacity());style.setScale(this.getScale());return style;};/**
 * @inheritDoc
 * @api
 */_ol_style_RegularShape_.prototype.getAnchor=function(){return this.anchor_;};/**
 * Get the angle used in generating the shape.
 * @return {number} Shape's rotation in radians.
 * @api
 */_ol_style_RegularShape_.prototype.getAngle=function(){return this.angle_;};/**
 * Get the fill style for the shape.
 * @return {ol.style.Fill} Fill style.
 * @api
 */_ol_style_RegularShape_.prototype.getFill=function(){return this.fill_;};/**
 * @inheritDoc
 */_ol_style_RegularShape_.prototype.getHitDetectionImage=function(pixelRatio){return this.hitDetectionCanvas_;};/**
 * @inheritDoc
 * @api
 */_ol_style_RegularShape_.prototype.getImage=function(pixelRatio){return this.canvas_;};/**
 * @inheritDoc
 */_ol_style_RegularShape_.prototype.getImageSize=function(){return this.imageSize_;};/**
 * @inheritDoc
 */_ol_style_RegularShape_.prototype.getHitDetectionImageSize=function(){return this.hitDetectionImageSize_;};/**
 * @inheritDoc
 */_ol_style_RegularShape_.prototype.getImageState=function(){return _ol_ImageState_.LOADED;};/**
 * @inheritDoc
 * @api
 */_ol_style_RegularShape_.prototype.getOrigin=function(){return this.origin_;};/**
 * Get the number of points for generating the shape.
 * @return {number} Number of points for stars and regular polygons.
 * @api
 */_ol_style_RegularShape_.prototype.getPoints=function(){return this.points_;};/**
 * Get the (primary) radius for the shape.
 * @return {number} Radius.
 * @api
 */_ol_style_RegularShape_.prototype.getRadius=function(){return this.radius_;};/**
 * Get the secondary radius for the shape.
 * @return {number|undefined} Radius2.
 * @api
 */_ol_style_RegularShape_.prototype.getRadius2=function(){return this.radius2_;};/**
 * @inheritDoc
 * @api
 */_ol_style_RegularShape_.prototype.getSize=function(){return this.size_;};/**
 * Get the stroke style for the shape.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */_ol_style_RegularShape_.prototype.getStroke=function(){return this.stroke_;};/**
 * @inheritDoc
 */_ol_style_RegularShape_.prototype.listenImageChange=function(listener,thisArg){};/**
 * @inheritDoc
 */_ol_style_RegularShape_.prototype.load=function(){};/**
 * @inheritDoc
 */_ol_style_RegularShape_.prototype.unlistenImageChange=function(listener,thisArg){};/**
 * @protected
 * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.
 */_ol_style_RegularShape_.prototype.render_=function(atlasManager){var imageSize;var lineCap='';var lineJoin='';var miterLimit=0;var lineDash=null;var lineDashOffset=0;var strokeStyle;var strokeWidth=0;if(this.stroke_){strokeStyle=this.stroke_.getColor();if(strokeStyle===null){strokeStyle=_ol_render_canvas_.defaultStrokeStyle;}strokeStyle=_ol_colorlike_.asColorLike(strokeStyle);strokeWidth=this.stroke_.getWidth();if(strokeWidth===undefined){strokeWidth=_ol_render_canvas_.defaultLineWidth;}lineDash=this.stroke_.getLineDash();lineDashOffset=this.stroke_.getLineDashOffset();if(!_ol_has_.CANVAS_LINE_DASH){lineDash=null;lineDashOffset=0;}lineJoin=this.stroke_.getLineJoin();if(lineJoin===undefined){lineJoin=_ol_render_canvas_.defaultLineJoin;}lineCap=this.stroke_.getLineCap();if(lineCap===undefined){lineCap=_ol_render_canvas_.defaultLineCap;}miterLimit=this.stroke_.getMiterLimit();if(miterLimit===undefined){miterLimit=_ol_render_canvas_.defaultMiterLimit;}}var size=2*(this.radius_+strokeWidth)+1;/** @type {ol.RegularShapeRenderOptions} */var renderOptions={strokeStyle:strokeStyle,strokeWidth:strokeWidth,size:size,lineCap:lineCap,lineDash:lineDash,lineDashOffset:lineDashOffset,lineJoin:lineJoin,miterLimit:miterLimit};if(atlasManager===undefined){// no atlas manager is used, create a new canvas
var context=_ol_dom_.createCanvasContext2D(size,size);this.canvas_=context.canvas;// canvas.width and height are rounded to the closest integer
size=this.canvas_.width;imageSize=size;this.draw_(renderOptions,context,0,0);this.createHitDetectionCanvas_(renderOptions);}else{// an atlas manager is used, add the symbol to an atlas
size=Math.round(size);var hasCustomHitDetectionImage=!this.fill_;var renderHitDetectionCallback;if(hasCustomHitDetectionImage){// render the hit-detection image into a separate atlas image
renderHitDetectionCallback=this.drawHitDetectionCanvas_.bind(this,renderOptions);}var id=this.getChecksum();var info=atlasManager.add(id,size,size,this.draw_.bind(this,renderOptions),renderHitDetectionCallback);this.canvas_=info.image;this.origin_=[info.offsetX,info.offsetY];imageSize=info.image.width;if(hasCustomHitDetectionImage){this.hitDetectionCanvas_=info.hitImage;this.hitDetectionImageSize_=[info.hitImage.width,info.hitImage.height];}else{this.hitDetectionCanvas_=this.canvas_;this.hitDetectionImageSize_=[imageSize,imageSize];}}this.anchor_=[size/2,size/2];this.size_=[size,size];this.imageSize_=[imageSize,imageSize];};/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */_ol_style_RegularShape_.prototype.draw_=function(renderOptions,context,x,y){var i,angle0,radiusC;// reset transform
context.setTransform(1,0,0,1,0,0);// then move to (x, y)
context.translate(x,y);context.beginPath();var points=this.points_;if(points===Infinity){context.arc(renderOptions.size/2,renderOptions.size/2,this.radius_,0,2*Math.PI,true);}else{var radius2=this.radius2_!==undefined?this.radius2_:this.radius_;if(radius2!==this.radius_){points=2*points;}for(i=0;i<=points;i++){angle0=i*2*Math.PI/points-Math.PI/2+this.angle_;radiusC=i%2===0?this.radius_:radius2;context.lineTo(renderOptions.size/2+radiusC*Math.cos(angle0),renderOptions.size/2+radiusC*Math.sin(angle0));}}if(this.fill_){var color=this.fill_.getColor();if(color===null){color=_ol_render_canvas_.defaultFillStyle;}context.fillStyle=_ol_colorlike_.asColorLike(color);context.fill();}if(this.stroke_){context.strokeStyle=renderOptions.strokeStyle;context.lineWidth=renderOptions.strokeWidth;if(renderOptions.lineDash){context.setLineDash(renderOptions.lineDash);context.lineDashOffset=renderOptions.lineDashOffset;}context.lineCap=renderOptions.lineCap;context.lineJoin=renderOptions.lineJoin;context.miterLimit=renderOptions.miterLimit;context.stroke();}context.closePath();};/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 */_ol_style_RegularShape_.prototype.createHitDetectionCanvas_=function(renderOptions){this.hitDetectionImageSize_=[renderOptions.size,renderOptions.size];if(this.fill_){this.hitDetectionCanvas_=this.canvas_;return;}// if no fill style is set, create an extra hit-detection image with a
// default fill style
var context=_ol_dom_.createCanvasContext2D(renderOptions.size,renderOptions.size);this.hitDetectionCanvas_=context.canvas;this.drawHitDetectionCanvas_(renderOptions,context,0,0);};/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */_ol_style_RegularShape_.prototype.drawHitDetectionCanvas_=function(renderOptions,context,x,y){// reset transform
context.setTransform(1,0,0,1,0,0);// then move to (x, y)
context.translate(x,y);context.beginPath();var points=this.points_;if(points===Infinity){context.arc(renderOptions.size/2,renderOptions.size/2,this.radius_,0,2*Math.PI,true);}else{var radius2=this.radius2_!==undefined?this.radius2_:this.radius_;if(radius2!==this.radius_){points=2*points;}var i,radiusC,angle0;for(i=0;i<=points;i++){angle0=i*2*Math.PI/points-Math.PI/2+this.angle_;radiusC=i%2===0?this.radius_:radius2;context.lineTo(renderOptions.size/2+radiusC*Math.cos(angle0),renderOptions.size/2+radiusC*Math.sin(angle0));}}context.fillStyle=_ol_render_canvas_.defaultFillStyle;context.fill();if(this.stroke_){context.strokeStyle=renderOptions.strokeStyle;context.lineWidth=renderOptions.strokeWidth;if(renderOptions.lineDash){context.setLineDash(renderOptions.lineDash);context.lineDashOffset=renderOptions.lineDashOffset;}context.stroke();}context.closePath();};/**
 * @return {string} The checksum.
 */_ol_style_RegularShape_.prototype.getChecksum=function(){var strokeChecksum=this.stroke_?this.stroke_.getChecksum():'-';var fillChecksum=this.fill_?this.fill_.getChecksum():'-';var recalculate=!this.checksums_||strokeChecksum!=this.checksums_[1]||fillChecksum!=this.checksums_[2]||this.radius_!=this.checksums_[3]||this.radius2_!=this.checksums_[4]||this.angle_!=this.checksums_[5]||this.points_!=this.checksums_[6];if(recalculate){var checksum='r'+strokeChecksum+fillChecksum+(this.radius_!==undefined?this.radius_.toString():'-')+(this.radius2_!==undefined?this.radius2_.toString():'-')+(this.angle_!==undefined?this.angle_.toString():'-')+(this.points_!==undefined?this.points_.toString():'-');this.checksums_=[checksum,strokeChecksum,fillChecksum,this.radius_,this.radius2_,this.angle_,this.points_];}return this.checksums_[0];};/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @param {olx.style.CircleOptions=} opt_options Options.
 * @extends {ol.style.RegularShape}
 * @api
 */var _ol_style_Circle_=function(opt_options){var options=opt_options||{};_ol_style_RegularShape_.call(this,{points:Infinity,fill:options.fill,radius:options.radius,snapToPixel:options.snapToPixel,stroke:options.stroke,atlasManager:options.atlasManager});};_ol_.inherits(_ol_style_Circle_,_ol_style_RegularShape_);/**
 * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.Circle} The cloned style.
 * @override
 * @api
 */_ol_style_Circle_.prototype.clone=function(){var style=new _ol_style_Circle_({fill:this.getFill()?this.getFill().clone():undefined,stroke:this.getStroke()?this.getStroke().clone():undefined,radius:this.getRadius(),snapToPixel:this.getSnapToPixel(),atlasManager:this.atlasManager_});style.setOpacity(this.getOpacity());style.setScale(this.getScale());return style;};/**
 * Set the circle radius.
 *
 * @param {number} radius Circle radius.
 * @api
 */_ol_style_Circle_.prototype.setRadius=function(radius){this.radius_=radius;this.render_(this.atlasManager_);};/**
 * @classdesc
 * Set fill style for vector features.
 *
 * @constructor
 * @param {olx.style.FillOptions=} opt_options Options.
 * @api
 */var _ol_style_Fill_=function(opt_options){var options=opt_options||{};/**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */this.color_=options.color!==undefined?options.color:null;/**
   * @private
   * @type {string|undefined}
   */this.checksum_=undefined;};/**
 * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.
 * @return {ol.style.Fill} The cloned style.
 * @api
 */_ol_style_Fill_.prototype.clone=function(){var color=this.getColor();return new _ol_style_Fill_({color:color&&color.slice?color.slice():color||undefined});};/**
 * Get the fill color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */_ol_style_Fill_.prototype.getColor=function(){return this.color_;};/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */_ol_style_Fill_.prototype.setColor=function(color){this.color_=color;this.checksum_=undefined;};/**
 * @return {string} The checksum.
 */_ol_style_Fill_.prototype.getChecksum=function(){if(this.checksum_===undefined){if(this.color_ instanceof CanvasPattern||this.color_ instanceof CanvasGradient){this.checksum_=_ol_.getUid(this.color_).toString();}else{this.checksum_='f'+(this.color_?_ol_color_.asString(this.color_):'-');}}return this.checksum_;};/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 *
 * @constructor
 * @param {olx.style.StrokeOptions=} opt_options Options.
 * @api
 */var _ol_style_Stroke_=function(opt_options){var options=opt_options||{};/**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */this.color_=options.color!==undefined?options.color:null;/**
   * @private
   * @type {string|undefined}
   */this.lineCap_=options.lineCap;/**
   * @private
   * @type {Array.<number>}
   */this.lineDash_=options.lineDash!==undefined?options.lineDash:null;/**
   * @private
   * @type {number|undefined}
   */this.lineDashOffset_=options.lineDashOffset;/**
   * @private
   * @type {string|undefined}
   */this.lineJoin_=options.lineJoin;/**
   * @private
   * @type {number|undefined}
   */this.miterLimit_=options.miterLimit;/**
   * @private
   * @type {number|undefined}
   */this.width_=options.width;/**
   * @private
   * @type {string|undefined}
   */this.checksum_=undefined;};/**
 * Clones the style.
 * @return {ol.style.Stroke} The cloned style.
 * @api
 */_ol_style_Stroke_.prototype.clone=function(){var color=this.getColor();return new _ol_style_Stroke_({color:color&&color.slice?color.slice():color||undefined,lineCap:this.getLineCap(),lineDash:this.getLineDash()?this.getLineDash().slice():undefined,lineDashOffset:this.getLineDashOffset(),lineJoin:this.getLineJoin(),miterLimit:this.getMiterLimit(),width:this.getWidth()});};/**
 * Get the stroke color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */_ol_style_Stroke_.prototype.getColor=function(){return this.color_;};/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */_ol_style_Stroke_.prototype.getLineCap=function(){return this.lineCap_;};/**
 * Get the line dash style for the stroke.
 * @return {Array.<number>} Line dash.
 * @api
 */_ol_style_Stroke_.prototype.getLineDash=function(){return this.lineDash_;};/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */_ol_style_Stroke_.prototype.getLineDashOffset=function(){return this.lineDashOffset_;};/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */_ol_style_Stroke_.prototype.getLineJoin=function(){return this.lineJoin_;};/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */_ol_style_Stroke_.prototype.getMiterLimit=function(){return this.miterLimit_;};/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */_ol_style_Stroke_.prototype.getWidth=function(){return this.width_;};/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */_ol_style_Stroke_.prototype.setColor=function(color){this.color_=color;this.checksum_=undefined;};/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */_ol_style_Stroke_.prototype.setLineCap=function(lineCap){this.lineCap_=lineCap;this.checksum_=undefined;};/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array.<number>} lineDash Line dash.
 * @api
 */_ol_style_Stroke_.prototype.setLineDash=function(lineDash){this.lineDash_=lineDash;this.checksum_=undefined;};/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */_ol_style_Stroke_.prototype.setLineDashOffset=function(lineDashOffset){this.lineDashOffset_=lineDashOffset;this.checksum_=undefined;};/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */_ol_style_Stroke_.prototype.setLineJoin=function(lineJoin){this.lineJoin_=lineJoin;this.checksum_=undefined;};/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */_ol_style_Stroke_.prototype.setMiterLimit=function(miterLimit){this.miterLimit_=miterLimit;this.checksum_=undefined;};/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */_ol_style_Stroke_.prototype.setWidth=function(width){this.width_=width;this.checksum_=undefined;};/**
 * @return {string} The checksum.
 */_ol_style_Stroke_.prototype.getChecksum=function(){if(this.checksum_===undefined){this.checksum_='s';if(this.color_){if(typeof this.color_==='string'){this.checksum_+=this.color_;}else{this.checksum_+=_ol_.getUid(this.color_).toString();}}else{this.checksum_+='-';}this.checksum_+=','+(this.lineCap_!==undefined?this.lineCap_.toString():'-')+','+(this.lineDash_?this.lineDash_.toString():'-')+','+(this.lineDashOffset_!==undefined?this.lineDashOffset_:'-')+','+(this.lineJoin_!==undefined?this.lineJoin_:'-')+','+(this.miterLimit_!==undefined?this.miterLimit_.toString():'-')+','+(this.width_!==undefined?this.width_.toString():'-');}return this.checksum_;};/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * @constructor
 * @struct
 * @param {olx.style.StyleOptions=} opt_options Style options.
 * @api
 */var _ol_style_Style_$1=function(opt_options){var options=opt_options||{};/**
   * @private
   * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}
   */this.geometry_=null;/**
   * @private
   * @type {!ol.StyleGeometryFunction}
   */this.geometryFunction_=_ol_style_Style_$1.defaultGeometryFunction;if(options.geometry!==undefined){this.setGeometry(options.geometry);}/**
   * @private
   * @type {ol.style.Fill}
   */this.fill_=options.fill!==undefined?options.fill:null;/**
   * @private
   * @type {ol.style.Image}
   */this.image_=options.image!==undefined?options.image:null;/**
   * @private
   * @type {ol.StyleRenderFunction|null}
   */this.renderer_=options.renderer!==undefined?options.renderer:null;/**
   * @private
   * @type {ol.style.Stroke}
   */this.stroke_=options.stroke!==undefined?options.stroke:null;/**
   * @private
   * @type {ol.style.Text}
   */this.text_=options.text!==undefined?options.text:null;/**
   * @private
   * @type {number|undefined}
   */this.zIndex_=options.zIndex;};/**
 * Clones the style.
 * @return {ol.style.Style} The cloned style.
 * @api
 */_ol_style_Style_$1.prototype.clone=function(){var geometry=this.getGeometry();if(geometry&&geometry.clone){geometry=geometry.clone();}return new _ol_style_Style_$1({geometry:geometry,fill:this.getFill()?this.getFill().clone():undefined,image:this.getImage()?this.getImage().clone():undefined,stroke:this.getStroke()?this.getStroke().clone():undefined,text:this.getText()?this.getText().clone():undefined,zIndex:this.getZIndex()});};/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {ol.StyleRenderFunction|null} Custom renderer function.
 * @api
 */_ol_style_Style_$1.prototype.getRenderer=function(){return this.renderer_;};/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {ol.StyleRenderFunction|null} renderer Custom renderer function.
 * @api
 */_ol_style_Style_$1.prototype.setRenderer=function(renderer){this.renderer_=renderer;};/**
 * Get the geometry to be rendered.
 * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */_ol_style_Style_$1.prototype.getGeometry=function(){return this.geometry_;};/**
 * Get the function used to generate a geometry for rendering.
 * @return {!ol.StyleGeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */_ol_style_Style_$1.prototype.getGeometryFunction=function(){return this.geometryFunction_;};/**
 * Get the fill style.
 * @return {ol.style.Fill} Fill style.
 * @api
 */_ol_style_Style_$1.prototype.getFill=function(){return this.fill_;};/**
 * Set the fill style.
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */_ol_style_Style_$1.prototype.setFill=function(fill){this.fill_=fill;};/**
 * Get the image style.
 * @return {ol.style.Image} Image style.
 * @api
 */_ol_style_Style_$1.prototype.getImage=function(){return this.image_;};/**
 * Set the image style.
 * @param {ol.style.Image} image Image style.
 * @api
 */_ol_style_Style_$1.prototype.setImage=function(image){this.image_=image;};/**
 * Get the stroke style.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */_ol_style_Style_$1.prototype.getStroke=function(){return this.stroke_;};/**
 * Set the stroke style.
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */_ol_style_Style_$1.prototype.setStroke=function(stroke){this.stroke_=stroke;};/**
 * Get the text style.
 * @return {ol.style.Text} Text style.
 * @api
 */_ol_style_Style_$1.prototype.getText=function(){return this.text_;};/**
 * Set the text style.
 * @param {ol.style.Text} text Text style.
 * @api
 */_ol_style_Style_$1.prototype.setText=function(text){this.text_=text;};/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */_ol_style_Style_$1.prototype.getZIndex=function(){return this.zIndex_;};/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry
 *     Feature property or geometry or function returning a geometry to render
 *     for this style.
 * @api
 */_ol_style_Style_$1.prototype.setGeometry=function(geometry){if(typeof geometry==='function'){this.geometryFunction_=geometry;}else if(typeof geometry==='string'){this.geometryFunction_=function(feature){return(/** @type {ol.geom.Geometry} */feature.get(geometry));};}else if(!geometry){this.geometryFunction_=_ol_style_Style_$1.defaultGeometryFunction;}else if(geometry!==undefined){this.geometryFunction_=function(){return(/** @type {ol.geom.Geometry} */geometry);};}this.geometry_=geometry;};/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */_ol_style_Style_$1.prototype.setZIndex=function(zIndex){this.zIndex_=zIndex;};/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a
 * new style function.
 * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {ol.StyleFunction} A style function.
 */_ol_style_Style_$1.createFunction=function(obj){var styleFunction;if(typeof obj==='function'){styleFunction=obj;}else{/**
     * @type {Array.<ol.style.Style>}
     */var styles;if(Array.isArray(obj)){styles=obj;}else{_ol_asserts_.assert(obj instanceof _ol_style_Style_$1,41);// Expected an `ol.style.Style` or an array of `ol.style.Style`
styles=[obj];}styleFunction=function(){return styles;};}return styleFunction;};/**
 * @type {Array.<ol.style.Style>}
 * @private
 */_ol_style_Style_$1.default_=null;/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.style.Style>} Style.
 */_ol_style_Style_$1.defaultFunction=function(feature,resolution){// We don't use an immediately-invoked function
// and a closure so we don't get an error at script evaluation time in
// browsers that do not support Canvas. (ol.style.Circle does
// canvas.getContext('2d') at construction time, which will cause an.error
// in such browsers.)
if(!_ol_style_Style_$1.default_){var fill=new _ol_style_Fill_({color:'rgba(255,255,255,0.4)'});var stroke=new _ol_style_Stroke_({color:'#3399CC',width:1.25});_ol_style_Style_$1.default_=[new _ol_style_Style_$1({image:new _ol_style_Circle_({fill:fill,stroke:stroke,radius:5}),fill:fill,stroke:stroke})];}return _ol_style_Style_$1.default_;};/**
 * Default styles for editing features.
 * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles
 */_ol_style_Style_$1.createDefaultEditing=function(){/** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */var styles={};var white=[255,255,255,1];var blue=[0,153,255,1];var width=3;styles[_ol_geom_GeometryType_.POLYGON]=[new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:[255,255,255,0.5]})})];styles[_ol_geom_GeometryType_.MULTI_POLYGON]=styles[_ol_geom_GeometryType_.POLYGON];styles[_ol_geom_GeometryType_.LINE_STRING]=[new _ol_style_Style_$1({stroke:new _ol_style_Stroke_({color:white,width:width+2})}),new _ol_style_Style_$1({stroke:new _ol_style_Stroke_({color:blue,width:width})})];styles[_ol_geom_GeometryType_.MULTI_LINE_STRING]=styles[_ol_geom_GeometryType_.LINE_STRING];styles[_ol_geom_GeometryType_.CIRCLE]=styles[_ol_geom_GeometryType_.POLYGON].concat(styles[_ol_geom_GeometryType_.LINE_STRING]);styles[_ol_geom_GeometryType_.POINT]=[new _ol_style_Style_$1({image:new _ol_style_Circle_({radius:width*2,fill:new _ol_style_Fill_({color:blue}),stroke:new _ol_style_Stroke_({color:white,width:width/2})}),zIndex:Infinity})];styles[_ol_geom_GeometryType_.MULTI_POINT]=styles[_ol_geom_GeometryType_.POINT];styles[_ol_geom_GeometryType_.GEOMETRY_COLLECTION]=styles[_ol_geom_GeometryType_.POLYGON].concat(styles[_ol_geom_GeometryType_.LINE_STRING],styles[_ol_geom_GeometryType_.POINT]);return styles;};/**
 * Function that is called with a feature and returns its default geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry
 *     for.
 * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.
 */_ol_style_Style_$1.defaultGeometryFunction=function(feature){return feature.getGeometry();};/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link ol.Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 * var feature = new ol.Feature({
 *   geometry: new ol.geom.Polygon(polyCoords),
 *   labelPoint: new ol.geom.Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @constructor
 * @extends {ol.Object}
 * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties
 *     You may pass a Geometry object directly, or an object literal
 *     containing properties.  If you pass an object literal, you may
 *     include a Geometry associated with a `geometry` key.
 * @api
 */var _ol_Feature_=function(opt_geometryOrProperties){_ol_Object_.call(this);/**
   * @private
   * @type {number|string|undefined}
   */this.id_=undefined;/**
   * @type {string}
   * @private
   */this.geometryName_='geometry';/**
   * User provided style.
   * @private
   * @type {ol.style.Style|Array.<ol.style.Style>|
   *     ol.FeatureStyleFunction}
   */this.style_=null;/**
   * @private
   * @type {ol.FeatureStyleFunction|undefined}
   */this.styleFunction_=undefined;/**
   * @private
   * @type {?ol.EventsKey}
   */this.geometryChangeKey_=null;_ol_events_.listen(this,_ol_Object_.getChangeEventType(this.geometryName_),this.handleGeometryChanged_,this);if(opt_geometryOrProperties!==undefined){if(opt_geometryOrProperties instanceof _ol_geom_Geometry_||!opt_geometryOrProperties){var geometry=opt_geometryOrProperties;this.setGeometry(geometry);}else{/** @type {Object.<string, *>} */var properties=opt_geometryOrProperties;this.setProperties(properties);}}};_ol_.inherits(_ol_Feature_,_ol_Object_);/**
 * Clone this feature. If the original feature has a geometry it
 * is also cloned. The feature id is not set in the clone.
 * @return {ol.Feature} The clone.
 * @api
 */_ol_Feature_.prototype.clone=function(){var clone=new _ol_Feature_(this.getProperties());clone.setGeometryName(this.getGeometryName());var geometry=this.getGeometry();if(geometry){clone.setGeometry(geometry.clone());}var style=this.getStyle();if(style){clone.setStyle(style);}return clone;};/**
 * Get the feature's default geometry.  A feature may have any number of named
 * geometries.  The "default" geometry (the one that is rendered by default) is
 * set when calling {@link ol.Feature#setGeometry}.
 * @return {ol.geom.Geometry|undefined} The default geometry for the feature.
 * @api
 * @observable
 */_ol_Feature_.prototype.getGeometry=function(){return(/** @type {ol.geom.Geometry|undefined} */this.get(this.geometryName_));};/**
 * Get the feature identifier.  This is a stable identifier for the feature and
 * is either set when reading data from a remote source or set explicitly by
 * calling {@link ol.Feature#setId}.
 * @return {number|string|undefined} Id.
 * @api
 */_ol_Feature_.prototype.getId=function(){return this.id_;};/**
 * Get the name of the feature's default geometry.  By default, the default
 * geometry is named `geometry`.
 * @return {string} Get the property name associated with the default geometry
 *     for this feature.
 * @api
 */_ol_Feature_.prototype.getGeometryName=function(){return this.geometryName_;};/**
 * Get the feature's style. Will return what was provided to the
 * {@link ol.Feature#setStyle} method.
 * @return {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.
 * @api
 */_ol_Feature_.prototype.getStyle=function(){return this.style_;};/**
 * Get the feature's style function.
 * @return {ol.FeatureStyleFunction|undefined} Return a function
 * representing the current style of this feature.
 * @api
 */_ol_Feature_.prototype.getStyleFunction=function(){return this.styleFunction_;};/**
 * @private
 */_ol_Feature_.prototype.handleGeometryChange_=function(){this.changed();};/**
 * @private
 */_ol_Feature_.prototype.handleGeometryChanged_=function(){if(this.geometryChangeKey_){_ol_events_.unlistenByKey(this.geometryChangeKey_);this.geometryChangeKey_=null;}var geometry=this.getGeometry();if(geometry){this.geometryChangeKey_=_ol_events_.listen(geometry,_ol_events_EventType_.CHANGE,this.handleGeometryChange_,this);}this.changed();};/**
 * Set the default geometry for the feature.  This will update the property
 * with the name returned by {@link ol.Feature#getGeometryName}.
 * @param {ol.geom.Geometry|undefined} geometry The new geometry.
 * @api
 * @observable
 */_ol_Feature_.prototype.setGeometry=function(geometry){this.set(this.geometryName_,geometry);};/**
 * Set the style for the feature.  This can be a single style object, an array
 * of styles, or a function that takes a resolution and returns an array of
 * styles. If it is `null` the feature has no style (a `null` style).
 * @param {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.
 * @api
 * @fires ol.events.Event#event:change
 */_ol_Feature_.prototype.setStyle=function(style){this.style_=style;this.styleFunction_=!style?undefined:_ol_Feature_.createStyleFunction(style);this.changed();};/**
 * Set the feature id.  The feature id is considered stable and may be used when
 * requesting features or comparing identifiers returned from a remote source.
 * The feature id can be used with the {@link ol.source.Vector#getFeatureById}
 * method.
 * @param {number|string|undefined} id The feature id.
 * @api
 * @fires ol.events.Event#event:change
 */_ol_Feature_.prototype.setId=function(id){this.id_=id;this.changed();};/**
 * Set the property name to be used when getting the feature's default geometry.
 * When calling {@link ol.Feature#getGeometry}, the value of the property with
 * this name will be returned.
 * @param {string} name The property name of the default geometry.
 * @api
 */_ol_Feature_.prototype.setGeometryName=function(name){_ol_events_.unlisten(this,_ol_Object_.getChangeEventType(this.geometryName_),this.handleGeometryChanged_,this);this.geometryName_=name;_ol_events_.listen(this,_ol_Object_.getChangeEventType(this.geometryName_),this.handleGeometryChanged_,this);this.handleGeometryChanged_();};/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of ol.style.Style or single style objects wrapped
 * in a new feature style function.
 * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {ol.FeatureStyleFunction} A style function.
 */_ol_Feature_.createStyleFunction=function(obj){var styleFunction;if(typeof obj==='function'){if(obj.length==2){styleFunction=function(resolution){return(/** @type {ol.StyleFunction} */obj(this,resolution));};}else{styleFunction=obj;}}else{/**
     * @type {Array.<ol.style.Style>}
     */var styles;if(Array.isArray(obj)){styles=obj;}else{_ol_asserts_.assert(obj instanceof _ol_style_Style_$1,41);// Expected an `ol.style.Style` or an array of `ol.style.Style`
styles=[obj];}styleFunction=function(){return styles;};}return styleFunction;};function capitalize(string){return string.charAt(0).toUpperCase()+string.slice(1);}var unitNames={npc_dota_roshan_spawner:"Roshan",dota_item_rune_spawner_powerup:"Rune",dota_item_rune_spawner_bounty:"Bounty Rune",ent_dota_tree:"Tree",npc_dota_healer:"Shrine",ent_dota_fountain:"Fountain",npc_dota_fort:"Ancient",ent_dota_shop:"Shop",npc_dota_tower:"Tower",npc_dota_barracks:"Barracks",npc_dota_filler:"Building",trigger_multiple:"Neutral Camp Spawn Box",npc_dota_neutral_spawner:"Neutral Camp",observer:"Observer Ward",sentry:"Sentry Ward"};function getUnitName(unitType,unitSubType){return(unitSubType?capitalize(unitSubType.replace('tower','Tier ').replace('range','Ranged'))+' ':'')+unitNames[unitType];}var pullTypes=['Normal','Fast','Slow'];var neutralTypes=['Easy','Medium','Hard','Ancient'];function getPopupContent(data,feature){var dotaProps=feature.get('dotaProps');var unitClass=dotaProps.subType?dotaProps.id+'_'+dotaProps.subType:dotaProps.id;var stats=data.data.stats[unitClass];var htmlContent='<div class="info"><span class="info-header">'+getUnitName(dotaProps.id,dotaProps.subType)+'</span><span class="info-body">';if(dotaProps.pullType!=null){htmlContent+='<br><span class="info-line">Pull Type: '+pullTypes[dotaProps.pullType]+'</span>';}if(dotaProps.neutralType!=null){htmlContent+='<br><span class="info-line">Difficulty: '+neutralTypes[dotaProps.neutralType]+'</span>';}if(stats.hasOwnProperty('damageMin')&&stats.hasOwnProperty('damageMax')){htmlContent+='<br><span class="info-line">Damage: '+stats.damageMin+"&ndash;"+stats.damageMax+'</span>';}if(stats.hasOwnProperty('bat')){htmlContent+='<br><span class="info-line">BAT: '+stats.bat+'</span>';}if(stats.hasOwnProperty('attackRange')){htmlContent+='<br><span class="info-line">Attack Range: '+stats.attackRange+'</span>';}if(stats.hasOwnProperty('health')){htmlContent+='<br><span class="info-line">Health: '+stats.health+'</span>';}if(stats.hasOwnProperty('armor')){htmlContent+='<br><span class="info-line">Armor: '+stats.armor+'</span>';}if(stats.hasOwnProperty('dayVision')&&stats.hasOwnProperty('nightVision')){htmlContent+='<br><span class="info-line">Vision: '+stats.dayVision+"/"+stats.nightVision+'</span>';}htmlContent+='</span></div>';return htmlContent;}/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */var _ol_style_IconAnchorUnits_={FRACTION:'fraction',PIXELS:'pixels'};/**
 * @constructor
 */var _ol_style_IconImageCache_=function(){/**
   * @type {Object.<string, ol.style.IconImage>}
   * @private
   */this.cache_={};/**
   * @type {number}
   * @private
   */this.cacheSize_=0;/**
   * @const
   * @type {number}
   * @private
   */this.maxCacheSize_=32;};/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {string} Cache key.
 */_ol_style_IconImageCache_.getKey=function(src,crossOrigin,color){var colorString=color?_ol_color_.asString(color):'null';return crossOrigin+':'+src+':'+colorString;};/**
 * FIXME empty description for jsdoc
 */_ol_style_IconImageCache_.prototype.clear=function(){this.cache_={};this.cacheSize_=0;};/**
 * FIXME empty description for jsdoc
 */_ol_style_IconImageCache_.prototype.expire=function(){if(this.cacheSize_>this.maxCacheSize_){var i=0;var key,iconImage;for(key in this.cache_){iconImage=this.cache_[key];if((i++&3)===0&&!iconImage.hasListener()){delete this.cache_[key];--this.cacheSize_;}}}};/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */_ol_style_IconImageCache_.prototype.get=function(src,crossOrigin,color){var key=_ol_style_IconImageCache_.getKey(src,crossOrigin,color);return key in this.cache_?this.cache_[key]:null;};/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @param {ol.style.IconImage} iconImage Icon image.
 */_ol_style_IconImageCache_.prototype.set=function(src,crossOrigin,color,iconImage){var key=_ol_style_IconImageCache_.getKey(src,crossOrigin,color);this.cache_[key]=iconImage;++this.cacheSize_;};var _ol_style_={};_ol_style_.iconImageCache=new _ol_style_IconImageCache_();/**
 * @constructor
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string|undefined} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @extends {ol.events.EventTarget}
 */var _ol_style_IconImage_=function(image,src,size,crossOrigin,imageState,color){_ol_events_EventTarget_.call(this);/**
   * @private
   * @type {Image|HTMLCanvasElement}
   */this.hitDetectionImage_=null;/**
   * @private
   * @type {Image|HTMLCanvasElement}
   */this.image_=!image?new Image():image;if(crossOrigin!==null){this.image_.crossOrigin=crossOrigin;}/**
   * @private
   * @type {HTMLCanvasElement}
   */this.canvas_=color?/** @type {HTMLCanvasElement} */document.createElement('CANVAS'):null;/**
   * @private
   * @type {ol.Color}
   */this.color_=color;/**
   * @private
   * @type {Array.<ol.EventsKey>}
   */this.imageListenerKeys_=null;/**
   * @private
   * @type {ol.ImageState}
   */this.imageState_=imageState;/**
   * @private
   * @type {ol.Size}
   */this.size_=size;/**
   * @private
   * @type {string|undefined}
   */this.src_=src;/**
   * @private
   * @type {boolean}
   */this.tainting_=false;if(this.imageState_==_ol_ImageState_.LOADED){this.determineTainting_();}};_ol_.inherits(_ol_style_IconImage_,_ol_events_EventTarget_);/**
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */_ol_style_IconImage_.get=function(image,src,size,crossOrigin,imageState,color){var iconImageCache=_ol_style_.iconImageCache;var iconImage=iconImageCache.get(src,crossOrigin,color);if(!iconImage){iconImage=new _ol_style_IconImage_(image,src,size,crossOrigin,imageState,color);iconImageCache.set(src,crossOrigin,color,iconImage);}return iconImage;};/**
 * @private
 */_ol_style_IconImage_.prototype.determineTainting_=function(){var context=_ol_dom_.createCanvasContext2D(1,1);try{context.drawImage(this.image_,0,0);context.getImageData(0,0,1,1);}catch(e){this.tainting_=true;}};/**
 * @private
 */_ol_style_IconImage_.prototype.dispatchChangeEvent_=function(){this.dispatchEvent(_ol_events_EventType_.CHANGE);};/**
 * @private
 */_ol_style_IconImage_.prototype.handleImageError_=function(){this.imageState_=_ol_ImageState_.ERROR;this.unlistenImage_();this.dispatchChangeEvent_();};/**
 * @private
 */_ol_style_IconImage_.prototype.handleImageLoad_=function(){this.imageState_=_ol_ImageState_.LOADED;if(this.size_){this.image_.width=this.size_[0];this.image_.height=this.size_[1];}this.size_=[this.image_.width,this.image_.height];this.unlistenImage_();this.determineTainting_();this.replaceColor_();this.dispatchChangeEvent_();};/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 */_ol_style_IconImage_.prototype.getImage=function(pixelRatio){return this.canvas_?this.canvas_:this.image_;};/**
 * @return {ol.ImageState} Image state.
 */_ol_style_IconImage_.prototype.getImageState=function(){return this.imageState_;};/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image element.
 */_ol_style_IconImage_.prototype.getHitDetectionImage=function(pixelRatio){if(!this.hitDetectionImage_){if(this.tainting_){var width=this.size_[0];var height=this.size_[1];var context=_ol_dom_.createCanvasContext2D(width,height);context.fillRect(0,0,width,height);this.hitDetectionImage_=context.canvas;}else{this.hitDetectionImage_=this.image_;}}return this.hitDetectionImage_;};/**
 * @return {ol.Size} Image size.
 */_ol_style_IconImage_.prototype.getSize=function(){return this.size_;};/**
 * @return {string|undefined} Image src.
 */_ol_style_IconImage_.prototype.getSrc=function(){return this.src_;};/**
 * Load not yet loaded URI.
 */_ol_style_IconImage_.prototype.load=function(){if(this.imageState_==_ol_ImageState_.IDLE){this.imageState_=_ol_ImageState_.LOADING;this.imageListenerKeys_=[_ol_events_.listenOnce(this.image_,_ol_events_EventType_.ERROR,this.handleImageError_,this),_ol_events_.listenOnce(this.image_,_ol_events_EventType_.LOAD,this.handleImageLoad_,this)];try{this.image_.src=this.src_;}catch(e){this.handleImageError_();}}};/**
 * @private
 */_ol_style_IconImage_.prototype.replaceColor_=function(){if(this.tainting_||this.color_===null){return;}this.canvas_.width=this.image_.width;this.canvas_.height=this.image_.height;var ctx=this.canvas_.getContext('2d');ctx.drawImage(this.image_,0,0);var imgData=ctx.getImageData(0,0,this.image_.width,this.image_.height);var data=imgData.data;var r=this.color_[0]/255.0;var g=this.color_[1]/255.0;var b=this.color_[2]/255.0;for(var i=0,ii=data.length;i<ii;i+=4){data[i]*=r;data[i+1]*=g;data[i+2]*=b;}ctx.putImageData(imgData,0,0);};/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */_ol_style_IconImage_.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(_ol_events_.unlistenByKey);this.imageListenerKeys_=null;};/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */var _ol_style_IconOrigin_={BOTTOM_LEFT:'bottom-left',BOTTOM_RIGHT:'bottom-right',TOP_LEFT:'top-left',TOP_RIGHT:'top-right'};/**
 * @classdesc
 * Set icon style for vector features.
 *
 * @constructor
 * @param {olx.style.IconOptions=} opt_options Options.
 * @extends {ol.style.Image}
 * @api
 */var _ol_style_Icon_=function(opt_options){var options=opt_options||{};/**
   * @private
   * @type {Array.<number>}
   */this.anchor_=options.anchor!==undefined?options.anchor:[0.5,0.5];/**
   * @private
   * @type {Array.<number>}
   */this.normalizedAnchor_=null;/**
   * @private
   * @type {ol.style.IconOrigin}
   */this.anchorOrigin_=options.anchorOrigin!==undefined?options.anchorOrigin:_ol_style_IconOrigin_.TOP_LEFT;/**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */this.anchorXUnits_=options.anchorXUnits!==undefined?options.anchorXUnits:_ol_style_IconAnchorUnits_.FRACTION;/**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */this.anchorYUnits_=options.anchorYUnits!==undefined?options.anchorYUnits:_ol_style_IconAnchorUnits_.FRACTION;/**
   * @private
   * @type {?string}
   */this.crossOrigin_=options.crossOrigin!==undefined?options.crossOrigin:null;/**
   * @type {Image|HTMLCanvasElement}
   */var image=options.img!==undefined?options.img:null;/**
   * @type {ol.Size}
   */var imgSize=options.imgSize!==undefined?options.imgSize:null;/**
   * @type {string|undefined}
   */var src=options.src;_ol_asserts_.assert(!(src!==undefined&&image),4);// `image` and `src` cannot be provided at the same time
_ol_asserts_.assert(!image||image&&imgSize,5);// `imgSize` must be set when `image` is provided
if((src===undefined||src.length===0)&&image){src=image.src||_ol_.getUid(image).toString();}_ol_asserts_.assert(src!==undefined&&src.length>0,6);// A defined and non-empty `src` or `image` must be provided
/**
   * @type {ol.ImageState}
   */var imageState=options.src!==undefined?_ol_ImageState_.IDLE:_ol_ImageState_.LOADED;/**
   * @private
   * @type {ol.Color}
   */this.color_=options.color!==undefined?_ol_color_.asArray(options.color):null;/**
   * @private
   * @type {ol.style.IconImage}
   */this.iconImage_=_ol_style_IconImage_.get(image,/** @type {string} */src,imgSize,this.crossOrigin_,imageState,this.color_);/**
   * @private
   * @type {Array.<number>}
   */this.offset_=options.offset!==undefined?options.offset:[0,0];/**
   * @private
   * @type {ol.style.IconOrigin}
   */this.offsetOrigin_=options.offsetOrigin!==undefined?options.offsetOrigin:_ol_style_IconOrigin_.TOP_LEFT;/**
   * @private
   * @type {Array.<number>}
   */this.origin_=null;/**
   * @private
   * @type {ol.Size}
   */this.size_=options.size!==undefined?options.size:null;/**
   * @type {number}
   */var opacity=options.opacity!==undefined?options.opacity:1;/**
   * @type {boolean}
   */var rotateWithView=options.rotateWithView!==undefined?options.rotateWithView:false;/**
   * @type {number}
   */var rotation=options.rotation!==undefined?options.rotation:0;/**
   * @type {number}
   */var scale=options.scale!==undefined?options.scale:1;/**
   * @type {boolean}
   */var snapToPixel=options.snapToPixel!==undefined?options.snapToPixel:true;_ol_style_Image_.call(this,{opacity:opacity,rotation:rotation,scale:scale,snapToPixel:snapToPixel,rotateWithView:rotateWithView});};_ol_.inherits(_ol_style_Icon_,_ol_style_Image_);/**
 * Clones the style.
 * @return {ol.style.Icon} The cloned style.
 * @api
 */_ol_style_Icon_.prototype.clone=function(){var oldImage=this.getImage(1);var newImage;if(this.iconImage_.getImageState()===_ol_ImageState_.LOADED){if(oldImage.tagName.toUpperCase()==='IMG'){newImage=/** @type {Image} */oldImage.cloneNode(true);}else{newImage=/** @type {HTMLCanvasElement} */document.createElement('canvas');var context=newImage.getContext('2d');newImage.width=oldImage.width;newImage.height=oldImage.height;context.drawImage(oldImage,0,0);}}return new _ol_style_Icon_({anchor:this.anchor_.slice(),anchorOrigin:this.anchorOrigin_,anchorXUnits:this.anchorXUnits_,anchorYUnits:this.anchorYUnits_,crossOrigin:this.crossOrigin_,color:this.color_&&this.color_.slice?this.color_.slice():this.color_||undefined,img:newImage?newImage:undefined,imgSize:newImage?this.iconImage_.getSize().slice():undefined,src:newImage?undefined:this.getSrc(),offset:this.offset_.slice(),offsetOrigin:this.offsetOrigin_,size:this.size_!==null?this.size_.slice():undefined,opacity:this.getOpacity(),scale:this.getScale(),snapToPixel:this.getSnapToPixel(),rotation:this.getRotation(),rotateWithView:this.getRotateWithView()});};/**
 * @inheritDoc
 * @api
 */_ol_style_Icon_.prototype.getAnchor=function(){if(this.normalizedAnchor_){return this.normalizedAnchor_;}var anchor=this.anchor_;var size=this.getSize();if(this.anchorXUnits_==_ol_style_IconAnchorUnits_.FRACTION||this.anchorYUnits_==_ol_style_IconAnchorUnits_.FRACTION){if(!size){return null;}anchor=this.anchor_.slice();if(this.anchorXUnits_==_ol_style_IconAnchorUnits_.FRACTION){anchor[0]*=size[0];}if(this.anchorYUnits_==_ol_style_IconAnchorUnits_.FRACTION){anchor[1]*=size[1];}}if(this.anchorOrigin_!=_ol_style_IconOrigin_.TOP_LEFT){if(!size){return null;}if(anchor===this.anchor_){anchor=this.anchor_.slice();}if(this.anchorOrigin_==_ol_style_IconOrigin_.TOP_RIGHT||this.anchorOrigin_==_ol_style_IconOrigin_.BOTTOM_RIGHT){anchor[0]=-anchor[0]+size[0];}if(this.anchorOrigin_==_ol_style_IconOrigin_.BOTTOM_LEFT||this.anchorOrigin_==_ol_style_IconOrigin_.BOTTOM_RIGHT){anchor[1]=-anchor[1]+size[1];}}this.normalizedAnchor_=anchor;return this.normalizedAnchor_;};/**
 * Get the icon color.
 * @return {ol.Color} Color.
 * @api
 */_ol_style_Icon_.prototype.getColor=function(){return this.color_;};/**
 * Get the image icon.
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 * @override
 * @api
 */_ol_style_Icon_.prototype.getImage=function(pixelRatio){return this.iconImage_.getImage(pixelRatio);};/**
 * @override
 */_ol_style_Icon_.prototype.getImageSize=function(){return this.iconImage_.getSize();};/**
 * @override
 */_ol_style_Icon_.prototype.getHitDetectionImageSize=function(){return this.getImageSize();};/**
 * @override
 */_ol_style_Icon_.prototype.getImageState=function(){return this.iconImage_.getImageState();};/**
 * @override
 */_ol_style_Icon_.prototype.getHitDetectionImage=function(pixelRatio){return this.iconImage_.getHitDetectionImage(pixelRatio);};/**
 * @inheritDoc
 * @api
 */_ol_style_Icon_.prototype.getOrigin=function(){if(this.origin_){return this.origin_;}var offset=this.offset_;if(this.offsetOrigin_!=_ol_style_IconOrigin_.TOP_LEFT){var size=this.getSize();var iconImageSize=this.iconImage_.getSize();if(!size||!iconImageSize){return null;}offset=offset.slice();if(this.offsetOrigin_==_ol_style_IconOrigin_.TOP_RIGHT||this.offsetOrigin_==_ol_style_IconOrigin_.BOTTOM_RIGHT){offset[0]=iconImageSize[0]-size[0]-offset[0];}if(this.offsetOrigin_==_ol_style_IconOrigin_.BOTTOM_LEFT||this.offsetOrigin_==_ol_style_IconOrigin_.BOTTOM_RIGHT){offset[1]=iconImageSize[1]-size[1]-offset[1];}}this.origin_=offset;return this.origin_;};/**
 * Get the image URL.
 * @return {string|undefined} Image src.
 * @api
 */_ol_style_Icon_.prototype.getSrc=function(){return this.iconImage_.getSrc();};/**
 * @inheritDoc
 * @api
 */_ol_style_Icon_.prototype.getSize=function(){return!this.size_?this.iconImage_.getSize():this.size_;};/**
 * @override
 */_ol_style_Icon_.prototype.listenImageChange=function(listener,thisArg){return _ol_events_.listen(this.iconImage_,_ol_events_EventType_.CHANGE,listener,thisArg);};/**
 * Load not yet loaded URI.
 * When rendering a feature with an icon style, the vector renderer will
 * automatically call this method. However, you might want to call this
 * method yourself for preloading or other purposes.
 * @override
 * @api
 */_ol_style_Icon_.prototype.load=function(){this.iconImage_.load();};/**
 * @override
 */_ol_style_Icon_.prototype.unlistenImageChange=function(listener,thisArg){_ol_events_.unlisten(this.iconImage_,_ol_events_EventType_.CHANGE,listener,thisArg);};var getFeatureCenter=function(feature){var ext=feature.getGeometry().getExtent();var center=_ol_extent_.getCenter(ext);return new _ol_geom_Point_(center);};var defaultStyle=new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255,255,255,0.4)'}),stroke:new _ol_style_Stroke_({color:'#3399CC',width:1.25})});var styles={creepSpawn:new _ol_style_Style_$1({image:new _ol_style_RegularShape_({points:6,radius:8,fill:new _ol_style_Fill_({color:'rgba(0, 0, 255, 0.3)'}),stroke:new _ol_style_Stroke_({color:'rgba(0, 0, 255, 0.7)',width:2})})}),neutralCamp:[new _ol_style_Style_$1({image:new _ol_style_RegularShape_({points:3,radius:8,fill:new _ol_style_Fill_({color:'rgba(0, 255, 0, 0.3)'}),stroke:new _ol_style_Stroke_({color:'rgba(0, 255, 0, 0.7)',width:2})})}),new _ol_style_Style_$1({image:new _ol_style_RegularShape_({points:3,radius:9,fill:new _ol_style_Fill_({color:'rgba(255, 255, 0, 0.3)'}),stroke:new _ol_style_Stroke_({color:'rgba(255, 255, 0, 0.7)',width:2})})}),new _ol_style_Style_$1({image:new _ol_style_RegularShape_({points:3,radius:10,fill:new _ol_style_Fill_({color:'rgba(255, 150, 0, 0.3)'}),stroke:new _ol_style_Stroke_({color:'rgba(255, 150, 0, 0.7)',width:2})})}),new _ol_style_Style_$1({image:new _ol_style_RegularShape_({points:3,radius:11,fill:new _ol_style_Fill_({color:'rgba(255, 0, 0, 0.3)'}),stroke:new _ol_style_Stroke_({color:'rgba(255, 0, 0, 0.7)',width:2})})})],dire:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255, 51, 51, 0.2)'}),stroke:new _ol_style_Stroke_({color:'#FF3333',width:2})}),radiant:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(51, 255, 51, 0.2)'}),stroke:new _ol_style_Stroke_({color:'#33FF33',width:2})}),direCreep:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255, 51, 51, 0.2)'}),stroke:new _ol_style_Stroke_({color:'#FF3333',width:10})}),radiantCreep:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(51, 255, 51, 0.2)'}),stroke:new _ol_style_Stroke_({color:'#33FF33',width:10})}),highlight:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255, 255, 0, 0.2)'}),stroke:new _ol_style_Stroke_({color:'#ffff00',width:2})}),select:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(0, 255, 0, 0.2)'}),stroke:new _ol_style_Stroke_({color:'#00ff00',width:2})}),cursor:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255, 255, 255, 0.2)'}),stroke:new _ol_style_Stroke_({color:'rgba(255, 255, 255, 1)',width:1})}),visionSimulation:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255, 255, 0, 0.2)'}),stroke:new _ol_style_Stroke_({color:'rgba(255, 255, 0, 1)',width:1})}),dayVision:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(238, 153, 0, 0.1)'}),stroke:new _ol_style_Stroke_({color:'rgba(238, 153, 0, 0.5)',width:2})}),nightVision:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(0, 127, 255, 0.1)'}),stroke:new _ol_style_Stroke_({color:'rgba(0, 0, 255, 0.5)',width:2})}),trueSight:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(0, 127, 255, 0.1)'}),stroke:new _ol_style_Stroke_({color:'rgba(0, 127, 255, 0.5)',width:2})}),attackRange:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255, 0, 0, 0.1)'}),stroke:new _ol_style_Stroke_({color:'rgba(255, 0, 0, 0.5)',width:2})}),ent_dota_fountain:[defaultStyle,new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/svgs/water-15.svg',anchor:[0.5,0.5],imgSize:[21,21]}),geometry:getFeatureCenter})],npc_dota_barracks:[defaultStyle,new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/svgs/stadium-15.svg',anchor:[0.5,0.5],imgSize:[21,21]}),geometry:getFeatureCenter})],npc_dota_filler:[defaultStyle,new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/svgs/landmark-15.svg',anchor:[0.5,0.5],imgSize:[21,21]}),geometry:getFeatureCenter})],npc_dota_tower:[defaultStyle,new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/svgs/castle-15.svg',anchor:[0.5,0.5],imgSize:[21,21]}),geometry:getFeatureCenter})],ent_dota_shop:[defaultStyle,new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/svgs/shop-15.svg',anchor:[0.5,0.5],imgSize:[21,21]}),geometry:getFeatureCenter})],npc_dota_fort:[defaultStyle,new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/svgs/town-hall-15.svg',anchor:[0.5,0.5],imgSize:[21,21]}),geometry:getFeatureCenter})],npc_dota_healer:[defaultStyle,new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/svgs/place-of-worship-15.svg',anchor:[0.5,0.5],imgSize:[21,21]}),geometry:getFeatureCenter})],measure:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(255, 255, 255, 0.3)'}),stroke:new _ol_style_Stroke_({color:'rgba(255,165,0, 0.7)',lineDash:[10,10],width:3}),image:new _ol_style_Circle_({radius:5,stroke:new _ol_style_Stroke_({color:'rgba(255,165,0, 0.7)',width:2}),fill:new _ol_style_Fill_({color:'rgba(255,165,0, 0.3)'})})}),observer:{normal:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/ward_observer.png',anchor:[0.5,1]})}),highlight:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/ward_observer.png',anchor:[0.5,1],color:'#0000ff'})}),remove:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/ward_observer.png',anchor:[0.5,1],color:'#ff0000'})})},sentry:{normal:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/ward_sentry.png',anchor:[0.5,1]})}),highlight:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/ward_sentry.png',anchor:[0.5,1],color:'#0000ff'})}),remove:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/ward_sentry.png',anchor:[0.5,1],color:'#ff0000'})})},tree:{alive:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:[0,255,0,0.3]}),stroke:new _ol_style_Stroke_({color:[0,255,0,0.8]})}),dead:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:[51,25,0,0.7]}),stroke:new _ol_style_Stroke_({color:[255,128,0,0.8]})})},bountyRune:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/bountyrune.png',anchor:[0.5,0.5]})}),rune:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/doubledamage.png',anchor:[0.5,0.5]})}),roshan:new _ol_style_Style_$1({image:new _ol_style_Icon_({src:'img/roshan.png',anchor:[0.5,0.5]})}),pullRange:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:'rgba(0, 153, 238, 0.1)'}),stroke:new _ol_style_Stroke_({color:'rgba(0, 153, 238, 0.5)',width:2})})};styles.teamColor=function(feature,resolution){if(feature.getId().indexOf('_bad_')==-1){return styles.radiant;}else{return styles.dire;}};styles.creepColor=function(feature,resolution){if(feature.getId().indexOf('_bad_')==-1){return styles.radiantCreep;}else{return styles.direCreep;}};function createCirclePointCoords(circleCenterX,circleCenterY,circleRadius,pointsToFind){var angleToAdd=360/pointsToFind;var coords=[];var angle=0;for(var i=0;i<pointsToFind;i++){angle=angle+angleToAdd;var coordX=circleCenterX+circleRadius*Math.cos(angle*Math.PI/180);var coordY=circleCenterY+circleRadius*Math.sin(angle*Math.PI/180);coords.push([coordX,coordY]);}return coords;}function InfoControl(InteractiveMap){var self=this;this.InteractiveMap=InteractiveMap;//this.highlight = null;
this.lastPointerMoveTime=Date.now();this.pointerMoveHandler=function(evt){// When user was dragging map, then coordinates didn't change and there's
// no need to continue
if(evt.dragging){return;}var pixel=self.InteractiveMap.map.getEventPixel(evt.originalEvent);// if mouse over a building feature, show info and highlight
var feature=self.InteractiveMap.map.forEachFeatureAtPixel(pixel,function(feature){return feature;},{layerFilter:self.InteractiveMap.layerFilters.marker});if(feature){if(!self.isActive()){self.displayFeatureInfo(feature,false);}self.highlight(feature);}else{self.close(false);// if mouse over a ward feature, highlight
var feature=self.InteractiveMap.checkAndHighlightWard(pixel);if(feature){self.InteractiveMap.wardControl.showVisibilityInfo(feature.get('visionFeature'));}// no highlighted feature so unhighlight current feature
else if(!self.isActive()){self.unhighlight();}}};this.pointerMoveListener=null;this.clickHandler=function(evt){self.unhighlight();var feature=self.InteractiveMap.map.forEachFeatureAtPixel(evt.pixel,function(feature,layer){return feature;},{layerFilter:self.InteractiveMap.layerFilters.marker});if(feature){if(!feature.get("clicked")){self.InteractiveMap.deselectAll();var dotaProps=feature.get('dotaProps');if(feature.get('dotaProps').id=="ent_dota_tree"){self.InteractiveMap.treeControl.toggleTree(feature,dotaProps);}else{self.displayFeatureInfo(feature,true);self.select(feature);self.InteractiveMap.panTo(evt.coordinate);}}else{self.InteractiveMap.deselectAll();self.close(true);}}else{// if clicked a ward feature, highlight
var feature=self.InteractiveMap.checkAndHighlightWard(evt.pixel);if(feature){var visionFeature=feature.get('visionFeature');if(visionFeature){self.InteractiveMap.wardControl.showVisibilityInfo(feature.get('visionFeature'),true);}else{self.close(true);}self.InteractiveMap.panTo(evt.coordinate);}// no highlighted feature so unhighlight current feature
else if(!self.isActive()){self.unhighlight();self.close(true);}self.InteractiveMap.deselectAll();}};this.clickListener=null;}InfoControl.prototype.activate=function(){if(!this.pointerMoveListener){this.pointerMoveListener=this.InteractiveMap.map.on('pointermove',this.pointerMoveHandler);}if(!this.clickListener){this.clickListener=this.InteractiveMap.map.on('click',this.clickHandler);}};InfoControl.prototype.deactivate=function(){this.InteractiveMap.unhighlightWard();_ol_Observable_.unByKey(this.pointerMoveListener);this.pointerMoveListener=null;_ol_Observable_.unByKey(this.clickListener);this.clickListener=null;};InfoControl.prototype.setContent=function(html){this.infoContent.innerHTML=html;};InfoControl.prototype.isActive=function(){return this.info.classList.contains('active');};InfoControl.prototype.open=function(bClicked){this.info.classList.add('slideUp');this.info.classList.remove('slideDown');if(bClicked){this.info.classList.add('active');}};InfoControl.prototype.close=function(bOverrideActive){if(!this.isActive()||bOverrideActive){this.info.classList.add('slideDown');this.info.classList.remove('slideUp');this.info.classList.remove('active');}};InfoControl.prototype.initialize=function(id){var self=this;this.id=id;this.info=document.getElementById(id);this.infoContent=document.querySelector('#'+id+' .message-content');this.closeBtn=document.querySelector('#'+id+' .btn-close');this.closeHandler=function(evt){self.close.call(self,true);};this.closeBtn.addEventListener('click',this.closeHandler,false);};InfoControl.prototype.displayFeatureInfo=function(feature,bClicked){this.setContent(getPopupContent(this.InteractiveMap.getMapData(),feature));this.open(bClicked);};InfoControl.prototype.unhighlight=function(feature){var highlightedFeature=feature||this.InteractiveMap.highlightedFeature;if(highlightedFeature&&!highlightedFeature.get("clicked")){var dotaProps=highlightedFeature.get('dotaProps');if(dotaProps){if(dotaProps.id=='npc_dota_neutral_spawner'){var pullRange=highlightedFeature.get('pullRange');if(pullRange){this.InteractiveMap.getMapLayerIndex()['pullRange'].getSource().removeFeature(pullRange);highlightedFeature.set("pullRange",null,true);}var guardRange=highlightedFeature.get('guardRange');if(guardRange){this.InteractiveMap.getMapLayerIndex()['pullRange'].getSource().removeFeature(guardRange);highlightedFeature.set("guardRange",null,true);}}}}this.InteractiveMap.unhighlight();};InfoControl.prototype.highlight=function(feature){this.unhighlight();var dotaProps=feature.get('dotaProps');if(dotaProps){if(dotaProps.id=='npc_dota_neutral_spawner'){if(!feature.get('pullRange')){var circle=this.InteractiveMap.getRangeCircle(feature,null,null,null,400);feature.set("guardRange",circle,true);this.InteractiveMap.getMapLayerIndex()['pullRange'].getSource().addFeature(circle);var center=worldToLatLon([dotaProps.x,dotaProps.y]);var pullTiming=mapConstants.pullRangeTiming[dotaProps.pullType];var pullMaxCoords=createCirclePointCoords(center[0],center[1],400+pullTiming*350,360);var pullMinCoords=createCirclePointCoords(center[0],center[1],400+pullTiming*270,360);var geom=new _ol_geom_Polygon_([pullMaxCoords]);geom.appendLinearRing(new _ol_geom_LinearRing_(pullMinCoords));var circle=new _ol_Feature_(geom);feature.set("pullRange",circle,true);this.InteractiveMap.getMapLayerIndex()['pullRange'].getSource().addFeature(circle);}}}this.InteractiveMap.highlight(feature);};InfoControl.prototype.select=function(feature){if(feature&&!feature.get("clicked")){if(feature==this.InteractiveMap.highlightedFeature){this.unhighlight();}this.InteractiveMap.selectSource.addFeature(feature);feature.set("clicked",true,true);}};function NotificationControl(){this.timer=null;}NotificationControl.prototype.show=function(message){this.setContent(message);this.info.classList.remove('slideUp');this.info.classList.add('slideDown');clearTimeout(this.timer);var self=this;this.timer=setTimeout(function(){self.info.classList.add('slideUp');self.info.classList.remove('slideDown');},1500);};NotificationControl.prototype.setContent=function(html){this.infoContent.innerHTML=html;};NotificationControl.prototype.open=function(){this.info.classList.add('slideDown');this.info.classList.remove('slideUp');};NotificationControl.prototype.close=function(){this.info.classList.add('slideUp');this.info.classList.remove('slideDown');};NotificationControl.prototype.initialize=function(id){var self=this;this.id=id;this.info=document.getElementById(id);this.infoContent=document.querySelector('#'+id+' .message-content');};/**
 * @enum {string}
 */var _ol_CollectionEventType_={/**
   * Triggered when an item is added to the collection.
   * @event ol.Collection.Event#add
   * @api
   */ADD:'add',/**
   * Triggered when an item is removed from the collection.
   * @event ol.Collection.Event#remove
   * @api
   */REMOVE:'remove'};/**
 * An implementation of Google Maps' MVCArray.
 * @see https://developers.google.com/maps/documentation/javascript/reference
 *//**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @constructor
 * @extends {ol.Object}
 * @fires ol.Collection.Event
 * @param {Array.<T>=} opt_array Array.
 * @param {olx.CollectionOptions=} opt_options Collection options.
 * @template T
 * @api
 */var _ol_Collection_=function(opt_array,opt_options){_ol_Object_.call(this);var options=opt_options||{};/**
   * @private
   * @type {boolean}
   */this.unique_=!!options.unique;/**
   * @private
   * @type {!Array.<T>}
   */this.array_=opt_array?opt_array:[];if(this.unique_){for(var i=0,ii=this.array_.length;i<ii;++i){this.assertUnique_(this.array_[i],i);}}this.updateLength_();};_ol_.inherits(_ol_Collection_,_ol_Object_);/**
 * Remove all elements from the collection.
 * @api
 */_ol_Collection_.prototype.clear=function(){while(this.getLength()>0){this.pop();}};/**
 * Add elements to the collection.  This pushes each item in the provided array
 * to the end of the collection.
 * @param {!Array.<T>} arr Array.
 * @return {ol.Collection.<T>} This collection.
 * @api
 */_ol_Collection_.prototype.extend=function(arr){var i,ii;for(i=0,ii=arr.length;i<ii;++i){this.push(arr[i]);}return this;};/**
 * Iterate over each element, calling the provided callback.
 * @param {function(this: S, T, number, Array.<T>): *} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array). The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 * @api
 */_ol_Collection_.prototype.forEach=function(f,opt_this){var fn=opt_this?f.bind(opt_this):f;var array=this.array_;for(var i=0,ii=array.length;i<ii;++i){fn(array[i],i,array);}};/**
 * Get a reference to the underlying Array object. Warning: if the array
 * is mutated, no events will be dispatched by the collection, and the
 * collection's "length" property won't be in sync with the actual length
 * of the array.
 * @return {!Array.<T>} Array.
 * @api
 */_ol_Collection_.prototype.getArray=function(){return this.array_;};/**
 * Get the element at the provided index.
 * @param {number} index Index.
 * @return {T} Element.
 * @api
 */_ol_Collection_.prototype.item=function(index){return this.array_[index];};/**
 * Get the length of this collection.
 * @return {number} The length of the array.
 * @observable
 * @api
 */_ol_Collection_.prototype.getLength=function(){return(/** @type {number} */this.get(_ol_Collection_.Property_.LENGTH));};/**
 * Insert an element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */_ol_Collection_.prototype.insertAt=function(index,elem){if(this.unique_){this.assertUnique_(elem);}this.array_.splice(index,0,elem);this.updateLength_();this.dispatchEvent(new _ol_Collection_.Event(_ol_CollectionEventType_.ADD,elem));};/**
 * Remove the last element of the collection and return it.
 * Return `undefined` if the collection is empty.
 * @return {T|undefined} Element.
 * @api
 */_ol_Collection_.prototype.pop=function(){return this.removeAt(this.getLength()-1);};/**
 * Insert the provided element at the end of the collection.
 * @param {T} elem Element.
 * @return {number} New length of the collection.
 * @api
 */_ol_Collection_.prototype.push=function(elem){if(this.unique_){this.assertUnique_(elem);}var n=this.getLength();this.insertAt(n,elem);return this.getLength();};/**
 * Remove the first occurrence of an element from the collection.
 * @param {T} elem Element.
 * @return {T|undefined} The removed element or undefined if none found.
 * @api
 */_ol_Collection_.prototype.remove=function(elem){var arr=this.array_;var i,ii;for(i=0,ii=arr.length;i<ii;++i){if(arr[i]===elem){return this.removeAt(i);}}return undefined;};/**
 * Remove the element at the provided index and return it.
 * Return `undefined` if the collection does not contain this index.
 * @param {number} index Index.
 * @return {T|undefined} Value.
 * @api
 */_ol_Collection_.prototype.removeAt=function(index){var prev=this.array_[index];this.array_.splice(index,1);this.updateLength_();this.dispatchEvent(new _ol_Collection_.Event(_ol_CollectionEventType_.REMOVE,prev));return prev;};/**
 * Set the element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */_ol_Collection_.prototype.setAt=function(index,elem){var n=this.getLength();if(index<n){if(this.unique_){this.assertUnique_(elem,index);}var prev=this.array_[index];this.array_[index]=elem;this.dispatchEvent(new _ol_Collection_.Event(_ol_CollectionEventType_.REMOVE,prev));this.dispatchEvent(new _ol_Collection_.Event(_ol_CollectionEventType_.ADD,elem));}else{var j;for(j=n;j<index;++j){this.insertAt(j,undefined);}this.insertAt(index,elem);}};/**
 * @private
 */_ol_Collection_.prototype.updateLength_=function(){this.set(_ol_Collection_.Property_.LENGTH,this.array_.length);};/**
 * @private
 * @param {T} elem Element.
 * @param {number=} opt_except Optional index to ignore.
 */_ol_Collection_.prototype.assertUnique_=function(elem,opt_except){for(var i=0,ii=this.array_.length;i<ii;++i){if(this.array_[i]===elem&&i!==opt_except){throw new _ol_AssertionError_(58);}}};/**
 * @enum {string}
 * @private
 */_ol_Collection_.Property_={LENGTH:'length'};/**
 * @classdesc
 * Events emitted by {@link ol.Collection} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.Collection.Event}
 * @param {ol.CollectionEventType} type Type.
 * @param {*=} opt_element Element.
 */_ol_Collection_.Event=function(type,opt_element){_ol_events_Event_.call(this,type);/**
   * The element that is added to or removed from the collection.
   * @type {*}
   * @api
   */this.element=opt_element;};_ol_.inherits(_ol_Collection_.Event,_ol_events_Event_);/**
 * @enum {string}
 */var _ol_format_FormatType_={ARRAY_BUFFER:'arraybuffer',JSON:'json',TEXT:'text',XML:'xml'};var _ol_xml_={};/**
 * This document should be used when creating nodes for XML serializations. This
 * document is also used by {@link ol.xml.createElementNS} and
 * {@link ol.xml.setAttributeNS}
 * @const
 * @type {Document}
 */_ol_xml_.DOCUMENT=document.implementation.createDocument('','',null);/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Node} Node.
 */_ol_xml_.createElementNS=function(namespaceURI,qualifiedName){return _ol_xml_.DOCUMENT.createElementNS(namespaceURI,qualifiedName);};/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */_ol_xml_.getAllTextContent=function(node,normalizeWhitespace){return _ol_xml_.getAllTextContent_(node,normalizeWhitespace,[]).join('');};/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array.<string>} accumulator Accumulator.
 * @private
 * @return {Array.<string>} Accumulator.
 */_ol_xml_.getAllTextContent_=function(node,normalizeWhitespace,accumulator){if(node.nodeType==Node.CDATA_SECTION_NODE||node.nodeType==Node.TEXT_NODE){if(normalizeWhitespace){accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g,''));}else{accumulator.push(node.nodeValue);}}else{var n;for(n=node.firstChild;n;n=n.nextSibling){_ol_xml_.getAllTextContent_(n,normalizeWhitespace,accumulator);}}return accumulator;};/**
 * @param {?} value Value.
 * @return {boolean} Is document.
 */_ol_xml_.isDocument=function(value){return value instanceof Document;};/**
 * @param {?} value Value.
 * @return {boolean} Is node.
 */_ol_xml_.isNode=function(value){return value instanceof Node;};/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */_ol_xml_.getAttributeNS=function(node,namespaceURI,name){return node.getAttributeNS(namespaceURI,name)||'';};/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @param {string|number} value Value.
 */_ol_xml_.setAttributeNS=function(node,namespaceURI,name,value){node.setAttributeNS(namespaceURI,name,value);};/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */_ol_xml_.parse=function(xml){return new DOMParser().parseFromString(xml,'application/xml');};/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): (Array.<*>|undefined)}
 *     valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */_ol_xml_.makeArrayExtender=function(valueReader,opt_this){return(/**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */function(node,objectStack){var value=valueReader.call(opt_this,node,objectStack);if(value!==undefined){var array=/** @type {Array.<*>} */objectStack[objectStack.length-1];_ol_array_.extend(array,value);}});};/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */_ol_xml_.makeArrayPusher=function(valueReader,opt_this){return(/**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */function(node,objectStack){var value=valueReader.call(opt_this!==undefined?opt_this:this,node,objectStack);if(value!==undefined){var array=objectStack[objectStack.length-1];array.push(value);}});};/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */_ol_xml_.makeReplacer=function(valueReader,opt_this){return(/**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */function(node,objectStack){var value=valueReader.call(opt_this!==undefined?opt_this:this,node,objectStack);if(value!==undefined){objectStack[objectStack.length-1]=value;}});};/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */_ol_xml_.makeObjectPropertyPusher=function(valueReader,opt_property,opt_this){return(/**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */function(node,objectStack){var value=valueReader.call(opt_this!==undefined?opt_this:this,node,objectStack);if(value!==undefined){var object=/** @type {Object} */objectStack[objectStack.length-1];var property=opt_property!==undefined?opt_property:node.localName;var array;if(property in object){array=object[property];}else{array=object[property]=[];}array.push(value);}});};/**
 * Make an object property setter function.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */_ol_xml_.makeObjectPropertySetter=function(valueReader,opt_property,opt_this){return(/**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */function(node,objectStack){var value=valueReader.call(opt_this!==undefined?opt_this:this,node,objectStack);if(value!==undefined){var object=/** @type {Object} */objectStack[objectStack.length-1];var property=opt_property!==undefined?opt_property:node.localName;object[property]=value;}});};/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link ol.XmlNodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */_ol_xml_.makeChildAppender=function(nodeWriter,opt_this){return function(node,value,objectStack){nodeWriter.call(opt_this!==undefined?opt_this:this,node,value,objectStack);var parent=objectStack[objectStack.length-1];var parentNode=parent.node;parentNode.appendChild(node);};};/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link ol.xml.serialize}. This can be used by the parent writer to have the
 * 'nodeWriter' called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */_ol_xml_.makeArraySerializer=function(nodeWriter,opt_this){var serializersNS,nodeFactory;return function(node,value,objectStack){if(serializersNS===undefined){serializersNS={};var serializers={};serializers[node.localName]=nodeWriter;serializersNS[node.namespaceURI]=serializers;nodeFactory=_ol_xml_.makeSimpleNodeFactory(node.localName);}_ol_xml_.serialize(serializersNS,nodeFactory,value,objectStack);};};/**
 * Create a node factory which can use the `opt_keys` passed to
 * {@link ol.xml.serialize} or {@link ol.xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string=} opt_nodeName Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array.<*>, string=): (Node|undefined)} Node factory.
 */_ol_xml_.makeSimpleNodeFactory=function(opt_nodeName,opt_namespaceURI){var fixedNodeName=opt_nodeName;return(/**
     * @param {*} value Value.
     * @param {Array.<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node} Node.
     */function(value,objectStack,opt_nodeName){var context=objectStack[objectStack.length-1];var node=context.node;var nodeName=fixedNodeName;if(nodeName===undefined){nodeName=opt_nodeName;}var namespaceURI=opt_namespaceURI;if(opt_namespaceURI===undefined){namespaceURI=node.namespaceURI;}return _ol_xml_.createElementNS(namespaceURI,/** @type {string} */nodeName);});};/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 */_ol_xml_.OBJECT_PROPERTY_NODE_FACTORY=_ol_xml_.makeSimpleNodeFactory();/**
 * Create an array of `values` to be used with {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `opt_key` argument.
 * @param {Object.<string, V>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array.<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array.<V>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 * @template V
 */_ol_xml_.makeSequence=function(object,orderedKeys){var length=orderedKeys.length;var sequence=new Array(length);for(var i=0;i<length;++i){sequence[i]=object[orderedKeys[i]];}return sequence;};/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.
 * @return {Object.<string, T>} Namespaced structure.
 * @template T
 */_ol_xml_.makeStructureNS=function(namespaceURIs,structure,opt_structureNS){/**
   * @type {Object.<string, *>}
   */var structureNS=opt_structureNS!==undefined?opt_structureNS:{};var i,ii;for(i=0,ii=namespaceURIs.length;i<ii;++i){structureNS[namespaceURIs[i]]=structure;}return structureNS;};/**
 * Parse a node using the parsers and object stack.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 */_ol_xml_.parseNode=function(parsersNS,node,objectStack,opt_this){var n;for(n=node.firstElementChild;n;n=n.nextElementSibling){var parsers=parsersNS[n.namespaceURI];if(parsers!==undefined){var parser=parsers[n.localName];if(parser!==undefined){parser.call(opt_this,n,objectStack);}}}};/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 * @return {T} Object.
 * @template T
 */_ol_xml_.pushParseAndPop=function(object,parsersNS,node,objectStack,opt_this){objectStack.push(object);_ol_xml_.parseNode(parsersNS,node,objectStack,opt_this);return objectStack.pop();};/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */_ol_xml_.serialize=function(serializersNS,nodeFactory,values,objectStack,opt_keys,opt_this){var length=(opt_keys!==undefined?opt_keys:values).length;var value,node;for(var i=0;i<length;++i){value=values[i];if(value!==undefined){node=nodeFactory.call(opt_this,value,objectStack,opt_keys!==undefined?opt_keys[i]:undefined);if(node!==undefined){serializersNS[node.namespaceURI][node.localName].call(opt_this,node,value,objectStack);}}}};/**
 * @param {O} object Object.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */_ol_xml_.pushSerializeAndPop=function(object,serializersNS,nodeFactory,values,objectStack,opt_keys,opt_this){objectStack.push(object);_ol_xml_.serialize(serializersNS,nodeFactory,values,objectStack,opt_keys,opt_this);return objectStack.pop();};var _ol_featureloader_={};/**
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @param {function(this:ol.VectorTile, Array.<ol.Feature>, ol.proj.Projection, ol.Extent)|function(this:ol.source.Vector, Array.<ol.Feature>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:ol.VectorTile)|function(this:ol.source.Vector)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {ol.FeatureLoader} The feature loader.
 */_ol_featureloader_.loadFeaturesXhr=function(url,format,success,failure){return(/**
     * @param {ol.Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {ol.proj.Projection} projection Projection.
     * @this {ol.source.Vector|ol.VectorTile}
     */function(extent,resolution,projection){var xhr=new XMLHttpRequest();xhr.open('GET',typeof url==='function'?url(extent,resolution,projection):url,true);if(format.getType()==_ol_format_FormatType_.ARRAY_BUFFER){xhr.responseType='arraybuffer';}/**
       * @param {Event} event Event.
       * @private
       */xhr.onload=function(event){// status will be 0 for file:// urls
if(!xhr.status||xhr.status>=200&&xhr.status<300){var type=format.getType();/** @type {Document|Node|Object|string|undefined} */var source;if(type==_ol_format_FormatType_.JSON||type==_ol_format_FormatType_.TEXT){source=xhr.responseText;}else if(type==_ol_format_FormatType_.XML){source=xhr.responseXML;if(!source){source=_ol_xml_.parse(xhr.responseText);}}else if(type==_ol_format_FormatType_.ARRAY_BUFFER){source=/** @type {ArrayBuffer} */xhr.response;}if(source){success.call(this,format.readFeatures(source,{featureProjection:projection}),format.readProjection(source),format.getLastExtent());}else{failure.call(this);}}else{failure.call(this);}}.bind(this);/**
       * @private
       */xhr.onerror=function(){failure.call(this);}.bind(this);xhr.send();});};/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @return {ol.FeatureLoader} The feature loader.
 * @api
 */_ol_featureloader_.xhr=function(url,format){return _ol_featureloader_.loadFeaturesXhr(url,format,/**
       * @param {Array.<ol.Feature>} features The loaded features.
       * @param {ol.proj.Projection} dataProjection Data projection.
       * @this {ol.source.Vector}
       */function(features,dataProjection){this.addFeatures(features);},/* FIXME handle error */_ol_.nullFunction);};var _ol_loadingstrategy_={};/**
 * Strategy function for loading all features with a single request.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */_ol_loadingstrategy_.all=function(extent,resolution){return[[-Infinity,-Infinity,Infinity,Infinity]];};/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */_ol_loadingstrategy_.bbox=function(extent,resolution){return[extent];};/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {function(ol.Extent, number): Array.<ol.Extent>} Loading strategy.
 * @api
 */_ol_loadingstrategy_.tile=function(tileGrid){return(/**
       * @param {ol.Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @return {Array.<ol.Extent>} Extents.
       */function(extent,resolution){var z=tileGrid.getZForResolution(resolution);var tileRange=tileGrid.getTileRangeForExtentAndZ(extent,z);/** @type {Array.<ol.Extent>} */var extents=[];/** @type {ol.TileCoord} */var tileCoord=[z,0,0];for(tileCoord[1]=tileRange.minX;tileCoord[1]<=tileRange.maxX;++tileCoord[1]){for(tileCoord[2]=tileRange.minY;tileCoord[2]<=tileRange.maxY;++tileCoord[2]){extents.push(tileGrid.getTileCoordExtent(tileCoord));}}return extents;});};/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 *
 * @constructor
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @struct
 */var _ol_TileRange_=function(minX,maxX,minY,maxY){/**
   * @type {number}
   */this.minX=minX;/**
   * @type {number}
   */this.maxX=maxX;/**
   * @type {number}
   */this.minY=minY;/**
   * @type {number}
   */this.maxY=maxY;};/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {ol.TileRange|undefined} tileRange TileRange.
 * @return {ol.TileRange} Tile range.
 */_ol_TileRange_.createOrUpdate=function(minX,maxX,minY,maxY,tileRange){if(tileRange!==undefined){tileRange.minX=minX;tileRange.maxX=maxX;tileRange.minY=minY;tileRange.maxY=maxY;return tileRange;}else{return new _ol_TileRange_(minX,maxX,minY,maxY);}};/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */_ol_TileRange_.prototype.contains=function(tileCoord){return this.containsXY(tileCoord[1],tileCoord[2]);};/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */_ol_TileRange_.prototype.containsTileRange=function(tileRange){return this.minX<=tileRange.minX&&tileRange.maxX<=this.maxX&&this.minY<=tileRange.minY&&tileRange.maxY<=this.maxY;};/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */_ol_TileRange_.prototype.containsXY=function(x,y){return this.minX<=x&&x<=this.maxX&&this.minY<=y&&y<=this.maxY;};/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */_ol_TileRange_.prototype.equals=function(tileRange){return this.minX==tileRange.minX&&this.minY==tileRange.minY&&this.maxX==tileRange.maxX&&this.maxY==tileRange.maxY;};/**
 * @param {ol.TileRange} tileRange Tile range.
 */_ol_TileRange_.prototype.extend=function(tileRange){if(tileRange.minX<this.minX){this.minX=tileRange.minX;}if(tileRange.maxX>this.maxX){this.maxX=tileRange.maxX;}if(tileRange.minY<this.minY){this.minY=tileRange.minY;}if(tileRange.maxY>this.maxY){this.maxY=tileRange.maxY;}};/**
 * @return {number} Height.
 */_ol_TileRange_.prototype.getHeight=function(){return this.maxY-this.minY+1;};/**
 * @return {ol.Size} Size.
 */_ol_TileRange_.prototype.getSize=function(){return[this.getWidth(),this.getHeight()];};/**
 * @return {number} Width.
 */_ol_TileRange_.prototype.getWidth=function(){return this.maxX-this.minX+1;};/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */_ol_TileRange_.prototype.intersects=function(tileRange){return this.minX<=tileRange.maxX&&this.maxX>=tileRange.minX&&this.minY<=tileRange.maxY&&this.maxY>=tileRange.minY;};var _ol_size_={};/**
 * Returns a buffered size.
 * @param {ol.Size} size Size.
 * @param {number} buffer Buffer.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The buffered size.
 */_ol_size_.buffer=function(size,buffer,opt_size){if(opt_size===undefined){opt_size=[0,0];}opt_size[0]=size[0]+2*buffer;opt_size[1]=size[1]+2*buffer;return opt_size;};/**
 * Determines if a size has a positive area.
 * @param {ol.Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */_ol_size_.hasArea=function(size){return size[0]>0&&size[1]>0;};/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {ol.Size} size Size.
 * @param {number} ratio Ratio.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The scaled size.
 */_ol_size_.scale=function(size,ratio,opt_size){if(opt_size===undefined){opt_size=[0,0];}opt_size[0]=size[0]*ratio+0.5|0;opt_size[1]=size[1]*ratio+0.5|0;return opt_size;};/**
 * Returns an `ol.Size` array for the passed in number (meaning: square) or
 * `ol.Size` array.
 * (meaning: non-square),
 * @param {number|ol.Size} size Width and height.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} Size.
 * @api
 */_ol_size_.toSize=function(size,opt_size){if(Array.isArray(size)){return size;}else{if(opt_size===undefined){opt_size=[size,size];}else{opt_size[0]=opt_size[1]=/** @type {number} */size;}return opt_size;}};var _ol_tilecoord_={};/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.TileCoord=} opt_tileCoord Tile coordinate.
 * @return {ol.TileCoord} Tile coordinate.
 */_ol_tilecoord_.createOrUpdate=function(z,x,y,opt_tileCoord){if(opt_tileCoord!==undefined){opt_tileCoord[0]=z;opt_tileCoord[1]=x;opt_tileCoord[2]=y;return opt_tileCoord;}else{return[z,x,y];}};/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */_ol_tilecoord_.getKeyZXY=function(z,x,y){return z+'/'+x+'/'+y;};/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */_ol_tilecoord_.hash=function(tileCoord){return(tileCoord[1]<<tileCoord[0])+tileCoord[2];};/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */_ol_tilecoord_.quadKey=function(tileCoord){var z=tileCoord[0];var digits=new Array(z);var mask=1<<z-1;var i,charCode;for(i=0;i<z;++i){// 48 is charCode for 0 - '0'.charCodeAt(0)
charCode=48;if(tileCoord[1]&mask){charCode+=1;}if(tileCoord[2]&mask){charCode+=2;}digits[i]=String.fromCharCode(charCode);mask>>=1;}return digits.join('');};/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */_ol_tilecoord_.withinExtentAndZ=function(tileCoord,tileGrid){var z=tileCoord[0];var x=tileCoord[1];var y=tileCoord[2];if(tileGrid.getMinZoom()>z||z>tileGrid.getMaxZoom()){return false;}var extent=tileGrid.getExtent();var tileRange;if(!extent){tileRange=tileGrid.getFullTileRange(z);}else{tileRange=tileGrid.getTileRangeForExtentAndZ(extent,z);}if(!tileRange){return true;}else{return tileRange.containsXY(x,y);}};/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 *
 * @constructor
 * @param {olx.tilegrid.TileGridOptions} options Tile grid options.
 * @struct
 * @api
 */var _ol_tilegrid_TileGrid_=function(options){/**
   * @protected
   * @type {number}
   */this.minZoom=options.minZoom!==undefined?options.minZoom:0;/**
   * @private
   * @type {!Array.<number>}
   */this.resolutions_=options.resolutions;_ol_asserts_.assert(_ol_array_.isSorted(this.resolutions_,function(a,b){return b-a;},true),17);// `resolutions` must be sorted in descending order
/**
   * @protected
   * @type {number}
   */this.maxZoom=this.resolutions_.length-1;/**
   * @private
   * @type {ol.Coordinate}
   */this.origin_=options.origin!==undefined?options.origin:null;/**
   * @private
   * @type {Array.<ol.Coordinate>}
   */this.origins_=null;if(options.origins!==undefined){this.origins_=options.origins;_ol_asserts_.assert(this.origins_.length==this.resolutions_.length,20);// Number of `origins` and `resolutions` must be equal
}var extent=options.extent;if(extent!==undefined&&!this.origin_&&!this.origins_){this.origin_=_ol_extent_.getTopLeft(extent);}_ol_asserts_.assert(!this.origin_&&this.origins_||this.origin_&&!this.origins_,18);// Either `origin` or `origins` must be configured, never both
/**
   * @private
   * @type {Array.<number|ol.Size>}
   */this.tileSizes_=null;if(options.tileSizes!==undefined){this.tileSizes_=options.tileSizes;_ol_asserts_.assert(this.tileSizes_.length==this.resolutions_.length,19);// Number of `tileSizes` and `resolutions` must be equal
}/**
   * @private
   * @type {number|ol.Size}
   */this.tileSize_=options.tileSize!==undefined?options.tileSize:!this.tileSizes_?_ol_.DEFAULT_TILE_SIZE:null;_ol_asserts_.assert(!this.tileSize_&&this.tileSizes_||this.tileSize_&&!this.tileSizes_,22);// Either `tileSize` or `tileSizes` must be configured, never both
/**
   * @private
   * @type {ol.Extent}
   */this.extent_=extent!==undefined?extent:null;/**
   * @private
   * @type {Array.<ol.TileRange>}
   */this.fullTileRanges_=null;/**
   * @private
   * @type {ol.Size}
   */this.tmpSize_=[0,0];if(options.sizes!==undefined){this.fullTileRanges_=options.sizes.map(function(size,z){var tileRange=new _ol_TileRange_(Math.min(0,size[0]),Math.max(size[0]-1,-1),Math.min(0,size[1]),Math.max(size[1]-1,-1));return tileRange;},this);}else if(extent){this.calculateTileRanges_(extent);}};/**
 * @private
 * @type {ol.TileCoord}
 */_ol_tilegrid_TileGrid_.tmpTileCoord_=[0,0,0];/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} zoom Zoom level.
 * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.forEachTileCoord=function(extent,zoom,callback){var tileRange=this.getTileRangeForExtentAndZ(extent,zoom);for(var i=tileRange.minX,ii=tileRange.maxX;i<=ii;++i){for(var j=tileRange.minY,jj=tileRange.maxY;j<=jj;++j){callback([zoom,i,j]);}}};/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */_ol_tilegrid_TileGrid_.prototype.forEachTileCoordParentTileRange=function(tileCoord,callback,opt_this,opt_tileRange,opt_extent){var tileCoordExtent=this.getTileCoordExtent(tileCoord,opt_extent);var z=tileCoord[0]-1;while(z>=this.minZoom){if(callback.call(opt_this,z,this.getTileRangeForExtentAndZ(tileCoordExtent,z,opt_tileRange))){return true;}--z;}return false;};/**
 * Get the extent for this tile grid, if it was configured.
 * @return {ol.Extent} Extent.
 */_ol_tilegrid_TileGrid_.prototype.getExtent=function(){return this.extent_;};/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getMaxZoom=function(){return this.maxZoom;};/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getMinZoom=function(){return this.minZoom;};/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Z.
 * @return {ol.Coordinate} Origin.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getOrigin=function(z){if(this.origin_){return this.origin_;}else{return this.origins_[z];}};/**
 * Get the resolution for the given zoom level.
 * @param {number} z Z.
 * @return {number} Resolution.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getResolution=function(z){return this.resolutions_[z];};/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getResolutions=function(){return this.resolutions_;};/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.TileRange} Tile range.
 */_ol_tilegrid_TileGrid_.prototype.getTileCoordChildTileRange=function(tileCoord,opt_tileRange,opt_extent){if(tileCoord[0]<this.maxZoom){var tileCoordExtent=this.getTileCoordExtent(tileCoord,opt_extent);return this.getTileRangeForExtentAndZ(tileCoordExtent,tileCoord[0]+1,opt_tileRange);}else{return null;}};/**
 * @param {number} z Z.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.Extent} Extent.
 */_ol_tilegrid_TileGrid_.prototype.getTileRangeExtent=function(z,tileRange,opt_extent){var origin=this.getOrigin(z);var resolution=this.getResolution(z);var tileSize=_ol_size_.toSize(this.getTileSize(z),this.tmpSize_);var minX=origin[0]+tileRange.minX*tileSize[0]*resolution;var maxX=origin[0]+(tileRange.maxX+1)*tileSize[0]*resolution;var minY=origin[1]+tileRange.minY*tileSize[1]*resolution;var maxY=origin[1]+(tileRange.maxY+1)*tileSize[1]*resolution;return _ol_extent_.createOrUpdate(minX,minY,maxX,maxY,opt_extent);};/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.TileRange=} opt_tileRange Temporary tile range object.
 * @return {ol.TileRange} Tile range.
 */_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndResolution=function(extent,resolution,opt_tileRange){var tileCoord=_ol_tilegrid_TileGrid_.tmpTileCoord_;this.getTileCoordForXYAndResolution_(extent[0],extent[1],resolution,false,tileCoord);var minX=tileCoord[1];var minY=tileCoord[2];this.getTileCoordForXYAndResolution_(extent[2],extent[3],resolution,true,tileCoord);return _ol_TileRange_.createOrUpdate(minX,tileCoord[1],minY,tileCoord[2],opt_tileRange);};/**
 * @param {ol.Extent} extent Extent.
 * @param {number} z Z.
 * @param {ol.TileRange=} opt_tileRange Temporary tile range object.
 * @return {ol.TileRange} Tile range.
 */_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndZ=function(extent,z,opt_tileRange){var resolution=this.getResolution(z);return this.getTileRangeForExtentAndResolution(extent,resolution,opt_tileRange);};/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {ol.Coordinate} Tile center.
 */_ol_tilegrid_TileGrid_.prototype.getTileCoordCenter=function(tileCoord){var origin=this.getOrigin(tileCoord[0]);var resolution=this.getResolution(tileCoord[0]);var tileSize=_ol_size_.toSize(this.getTileSize(tileCoord[0]),this.tmpSize_);return[origin[0]+(tileCoord[1]+0.5)*tileSize[0]*resolution,origin[1]+(tileCoord[2]+0.5)*tileSize[1]*resolution];};/**
 * Get the extent of a tile coordinate.
 *
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Extent=} opt_extent Temporary extent object.
 * @return {ol.Extent} Extent.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getTileCoordExtent=function(tileCoord,opt_extent){var origin=this.getOrigin(tileCoord[0]);var resolution=this.getResolution(tileCoord[0]);var tileSize=_ol_size_.toSize(this.getTileSize(tileCoord[0]),this.tmpSize_);var minX=origin[0]+tileCoord[1]*tileSize[0]*resolution;var minY=origin[1]+tileCoord[2]*tileSize[1]*resolution;var maxX=minX+tileSize[0]*resolution;var maxY=minY+tileSize[1]*resolution;return _ol_extent_.createOrUpdate(minX,minY,maxX,maxY,opt_extent);};/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndResolution=function(coordinate,resolution,opt_tileCoord){return this.getTileCoordForXYAndResolution_(coordinate[0],coordinate[1],resolution,false,opt_tileCoord);};/**
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndResolution_=function(x,y,resolution,reverseIntersectionPolicy,opt_tileCoord){var z=this.getZForResolution(resolution);var scale=resolution/this.getResolution(z);var origin=this.getOrigin(z);var tileSize=_ol_size_.toSize(this.getTileSize(z),this.tmpSize_);var adjustX=reverseIntersectionPolicy?0.5:0;var adjustY=reverseIntersectionPolicy?0:0.5;var xFromOrigin=Math.floor((x-origin[0])/resolution+adjustX);var yFromOrigin=Math.floor((y-origin[1])/resolution+adjustY);var tileCoordX=scale*xFromOrigin/tileSize[0];var tileCoordY=scale*yFromOrigin/tileSize[1];if(reverseIntersectionPolicy){tileCoordX=Math.ceil(tileCoordX)-1;tileCoordY=Math.ceil(tileCoordY)-1;}else{tileCoordX=Math.floor(tileCoordX);tileCoordY=Math.floor(tileCoordY);}return _ol_tilecoord_.createOrUpdate(z,tileCoordX,tileCoordY,opt_tileCoord);};/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndZ=function(coordinate,z,opt_tileCoord){var resolution=this.getResolution(z);return this.getTileCoordForXYAndResolution_(coordinate[0],coordinate[1],resolution,false,opt_tileCoord);};/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */_ol_tilegrid_TileGrid_.prototype.getTileCoordResolution=function(tileCoord){return this.resolutions_[tileCoord[0]];};/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `ol.Size`, run the result through `ol.size.toSize()`.
 * @param {number} z Z.
 * @return {number|ol.Size} Tile size.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getTileSize=function(z){if(this.tileSize_){return this.tileSize_;}else{return this.tileSizes_[z];}};/**
 * @param {number} z Zoom level.
 * @return {ol.TileRange} Extent tile range for the specified zoom level.
 */_ol_tilegrid_TileGrid_.prototype.getFullTileRange=function(z){if(!this.fullTileRanges_){return null;}else{return this.fullTileRanges_[z];}};/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */_ol_tilegrid_TileGrid_.prototype.getZForResolution=function(resolution,opt_direction){var z=_ol_array_.linearFindNearest(this.resolutions_,resolution,opt_direction||0);return _ol_math_.clamp(z,this.minZoom,this.maxZoom);};/**
 * @param {!ol.Extent} extent Extent for this tile grid.
 * @private
 */_ol_tilegrid_TileGrid_.prototype.calculateTileRanges_=function(extent){var length=this.resolutions_.length;var fullTileRanges=new Array(length);for(var z=this.minZoom;z<length;++z){fullTileRanges[z]=this.getTileRangeForExtentAndZ(extent,z);}this.fullTileRanges_=fullTileRanges;};var _ol_tilegrid_={};/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Default tile grid for the passed projection.
 */_ol_tilegrid_.getForProjection=function(projection){var tileGrid=projection.getDefaultTileGrid();if(!tileGrid){tileGrid=_ol_tilegrid_.createForProjection(projection);projection.setDefaultTileGrid(tileGrid);}return tileGrid;};/**
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCoord} Tile coordinate.
 */_ol_tilegrid_.wrapX=function(tileGrid,tileCoord,projection){var z=tileCoord[0];var center=tileGrid.getTileCoordCenter(tileCoord);var projectionExtent=_ol_tilegrid_.extentFromProjection(projection);if(!_ol_extent_.containsCoordinate(projectionExtent,center)){var worldWidth=_ol_extent_.getWidth(projectionExtent);var worldsAway=Math.ceil((projectionExtent[0]-center[0])/worldWidth);center[0]+=worldWidth*worldsAway;return tileGrid.getTileCoordForCoordAndZ(center,z);}else{return tileCoord;}};/**
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.TOP_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */_ol_tilegrid_.createForExtent=function(extent,opt_maxZoom,opt_tileSize,opt_corner){var corner=opt_corner!==undefined?opt_corner:_ol_extent_Corner_.TOP_LEFT;var resolutions=_ol_tilegrid_.resolutionsFromExtent(extent,opt_maxZoom,opt_tileSize);return new _ol_tilegrid_TileGrid_({extent:extent,origin:_ol_extent_.getCorner(extent,corner),resolutions:resolutions,tileSize:opt_tileSize});};/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {olx.tilegrid.XYZOptions=} opt_options Tile grid options.
 * @return {!ol.tilegrid.TileGrid} Tile grid instance.
 * @api
 */_ol_tilegrid_.createXYZ=function(opt_options){var options=/** @type {olx.tilegrid.TileGridOptions} */{};_ol_obj_.assign(options,opt_options!==undefined?opt_options:/** @type {olx.tilegrid.XYZOptions} */{});if(options.extent===undefined){options.extent=_ol_proj_.get('EPSG:3857').getExtent();}options.resolutions=_ol_tilegrid_.resolutionsFromExtent(options.extent,options.maxZoom,options.tileSize);delete options.maxZoom;return new _ol_tilegrid_TileGrid_(options);};/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */_ol_tilegrid_.resolutionsFromExtent=function(extent,opt_maxZoom,opt_tileSize){var maxZoom=opt_maxZoom!==undefined?opt_maxZoom:_ol_.DEFAULT_MAX_ZOOM;var height=_ol_extent_.getHeight(extent);var width=_ol_extent_.getWidth(extent);var tileSize=_ol_size_.toSize(opt_tileSize!==undefined?opt_tileSize:_ol_.DEFAULT_TILE_SIZE);var maxResolution=Math.max(width/tileSize[0],height/tileSize[1]);var length=maxZoom+1;var resolutions=new Array(length);for(var z=0;z<length;++z){resolutions[z]=maxResolution/Math.pow(2,z);}return resolutions;};/**
 * @param {ol.ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.BOTTOM_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */_ol_tilegrid_.createForProjection=function(projection,opt_maxZoom,opt_tileSize,opt_corner){var extent=_ol_tilegrid_.extentFromProjection(projection);return _ol_tilegrid_.createForExtent(extent,opt_maxZoom,opt_tileSize,opt_corner);};/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {ol.ProjectionLike} projection Projection.
 * @return {ol.Extent} Extent.
 */_ol_tilegrid_.extentFromProjection=function(projection){projection=_ol_proj_.get(projection);var extent=projection.getExtent();if(!extent){var half=180*_ol_proj_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES]/projection.getMetersPerUnit();extent=_ol_extent_.createOrUpdate(-half,-half,half,half);}return extent;};/**
 * @classdesc
 * An attribution for a layer source.
 *
 * Example:
 *
 *     source: new ol.source.OSM({
 *       attributions: [
 *         new ol.Attribution({
 *           html: 'All maps &copy; ' +
 *               '<a href="https://www.opencyclemap.org/">OpenCycleMap</a>'
 *         }),
 *         ol.source.OSM.ATTRIBUTION
 *       ],
 *     ..
 *
 * @constructor
 * @param {olx.AttributionOptions} options Attribution options.
 * @struct
 * @api
 */var _ol_Attribution_=function(options){/**
   * @private
   * @type {string}
   */this.html_=options.html;/**
   * @private
   * @type {Object.<string, Array.<ol.TileRange>>}
   */this.tileRanges_=options.tileRanges?options.tileRanges:null;};/**
 * Get the attribution markup.
 * @return {string} The attribution HTML.
 * @api
 */_ol_Attribution_.prototype.getHTML=function(){return this.html_;};/**
 * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {boolean} Intersects any tile range.
 */_ol_Attribution_.prototype.intersectsAnyTileRange=function(tileRanges,tileGrid,projection){if(!this.tileRanges_){return true;}var i,ii,tileRange,zKey;for(zKey in tileRanges){if(!(zKey in this.tileRanges_)){continue;}tileRange=tileRanges[zKey];var testTileRange;for(i=0,ii=this.tileRanges_[zKey].length;i<ii;++i){testTileRange=this.tileRanges_[zKey][i];if(testTileRange.intersects(tileRange)){return true;}var extentTileRange=tileGrid.getTileRangeForExtentAndZ(_ol_tilegrid_.extentFromProjection(projection),parseInt(zKey,10));var width=extentTileRange.getWidth();if(tileRange.minX<extentTileRange.minX||tileRange.maxX>extentTileRange.maxX){if(testTileRange.intersects(new _ol_TileRange_(_ol_math_.modulo(tileRange.minX,width),_ol_math_.modulo(tileRange.maxX,width),tileRange.minY,tileRange.maxY))){return true;}if(tileRange.getWidth()>width&&testTileRange.intersects(extentTileRange)){return true;}}}}return false;};/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */var _ol_source_State_={UNDEFINED:'undefined',LOADING:'loading',READY:'ready',ERROR:'error'};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link ol.layer.Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {ol.SourceSourceOptions} options Source options.
 * @api
 */var _ol_source_Source_=function(options){_ol_Object_.call(this);/**
   * @private
   * @type {ol.proj.Projection}
   */this.projection_=_ol_proj_.get(options.projection);/**
   * @private
   * @type {Array.<ol.Attribution>}
   */this.attributions_=_ol_source_Source_.toAttributionsArray_(options.attributions);/**
   * @private
   * @type {string|olx.LogoOptions|undefined}
   */this.logo_=options.logo;/**
   * @private
   * @type {ol.source.State}
   */this.state_=options.state!==undefined?options.state:_ol_source_State_.READY;/**
   * @private
   * @type {boolean}
   */this.wrapX_=options.wrapX!==undefined?options.wrapX:false;};_ol_.inherits(_ol_source_Source_,_ol_Object_);/**
 * Turns various ways of defining an attribution to an array of `ol.Attributions`.
 *
 * @param {ol.AttributionLike|undefined}
 *     attributionLike The attributions as string, array of strings,
 *     `ol.Attribution`, array of `ol.Attribution` or undefined.
 * @return {Array.<ol.Attribution>} The array of `ol.Attribution` or null if
 *     `undefined` was given.
 */_ol_source_Source_.toAttributionsArray_=function(attributionLike){if(typeof attributionLike==='string'){return[new _ol_Attribution_({html:attributionLike})];}else if(attributionLike instanceof _ol_Attribution_){return[attributionLike];}else if(Array.isArray(attributionLike)){var len=attributionLike.length;var attributions=new Array(len);for(var i=0;i<len;i++){var item=attributionLike[i];if(typeof item==='string'){attributions[i]=new _ol_Attribution_({html:item});}else{attributions[i]=item;}}return attributions;}else{return null;}};/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @return {T|undefined} Callback result.
 * @template T
 */_ol_source_Source_.prototype.forEachFeatureAtCoordinate=_ol_.nullFunction;/**
 * Get the attributions of the source.
 * @return {Array.<ol.Attribution>} Attributions.
 * @api
 */_ol_source_Source_.prototype.getAttributions=function(){return this.attributions_;};/**
 * Get the logo of the source.
 * @return {string|olx.LogoOptions|undefined} Logo.
 * @api
 */_ol_source_Source_.prototype.getLogo=function(){return this.logo_;};/**
 * Get the projection of the source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */_ol_source_Source_.prototype.getProjection=function(){return this.projection_;};/**
 * @abstract
 * @return {Array.<number>|undefined} Resolutions.
 */_ol_source_Source_.prototype.getResolutions=function(){};/**
 * Get the state of the source, see {@link ol.source.State} for possible states.
 * @return {ol.source.State} State.
 * @api
 */_ol_source_Source_.prototype.getState=function(){return this.state_;};/**
 * @return {boolean|undefined} Wrap X.
 */_ol_source_Source_.prototype.getWrapX=function(){return this.wrapX_;};/**
 * Refreshes the source and finally dispatches a 'change' event.
 * @api
 */_ol_source_Source_.prototype.refresh=function(){this.changed();};/**
 * Set the attributions of the source.
 * @param {ol.AttributionLike|undefined} attributions Attributions.
 *     Can be passed as `string`, `Array<string>`, `{@link ol.Attribution}`,
 *     `Array<{@link ol.Attribution}>` or `undefined`.
 * @api
 */_ol_source_Source_.prototype.setAttributions=function(attributions){this.attributions_=_ol_source_Source_.toAttributionsArray_(attributions);this.changed();};/**
 * Set the logo of the source.
 * @param {string|olx.LogoOptions|undefined} logo Logo.
 */_ol_source_Source_.prototype.setLogo=function(logo){this.logo_=logo;};/**
 * Set the state of the source.
 * @param {ol.source.State} state State.
 * @protected
 */_ol_source_Source_.prototype.setState=function(state){this.state_=state;this.changed();};/**
 * @enum {string}
 */var _ol_source_VectorEventType_={/**
   * Triggered when a feature is added to the source.
   * @event ol.source.Vector.Event#addfeature
   * @api
   */ADDFEATURE:'addfeature',/**
   * Triggered when a feature is updated.
   * @event ol.source.Vector.Event#changefeature
   * @api
   */CHANGEFEATURE:'changefeature',/**
   * Triggered when the clear method is called on the source.
   * @event ol.source.Vector.Event#clear
   * @api
   */CLEAR:'clear',/**
   * Triggered when a feature is removed from the source.
   * See {@link ol.source.Vector#clear source.clear()} for exceptions.
   * @event ol.source.Vector.Event#removefeature
   * @api
   */REMOVEFEATURE:'removefeature'};var index$1=partialSort;// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]
function partialSort(arr,k,left,right,compare){left=left||0;right=right||arr.length-1;compare=compare||defaultCompare;while(right>left){if(right-left>600){var n=right-left+1;var m=k-left+1;var z=Math.log(n);var s=0.5*Math.exp(2*z/3);var sd=0.5*Math.sqrt(z*s*(n-s)/n)*(m-n/2<0?-1:1);var newLeft=Math.max(left,Math.floor(k-m*s/n+sd));var newRight=Math.min(right,Math.floor(k+(n-m)*s/n+sd));partialSort(arr,k,newLeft,newRight,compare);}var t=arr[k];var i=left;var j=right;swap(arr,left,k);if(compare(arr[right],t)>0)swap(arr,left,right);while(i<j){swap(arr,i,j);i++;j--;while(compare(arr[i],t)<0)i++;while(compare(arr[j],t)>0)j--;}if(compare(arr[left],t)===0)swap(arr,left,j);else{j++;swap(arr,j,right);}if(j<=k)left=j+1;if(k<=j)right=j-1;}}function swap(arr,i,j){var tmp=arr[i];arr[i]=arr[j];arr[j]=tmp;}function defaultCompare(a,b){return a<b?-1:a>b?1:0;}var index=rbush;function rbush(maxEntries,format){if(!(this instanceof rbush))return new rbush(maxEntries,format);// max entries in a node is 9 by default; min node fill is 40% for best performance
this._maxEntries=Math.max(4,maxEntries||9);this._minEntries=Math.max(2,Math.ceil(this._maxEntries*0.4));if(format){this._initFormat(format);}this.clear();}rbush.prototype={all:function(){return this._all(this.data,[]);},search:function(bbox){var node=this.data,result=[],toBBox=this.toBBox;if(!intersects(bbox,node))return result;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf)result.push(child);else if(contains(bbox,childBBox))this._all(child,result);else nodesToSearch.push(child);}}node=nodesToSearch.pop();}return result;},collides:function(bbox){var node=this.data,toBBox=this.toBBox;if(!intersects(bbox,node))return false;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf||contains(bbox,childBBox))return true;nodesToSearch.push(child);}}node=nodesToSearch.pop();}return false;},load:function(data){if(!(data&&data.length))return this;if(data.length<this._minEntries){for(var i=0,len=data.length;i<len;i++){this.insert(data[i]);}return this;}// recursively build the tree with the given data from stratch using OMT algorithm
var node=this._build(data.slice(),0,data.length-1,0);if(!this.data.children.length){// save as is if tree is empty
this.data=node;}else if(this.data.height===node.height){// split root if trees have the same height
this._splitRoot(this.data,node);}else{if(this.data.height<node.height){// swap trees if inserted one is bigger
var tmpNode=this.data;this.data=node;node=tmpNode;}// insert the small tree into the large tree at appropriate level
this._insert(node,this.data.height-node.height-1,true);}return this;},insert:function(item){if(item)this._insert(item,this.data.height-1);return this;},clear:function(){this.data=createNode([]);return this;},remove:function(item,equalsFn){if(!item)return this;var node=this.data,bbox=this.toBBox(item),path=[],indexes=[],i,parent,index,goingUp;// depth-first iterative tree traversal
while(node||path.length){if(!node){// go up
node=path.pop();parent=path[path.length-1];i=indexes.pop();goingUp=true;}if(node.leaf){// check current node
index=findItem(item,node.children,equalsFn);if(index!==-1){// item found, remove the item and condense tree upwards
node.children.splice(index,1);path.push(node);this._condense(path);return this;}}if(!goingUp&&!node.leaf&&contains(node,bbox)){// go down
path.push(node);indexes.push(i);i=0;parent=node;node=node.children[0];}else if(parent){// go right
i++;node=parent.children[i];goingUp=false;}else node=null;// nothing found
}return this;},toBBox:function(item){return item;},compareMinX:compareNodeMinX,compareMinY:compareNodeMinY,toJSON:function(){return this.data;},fromJSON:function(data){this.data=data;return this;},_all:function(node,result){var nodesToSearch=[];while(node){if(node.leaf)result.push.apply(result,node.children);else nodesToSearch.push.apply(nodesToSearch,node.children);node=nodesToSearch.pop();}return result;},_build:function(items,left,right,height){var N=right-left+1,M=this._maxEntries,node;if(N<=M){// reached leaf level; return leaf
node=createNode(items.slice(left,right+1));calcBBox(node,this.toBBox);return node;}if(!height){// target height of the bulk-loaded tree
height=Math.ceil(Math.log(N)/Math.log(M));// target number of root entries to maximize storage utilization
M=Math.ceil(N/Math.pow(M,height-1));}node=createNode([]);node.leaf=false;node.height=height;// split the items into M mostly square tiles
var N2=Math.ceil(N/M),N1=N2*Math.ceil(Math.sqrt(M)),i,j,right2,right3;multiSelect(items,left,right,N1,this.compareMinX);for(i=left;i<=right;i+=N1){right2=Math.min(i+N1-1,right);multiSelect(items,i,right2,N2,this.compareMinY);for(j=i;j<=right2;j+=N2){right3=Math.min(j+N2-1,right2);// pack each entry recursively
node.children.push(this._build(items,j,right3,height-1));}}calcBBox(node,this.toBBox);return node;},_chooseSubtree:function(bbox,node,level,path){var i,len,child,targetNode,area,enlargement,minArea,minEnlargement;while(true){path.push(node);if(node.leaf||path.length-1===level)break;minArea=minEnlargement=Infinity;for(i=0,len=node.children.length;i<len;i++){child=node.children[i];area=bboxArea(child);enlargement=enlargedArea(bbox,child)-area;// choose entry with the least area enlargement
if(enlargement<minEnlargement){minEnlargement=enlargement;minArea=area<minArea?area:minArea;targetNode=child;}else if(enlargement===minEnlargement){// otherwise choose one with the smallest area
if(area<minArea){minArea=area;targetNode=child;}}}node=targetNode||node.children[0];}return node;},_insert:function(item,level,isNode){var toBBox=this.toBBox,bbox=isNode?item:toBBox(item),insertPath=[];// find the best node for accommodating the item, saving all nodes along the path too
var node=this._chooseSubtree(bbox,this.data,level,insertPath);// put the item into the node
node.children.push(item);extend(node,bbox);// split on node overflow; propagate upwards if necessary
while(level>=0){if(insertPath[level].children.length>this._maxEntries){this._split(insertPath,level);level--;}else break;}// adjust bboxes along the insertion path
this._adjustParentBBoxes(bbox,insertPath,level);},// split overflowed node into two
_split:function(insertPath,level){var node=insertPath[level],M=node.children.length,m=this._minEntries;this._chooseSplitAxis(node,m,M);var splitIndex=this._chooseSplitIndex(node,m,M);var newNode=createNode(node.children.splice(splitIndex,node.children.length-splitIndex));newNode.height=node.height;newNode.leaf=node.leaf;calcBBox(node,this.toBBox);calcBBox(newNode,this.toBBox);if(level)insertPath[level-1].children.push(newNode);else this._splitRoot(node,newNode);},_splitRoot:function(node,newNode){// split root node
this.data=createNode([node,newNode]);this.data.height=node.height+1;this.data.leaf=false;calcBBox(this.data,this.toBBox);},_chooseSplitIndex:function(node,m,M){var i,bbox1,bbox2,overlap,area,minOverlap,minArea,index;minOverlap=minArea=Infinity;for(i=m;i<=M-m;i++){bbox1=distBBox(node,0,i,this.toBBox);bbox2=distBBox(node,i,M,this.toBBox);overlap=intersectionArea(bbox1,bbox2);area=bboxArea(bbox1)+bboxArea(bbox2);// choose distribution with minimum overlap
if(overlap<minOverlap){minOverlap=overlap;index=i;minArea=area<minArea?area:minArea;}else if(overlap===minOverlap){// otherwise choose distribution with minimum area
if(area<minArea){minArea=area;index=i;}}}return index;},// sorts node children by the best axis for split
_chooseSplitAxis:function(node,m,M){var compareMinX=node.leaf?this.compareMinX:compareNodeMinX,compareMinY=node.leaf?this.compareMinY:compareNodeMinY,xMargin=this._allDistMargin(node,m,M,compareMinX),yMargin=this._allDistMargin(node,m,M,compareMinY);// if total distributions margin value is minimal for x, sort by minX,
// otherwise it's already sorted by minY
if(xMargin<yMargin)node.children.sort(compareMinX);},// total margin of all possible split distributions where each node is at least m full
_allDistMargin:function(node,m,M,compare){node.children.sort(compare);var toBBox=this.toBBox,leftBBox=distBBox(node,0,m,toBBox),rightBBox=distBBox(node,M-m,M,toBBox),margin=bboxMargin(leftBBox)+bboxMargin(rightBBox),i,child;for(i=m;i<M-m;i++){child=node.children[i];extend(leftBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(leftBBox);}for(i=M-m-1;i>=m;i--){child=node.children[i];extend(rightBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(rightBBox);}return margin;},_adjustParentBBoxes:function(bbox,path,level){// adjust bboxes along the given tree path
for(var i=level;i>=0;i--){extend(path[i],bbox);}},_condense:function(path){// go through the path, removing empty nodes and updating bboxes
for(var i=path.length-1,siblings;i>=0;i--){if(path[i].children.length===0){if(i>0){siblings=path[i-1].children;siblings.splice(siblings.indexOf(path[i]),1);}else this.clear();}else calcBBox(path[i],this.toBBox);}},_initFormat:function(format){// data format (minX, minY, maxX, maxY accessors)
// uses eval-type function compilation instead of just accepting a toBBox function
// because the algorithms are very sensitive to sorting functions performance,
// so they should be dead simple and without inner calls
var compareArr=['return a',' - b',';'];this.compareMinX=new Function('a','b',compareArr.join(format[0]));this.compareMinY=new Function('a','b',compareArr.join(format[1]));this.toBBox=new Function('a','return {minX: a'+format[0]+', minY: a'+format[1]+', maxX: a'+format[2]+', maxY: a'+format[3]+'};');}};function findItem(item,items,equalsFn){if(!equalsFn)return items.indexOf(item);for(var i=0;i<items.length;i++){if(equalsFn(item,items[i]))return i;}return-1;}// calculate node's bbox from bboxes of its children
function calcBBox(node,toBBox){distBBox(node,0,node.children.length,toBBox,node);}// min bounding rectangle of node children from k to p-1
function distBBox(node,k,p,toBBox,destNode){if(!destNode)destNode=createNode(null);destNode.minX=Infinity;destNode.minY=Infinity;destNode.maxX=-Infinity;destNode.maxY=-Infinity;for(var i=k,child;i<p;i++){child=node.children[i];extend(destNode,node.leaf?toBBox(child):child);}return destNode;}function extend(a,b){a.minX=Math.min(a.minX,b.minX);a.minY=Math.min(a.minY,b.minY);a.maxX=Math.max(a.maxX,b.maxX);a.maxY=Math.max(a.maxY,b.maxY);return a;}function compareNodeMinX(a,b){return a.minX-b.minX;}function compareNodeMinY(a,b){return a.minY-b.minY;}function bboxArea(a){return(a.maxX-a.minX)*(a.maxY-a.minY);}function bboxMargin(a){return a.maxX-a.minX+(a.maxY-a.minY);}function enlargedArea(a,b){return(Math.max(b.maxX,a.maxX)-Math.min(b.minX,a.minX))*(Math.max(b.maxY,a.maxY)-Math.min(b.minY,a.minY));}function intersectionArea(a,b){var minX=Math.max(a.minX,b.minX),minY=Math.max(a.minY,b.minY),maxX=Math.min(a.maxX,b.maxX),maxY=Math.min(a.maxY,b.maxY);return Math.max(0,maxX-minX)*Math.max(0,maxY-minY);}function contains(a,b){return a.minX<=b.minX&&a.minY<=b.minY&&b.maxX<=a.maxX&&b.maxY<=a.maxY;}function intersects(a,b){return b.minX<=a.maxX&&b.minY<=a.maxY&&b.maxX>=a.minX&&b.maxY>=a.minY;}function createNode(children){return{children:children,height:1,leaf:true,minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity};}// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach
function multiSelect(arr,left,right,n,compare){var stack=[left,right],mid;while(stack.length){right=stack.pop();left=stack.pop();if(right-left<=n)continue;mid=left+Math.ceil((right-left)/n/2)*n;index$1(arr,mid,left,right,compare);stack.push(left,mid,mid,right);}}/**
 * Wrapper around the RBush by Vladimir Agafonkin.
 *
 * @constructor
 * @param {number=} opt_maxEntries Max entries.
 * @see https://github.com/mourner/rbush
 * @struct
 * @template T
 */var _ol_structs_RBush_=function(opt_maxEntries){/**
   * @private
   */this.rbush_=index(opt_maxEntries);/**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object.<number, ol.RBushEntry>}
   */this.items_={};};/**
 * Insert a value into the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */_ol_structs_RBush_.prototype.insert=function(extent,value){/** @type {ol.RBushEntry} */var item={minX:extent[0],minY:extent[1],maxX:extent[2],maxY:extent[3],value:value};this.rbush_.insert(item);this.items_[_ol_.getUid(value)]=item;};/**
 * Bulk-insert values into the RBush.
 * @param {Array.<ol.Extent>} extents Extents.
 * @param {Array.<T>} values Values.
 */_ol_structs_RBush_.prototype.load=function(extents,values){var items=new Array(values.length);for(var i=0,l=values.length;i<l;i++){var extent=extents[i];var value=values[i];/** @type {ol.RBushEntry} */var item={minX:extent[0],minY:extent[1],maxX:extent[2],maxY:extent[3],value:value};items[i]=item;this.items_[_ol_.getUid(value)]=item;}this.rbush_.load(items);};/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */_ol_structs_RBush_.prototype.remove=function(value){var uid=_ol_.getUid(value);// get the object in which the value was wrapped when adding to the
// internal rbush. then use that object to do the removal.
var item=this.items_[uid];delete this.items_[uid];return this.rbush_.remove(item)!==null;};/**
 * Update the extent of a value in the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */_ol_structs_RBush_.prototype.update=function(extent,value){var item=this.items_[_ol_.getUid(value)];var bbox=[item.minX,item.minY,item.maxX,item.maxY];if(!_ol_extent_.equals(bbox,extent)){this.remove(value);this.insert(extent,value);}};/**
 * Return all values in the RBush.
 * @return {Array.<T>} All.
 */_ol_structs_RBush_.prototype.getAll=function(){var items=this.rbush_.all();return items.map(function(item){return item.value;});};/**
 * Return all values in the given extent.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<T>} All in extent.
 */_ol_structs_RBush_.prototype.getInExtent=function(extent){/** @type {ol.RBushEntry} */var bbox={minX:extent[0],minY:extent[1],maxX:extent[2],maxY:extent[3]};var items=this.rbush_.search(bbox);return items.map(function(item){return item.value;});};/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */_ol_structs_RBush_.prototype.forEach=function(callback,opt_this){return this.forEach_(this.getAll(),callback,opt_this);};/**
 * Calls a callback function with each value in the provided extent.
 * @param {ol.Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */_ol_structs_RBush_.prototype.forEachInExtent=function(extent,callback,opt_this){return this.forEach_(this.getInExtent(extent),callback,opt_this);};/**
 * @param {Array.<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */_ol_structs_RBush_.prototype.forEach_=function(values,callback,opt_this){var result;for(var i=0,l=values.length;i<l;i++){result=callback.call(opt_this,values[i]);if(result){return result;}}return result;};/**
 * @return {boolean} Is empty.
 */_ol_structs_RBush_.prototype.isEmpty=function(){return _ol_obj_.isEmpty(this.items_);};/**
 * Remove all values from the RBush.
 */_ol_structs_RBush_.prototype.clear=function(){this.rbush_.clear();this.items_={};};/**
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */_ol_structs_RBush_.prototype.getExtent=function(opt_extent){// FIXME add getExtent() to rbush
var data=this.rbush_.data;return _ol_extent_.createOrUpdate(data.minX,data.minY,data.maxX,data.maxY,opt_extent);};/**
 * @param {ol.structs.RBush} rbush R-Tree.
 */_ol_structs_RBush_.prototype.concat=function(rbush){this.rbush_.load(rbush.rbush_.all());for(var i in rbush.items_){this.items_[i|0]=rbush.items_[i|0];}};// FIXME bulk feature upload - suppress events
// FIXME make change-detection more refined (notably, geometry hint)
/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link ol.source.VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @constructor
 * @extends {ol.source.Source}
 * @fires ol.source.Vector.Event
 * @param {olx.source.VectorOptions=} opt_options Vector source options.
 * @api
 */var _ol_source_Vector_=function(opt_options){var options=opt_options||{};_ol_source_Source_.call(this,{attributions:options.attributions,logo:options.logo,projection:undefined,state:_ol_source_State_.READY,wrapX:options.wrapX!==undefined?options.wrapX:true});/**
   * @private
   * @type {ol.FeatureLoader}
   */this.loader_=_ol_.nullFunction;/**
   * @private
   * @type {ol.format.Feature|undefined}
   */this.format_=options.format;/**
   * @private
   * @type {boolean}
   */this.overlaps_=options.overlaps==undefined?true:options.overlaps;/**
   * @private
   * @type {string|ol.FeatureUrlFunction|undefined}
   */this.url_=options.url;if(options.loader!==undefined){this.loader_=options.loader;}else if(this.url_!==undefined){_ol_asserts_.assert(this.format_,7);// `format` must be set when `url` is set
// create a XHR feature loader for "url" and "format"
this.loader_=_ol_featureloader_.xhr(this.url_,/** @type {ol.format.Feature} */this.format_);}/**
   * @private
   * @type {ol.LoadingStrategy}
   */this.strategy_=options.strategy!==undefined?options.strategy:_ol_loadingstrategy_.all;var useSpatialIndex=options.useSpatialIndex!==undefined?options.useSpatialIndex:true;/**
   * @private
   * @type {ol.structs.RBush.<ol.Feature>}
   */this.featuresRtree_=useSpatialIndex?new _ol_structs_RBush_():null;/**
   * @private
   * @type {ol.structs.RBush.<{extent: ol.Extent}>}
   */this.loadedExtentsRtree_=new _ol_structs_RBush_();/**
   * @private
   * @type {Object.<string, ol.Feature>}
   */this.nullGeometryFeatures_={};/**
   * A lookup of features by id (the return from feature.getId()).
   * @private
   * @type {Object.<string, ol.Feature>}
   */this.idIndex_={};/**
   * A lookup of features without id (keyed by ol.getUid(feature)).
   * @private
   * @type {Object.<string, ol.Feature>}
   */this.undefIdIndex_={};/**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */this.featureChangeKeys_={};/**
   * @private
   * @type {ol.Collection.<ol.Feature>}
   */this.featuresCollection_=null;var collection,features;if(options.features instanceof _ol_Collection_){collection=options.features;features=collection.getArray();}else if(Array.isArray(options.features)){features=options.features;}if(!useSpatialIndex&&collection===undefined){collection=new _ol_Collection_(features);}if(features!==undefined){this.addFeaturesInternal(features);}if(collection!==undefined){this.bindFeaturesCollection_(collection);}};_ol_.inherits(_ol_source_Vector_,_ol_source_Source_);/**
 * Add a single feature to the source.  If you want to add a batch of features
 * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}
 * instead. A feature will not be added to the source if feature with
 * the same id is already there. The reason for this behavior is to avoid
 * feature duplication when using bbox or tile loading strategies.
 * @param {ol.Feature} feature Feature to add.
 * @api
 */_ol_source_Vector_.prototype.addFeature=function(feature){this.addFeatureInternal(feature);this.changed();};/**
 * Add a feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */_ol_source_Vector_.prototype.addFeatureInternal=function(feature){var featureKey=_ol_.getUid(feature).toString();if(!this.addToIndex_(featureKey,feature)){return;}this.setupChangeEvents_(featureKey,feature);var geometry=feature.getGeometry();if(geometry){var extent=geometry.getExtent();if(this.featuresRtree_){this.featuresRtree_.insert(extent,feature);}}else{this.nullGeometryFeatures_[featureKey]=feature;}this.dispatchEvent(new _ol_source_Vector_.Event(_ol_source_VectorEventType_.ADDFEATURE,feature));};/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @private
 */_ol_source_Vector_.prototype.setupChangeEvents_=function(featureKey,feature){this.featureChangeKeys_[featureKey]=[_ol_events_.listen(feature,_ol_events_EventType_.CHANGE,this.handleFeatureChange_,this),_ol_events_.listen(feature,_ol_ObjectEventType_.PROPERTYCHANGE,this.handleFeatureChange_,this)];};/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} The feature is "valid", in the sense that it is also a
 *     candidate for insertion into the Rtree.
 * @private
 */_ol_source_Vector_.prototype.addToIndex_=function(featureKey,feature){var valid=true;var id=feature.getId();if(id!==undefined){if(!(id.toString()in this.idIndex_)){this.idIndex_[id.toString()]=feature;}else{valid=false;}}else{_ol_asserts_.assert(!(featureKey in this.undefIdIndex_),30);// The passed `feature` was already added to the source
this.undefIdIndex_[featureKey]=feature;}return valid;};/**
 * Add a batch of features to the source.
 * @param {Array.<ol.Feature>} features Features to add.
 * @api
 */_ol_source_Vector_.prototype.addFeatures=function(features){this.addFeaturesInternal(features);this.changed();};/**
 * Add features without firing a `change` event.
 * @param {Array.<ol.Feature>} features Features.
 * @protected
 */_ol_source_Vector_.prototype.addFeaturesInternal=function(features){var featureKey,i,length,feature;var extents=[];var newFeatures=[];var geometryFeatures=[];for(i=0,length=features.length;i<length;i++){feature=features[i];featureKey=_ol_.getUid(feature).toString();if(this.addToIndex_(featureKey,feature)){newFeatures.push(feature);}}for(i=0,length=newFeatures.length;i<length;i++){feature=newFeatures[i];featureKey=_ol_.getUid(feature).toString();this.setupChangeEvents_(featureKey,feature);var geometry=feature.getGeometry();if(geometry){var extent=geometry.getExtent();extents.push(extent);geometryFeatures.push(feature);}else{this.nullGeometryFeatures_[featureKey]=feature;}}if(this.featuresRtree_){this.featuresRtree_.load(extents,geometryFeatures);}for(i=0,length=newFeatures.length;i<length;i++){this.dispatchEvent(new _ol_source_Vector_.Event(_ol_source_VectorEventType_.ADDFEATURE,newFeatures[i]));}};/**
 * @param {!ol.Collection.<ol.Feature>} collection Collection.
 * @private
 */_ol_source_Vector_.prototype.bindFeaturesCollection_=function(collection){var modifyingCollection=false;_ol_events_.listen(this,_ol_source_VectorEventType_.ADDFEATURE,function(evt){if(!modifyingCollection){modifyingCollection=true;collection.push(evt.feature);modifyingCollection=false;}});_ol_events_.listen(this,_ol_source_VectorEventType_.REMOVEFEATURE,function(evt){if(!modifyingCollection){modifyingCollection=true;collection.remove(evt.feature);modifyingCollection=false;}});_ol_events_.listen(collection,_ol_CollectionEventType_.ADD,function(evt){if(!modifyingCollection){modifyingCollection=true;this.addFeature(/** @type {ol.Feature} */evt.element);modifyingCollection=false;}},this);_ol_events_.listen(collection,_ol_CollectionEventType_.REMOVE,function(evt){if(!modifyingCollection){modifyingCollection=true;this.removeFeature(/** @type {ol.Feature} */evt.element);modifyingCollection=false;}},this);this.featuresCollection_=collection;};/**
 * Remove all features from the source.
 * @param {boolean=} opt_fast Skip dispatching of {@link removefeature} events.
 * @api
 */_ol_source_Vector_.prototype.clear=function(opt_fast){if(opt_fast){for(var featureId in this.featureChangeKeys_){var keys=this.featureChangeKeys_[featureId];keys.forEach(_ol_events_.unlistenByKey);}if(!this.featuresCollection_){this.featureChangeKeys_={};this.idIndex_={};this.undefIdIndex_={};}}else{if(this.featuresRtree_){this.featuresRtree_.forEach(this.removeFeatureInternal,this);for(var id in this.nullGeometryFeatures_){this.removeFeatureInternal(this.nullGeometryFeatures_[id]);}}}if(this.featuresCollection_){this.featuresCollection_.clear();}if(this.featuresRtree_){this.featuresRtree_.clear();}this.loadedExtentsRtree_.clear();this.nullGeometryFeatures_={};var clearEvent=new _ol_source_Vector_.Event(_ol_source_VectorEventType_.CLEAR);this.dispatchEvent(clearEvent);this.changed();};/**
 * Iterate through all features on the source, calling the provided callback
 * with each one.  If the callback returns any "truthy" value, iteration will
 * stop and the function will return the same value.
 *
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     on the source.  Return a truthy value to stop iteration.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */_ol_source_Vector_.prototype.forEachFeature=function(callback,opt_this){if(this.featuresRtree_){return this.featuresRtree_.forEach(callback,opt_this);}else if(this.featuresCollection_){return this.featuresCollection_.forEach(callback,opt_this);}};/**
 * Iterate through all features whose geometries contain the provided
 * coordinate, calling the callback with each feature.  If the callback returns
 * a "truthy" value, iteration will stop and the function will return the same
 * value.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose goemetry contains the provided coordinate.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 */_ol_source_Vector_.prototype.forEachFeatureAtCoordinateDirect=function(coordinate,callback,opt_this){var extent=[coordinate[0],coordinate[1],coordinate[0],coordinate[1]];return this.forEachFeatureInExtent(extent,function(feature){var geometry=feature.getGeometry();if(geometry.intersectsCoordinate(coordinate)){return callback.call(opt_this,feature);}else{return undefined;}});};/**
 * Iterate through all features whose bounding box intersects the provided
 * extent (note that the feature's geometry may not intersect the extent),
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you are interested in features whose geometry intersects an extent, call
 * the {@link ol.source.Vector#forEachFeatureIntersectingExtent
 * source.forEachFeatureIntersectingExtent()} method instead.
 *
 * When `useSpatialIndex` is set to false, this method will loop through all
 * features, equivalent to {@link ol.source.Vector#forEachFeature}.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose bounding box intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */_ol_source_Vector_.prototype.forEachFeatureInExtent=function(extent,callback,opt_this){if(this.featuresRtree_){return this.featuresRtree_.forEachInExtent(extent,callback,opt_this);}else if(this.featuresCollection_){return this.featuresCollection_.forEach(callback,opt_this);}};/**
 * Iterate through all features whose geometry intersects the provided extent,
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you only want to test for bounding box intersection, call the
 * {@link ol.source.Vector#forEachFeatureInExtent
 * source.forEachFeatureInExtent()} method instead.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose geometry intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */_ol_source_Vector_.prototype.forEachFeatureIntersectingExtent=function(extent,callback,opt_this){return this.forEachFeatureInExtent(extent,/**
       * @param {ol.Feature} feature Feature.
       * @return {S|undefined} The return value from the last call to the callback.
       * @template S
       */function(feature){var geometry=feature.getGeometry();if(geometry.intersectsExtent(extent)){var result=callback.call(opt_this,feature);if(result){return result;}}});};/**
 * Get the features collection associated with this source. Will be `null`
 * unless the source was configured with `useSpatialIndex` set to `false`, or
 * with an {@link ol.Collection} as `features`.
 * @return {ol.Collection.<ol.Feature>} The collection of features.
 * @api
 */_ol_source_Vector_.prototype.getFeaturesCollection=function(){return this.featuresCollection_;};/**
 * Get all features on the source in random order.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */_ol_source_Vector_.prototype.getFeatures=function(){var features;if(this.featuresCollection_){features=this.featuresCollection_.getArray();}else if(this.featuresRtree_){features=this.featuresRtree_.getAll();if(!_ol_obj_.isEmpty(this.nullGeometryFeatures_)){_ol_array_.extend(features,_ol_obj_.getValues(this.nullGeometryFeatures_));}}return(/** @type {Array.<ol.Feature>} */features);};/**
 * Get all features whose geometry intersects the provided coordinate.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */_ol_source_Vector_.prototype.getFeaturesAtCoordinate=function(coordinate){var features=[];this.forEachFeatureAtCoordinateDirect(coordinate,function(feature){features.push(feature);});return features;};/**
 * Get all features in the provided extent.  Note that this returns an array of
 * all features intersecting the given extent in random order (so it may include
 * features whose geometries do not intersect the extent).
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */_ol_source_Vector_.prototype.getFeaturesInExtent=function(extent){return this.featuresRtree_.getInExtent(extent);};/**
 * Get the closest feature to the provided coordinate.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(ol.Feature):boolean=} opt_filter Feature filter function.
 *     The filter function will receive one argument, the {@link ol.Feature feature}
 *     and it should return a boolean value. By default, no filtering is made.
 * @return {ol.Feature} Closest feature.
 * @api
 */_ol_source_Vector_.prototype.getClosestFeatureToCoordinate=function(coordinate,opt_filter){// Find the closest feature using branch and bound.  We start searching an
// infinite extent, and find the distance from the first feature found.  This
// becomes the closest feature.  We then compute a smaller extent which any
// closer feature must intersect.  We continue searching with this smaller
// extent, trying to find a closer feature.  Every time we find a closer
// feature, we update the extent being searched so that any even closer
// feature must intersect it.  We continue until we run out of features.
var x=coordinate[0];var y=coordinate[1];var closestFeature=null;var closestPoint=[NaN,NaN];var minSquaredDistance=Infinity;var extent=[-Infinity,-Infinity,Infinity,Infinity];var filter=opt_filter?opt_filter:_ol_functions_.TRUE;this.featuresRtree_.forEachInExtent(extent,/**
       * @param {ol.Feature} feature Feature.
       */function(feature){if(filter(feature)){var geometry=feature.getGeometry();var previousMinSquaredDistance=minSquaredDistance;minSquaredDistance=geometry.closestPointXY(x,y,closestPoint,minSquaredDistance);if(minSquaredDistance<previousMinSquaredDistance){closestFeature=feature;// This is sneaky.  Reduce the extent that it is currently being
// searched while the R-Tree traversal using this same extent object
// is still in progress.  This is safe because the new extent is
// strictly contained by the old extent.
var minDistance=Math.sqrt(minSquaredDistance);extent[0]=x-minDistance;extent[1]=y-minDistance;extent[2]=x+minDistance;extent[3]=y+minDistance;}}});return closestFeature;};/**
 * Get the extent of the features currently in the source.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent=} opt_extent Destination extent. If provided, no new extent
 *     will be created. Instead, that extent's coordinates will be overwritten.
 * @return {ol.Extent} Extent.
 * @api
 */_ol_source_Vector_.prototype.getExtent=function(opt_extent){return this.featuresRtree_.getExtent(opt_extent);};/**
 * Get a feature by its identifier (the value returned by feature.getId()).
 * Note that the index treats string and numeric identifiers as the same.  So
 * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
 *
 * @param {string|number} id Feature identifier.
 * @return {ol.Feature} The feature (or `null` if not found).
 * @api
 */_ol_source_Vector_.prototype.getFeatureById=function(id){var feature=this.idIndex_[id.toString()];return feature!==undefined?feature:null;};/**
 * Get the format associated with this source.
 *
 * @return {ol.format.Feature|undefined} The feature format.
 * @api
 */_ol_source_Vector_.prototype.getFormat=function(){return this.format_;};/**
 * @return {boolean} The source can have overlapping geometries.
 */_ol_source_Vector_.prototype.getOverlaps=function(){return this.overlaps_;};/**
 * @override
 */_ol_source_Vector_.prototype.getResolutions=function(){};/**
 * Get the url associated with this source.
 *
 * @return {string|ol.FeatureUrlFunction|undefined} The url.
 * @api
 */_ol_source_Vector_.prototype.getUrl=function(){return this.url_;};/**
 * @param {ol.events.Event} event Event.
 * @private
 */_ol_source_Vector_.prototype.handleFeatureChange_=function(event){var feature=/** @type {ol.Feature} */event.target;var featureKey=_ol_.getUid(feature).toString();var geometry=feature.getGeometry();if(!geometry){if(!(featureKey in this.nullGeometryFeatures_)){if(this.featuresRtree_){this.featuresRtree_.remove(feature);}this.nullGeometryFeatures_[featureKey]=feature;}}else{var extent=geometry.getExtent();if(featureKey in this.nullGeometryFeatures_){delete this.nullGeometryFeatures_[featureKey];if(this.featuresRtree_){this.featuresRtree_.insert(extent,feature);}}else{if(this.featuresRtree_){this.featuresRtree_.update(extent,feature);}}}var id=feature.getId();if(id!==undefined){var sid=id.toString();if(featureKey in this.undefIdIndex_){delete this.undefIdIndex_[featureKey];this.idIndex_[sid]=feature;}else{if(this.idIndex_[sid]!==feature){this.removeFromIdIndex_(feature);this.idIndex_[sid]=feature;}}}else{if(!(featureKey in this.undefIdIndex_)){this.removeFromIdIndex_(feature);this.undefIdIndex_[featureKey]=feature;}}this.changed();this.dispatchEvent(new _ol_source_Vector_.Event(_ol_source_VectorEventType_.CHANGEFEATURE,feature));};/**
 * @return {boolean} Is empty.
 */_ol_source_Vector_.prototype.isEmpty=function(){return this.featuresRtree_.isEmpty()&&_ol_obj_.isEmpty(this.nullGeometryFeatures_);};/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 */_ol_source_Vector_.prototype.loadFeatures=function(extent,resolution,projection){var loadedExtentsRtree=this.loadedExtentsRtree_;var extentsToLoad=this.strategy_(extent,resolution);var i,ii;for(i=0,ii=extentsToLoad.length;i<ii;++i){var extentToLoad=extentsToLoad[i];var alreadyLoaded=loadedExtentsRtree.forEachInExtent(extentToLoad,/**
         * @param {{extent: ol.Extent}} object Object.
         * @return {boolean} Contains.
         */function(object){return _ol_extent_.containsExtent(object.extent,extentToLoad);});if(!alreadyLoaded){this.loader_.call(this,extentToLoad,resolution,projection);loadedExtentsRtree.insert(extentToLoad,{extent:extentToLoad.slice()});}}};/**
 * Remove a single feature from the source.  If you want to remove all features
 * at once, use the {@link ol.source.Vector#clear source.clear()} method
 * instead.
 * @param {ol.Feature} feature Feature to remove.
 * @api
 */_ol_source_Vector_.prototype.removeFeature=function(feature){var featureKey=_ol_.getUid(feature).toString();if(featureKey in this.nullGeometryFeatures_){delete this.nullGeometryFeatures_[featureKey];}else{if(this.featuresRtree_){this.featuresRtree_.remove(feature);}}this.removeFeatureInternal(feature);this.changed();};/**
 * Remove feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */_ol_source_Vector_.prototype.removeFeatureInternal=function(feature){var featureKey=_ol_.getUid(feature).toString();this.featureChangeKeys_[featureKey].forEach(_ol_events_.unlistenByKey);delete this.featureChangeKeys_[featureKey];var id=feature.getId();if(id!==undefined){delete this.idIndex_[id.toString()];}else{delete this.undefIdIndex_[featureKey];}this.dispatchEvent(new _ol_source_Vector_.Event(_ol_source_VectorEventType_.REMOVEFEATURE,feature));};/**
 * Remove a feature from the id index.  Called internally when the feature id
 * may have changed.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} Removed the feature from the index.
 * @private
 */_ol_source_Vector_.prototype.removeFromIdIndex_=function(feature){var removed=false;for(var id in this.idIndex_){if(this.idIndex_[id]===feature){delete this.idIndex_[id];removed=true;break;}}return removed;};/**
 * @classdesc
 * Events emitted by {@link ol.source.Vector} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Vector.Event}
 * @param {string} type Type.
 * @param {ol.Feature=} opt_feature Feature.
 */_ol_source_Vector_.Event=function(type,opt_feature){_ol_events_Event_.call(this,type);/**
   * The feature being added or removed.
   * @type {ol.Feature|undefined}
   * @api
   */this.feature=opt_feature;};_ol_.inherits(_ol_source_Vector_.Event,_ol_events_Event_);/**
 * @enum {string}
 */var _ol_layer_Property_={OPACITY:'opacity',VISIBLE:'visible',EXTENT:'extent',Z_INDEX:'zIndex',MAX_RESOLUTION:'maxResolution',MIN_RESOLUTION:'minResolution',SOURCE:'source'};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with `ol.layer.Base` and all its subclasses, any property set in
 * the options is set as a {@link ol.Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {olx.layer.BaseOptions} options Layer options.
 * @api
 */var _ol_layer_Base_=function(options){_ol_Object_.call(this);/**
   * @type {Object.<string, *>}
   */var properties=_ol_obj_.assign({},options);properties[_ol_layer_Property_.OPACITY]=options.opacity!==undefined?options.opacity:1;properties[_ol_layer_Property_.VISIBLE]=options.visible!==undefined?options.visible:true;properties[_ol_layer_Property_.Z_INDEX]=options.zIndex!==undefined?options.zIndex:0;properties[_ol_layer_Property_.MAX_RESOLUTION]=options.maxResolution!==undefined?options.maxResolution:Infinity;properties[_ol_layer_Property_.MIN_RESOLUTION]=options.minResolution!==undefined?options.minResolution:0;this.setProperties(properties);/**
   * @type {ol.LayerState}
   * @private
   */this.state_=/** @type {ol.LayerState} */{layer:/** @type {ol.layer.Layer} */this,managed:true};};_ol_.inherits(_ol_layer_Base_,_ol_Object_);/**
 * Create a renderer for this layer.
 * @abstract
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @return {ol.renderer.Layer} A layer renderer.
 */_ol_layer_Base_.prototype.createRenderer=function(mapRenderer){};/**
 * @return {ol.LayerState} Layer state.
 */_ol_layer_Base_.prototype.getLayerState=function(){this.state_.opacity=_ol_math_.clamp(this.getOpacity(),0,1);this.state_.sourceState=this.getSourceState();this.state_.visible=this.getVisible();this.state_.extent=this.getExtent();this.state_.zIndex=this.getZIndex();this.state_.maxResolution=this.getMaxResolution();this.state_.minResolution=Math.max(this.getMinResolution(),0);return this.state_;};/**
 * @abstract
 * @param {Array.<ol.layer.Layer>=} opt_array Array of layers (to be
 *     modified in place).
 * @return {Array.<ol.layer.Layer>} Array of layers.
 */_ol_layer_Base_.prototype.getLayersArray=function(opt_array){};/**
 * @abstract
 * @param {Array.<ol.LayerState>=} opt_states Optional list of layer
 *     states (to be modified in place).
 * @return {Array.<ol.LayerState>} List of layer states.
 */_ol_layer_Base_.prototype.getLayerStatesArray=function(opt_states){};/**
 * Return the {@link ol.Extent extent} of the layer or `undefined` if it
 * will be visible regardless of extent.
 * @return {ol.Extent|undefined} The layer extent.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.getExtent=function(){return(/** @type {ol.Extent|undefined} */this.get(_ol_layer_Property_.EXTENT));};/**
 * Return the maximum resolution of the layer.
 * @return {number} The maximum resolution of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.getMaxResolution=function(){return(/** @type {number} */this.get(_ol_layer_Property_.MAX_RESOLUTION));};/**
 * Return the minimum resolution of the layer.
 * @return {number} The minimum resolution of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.getMinResolution=function(){return(/** @type {number} */this.get(_ol_layer_Property_.MIN_RESOLUTION));};/**
 * Return the opacity of the layer (between 0 and 1).
 * @return {number} The opacity of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.getOpacity=function(){return(/** @type {number} */this.get(_ol_layer_Property_.OPACITY));};/**
 * @abstract
 * @return {ol.source.State} Source state.
 */_ol_layer_Base_.prototype.getSourceState=function(){};/**
 * Return the visibility of the layer (`true` or `false`).
 * @return {boolean} The visibility of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.getVisible=function(){return(/** @type {boolean} */this.get(_ol_layer_Property_.VISIBLE));};/**
 * Return the Z-index of the layer, which is used to order layers before
 * rendering. The default Z-index is 0.
 * @return {number} The Z-index of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.getZIndex=function(){return(/** @type {number} */this.get(_ol_layer_Property_.Z_INDEX));};/**
 * Set the extent at which the layer is visible.  If `undefined`, the layer
 * will be visible at all extents.
 * @param {ol.Extent|undefined} extent The extent of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.setExtent=function(extent){this.set(_ol_layer_Property_.EXTENT,extent);};/**
 * Set the maximum resolution at which the layer is visible.
 * @param {number} maxResolution The maximum resolution of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.setMaxResolution=function(maxResolution){this.set(_ol_layer_Property_.MAX_RESOLUTION,maxResolution);};/**
 * Set the minimum resolution at which the layer is visible.
 * @param {number} minResolution The minimum resolution of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.setMinResolution=function(minResolution){this.set(_ol_layer_Property_.MIN_RESOLUTION,minResolution);};/**
 * Set the opacity of the layer, allowed values range from 0 to 1.
 * @param {number} opacity The opacity of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.setOpacity=function(opacity){this.set(_ol_layer_Property_.OPACITY,opacity);};/**
 * Set the visibility of the layer (`true` or `false`).
 * @param {boolean} visible The visibility of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.setVisible=function(visible){this.set(_ol_layer_Property_.VISIBLE,visible);};/**
 * Set Z-index of the layer, which is used to order layers before rendering.
 * The default Z-index is 0.
 * @param {number} zindex The z-index of the layer.
 * @observable
 * @api
 */_ol_layer_Base_.prototype.setZIndex=function(zindex){this.set(_ol_layer_Property_.Z_INDEX,zindex);};/**
 * @enum {string}
 */var _ol_render_EventType_={/**
   * @event ol.render.Event#postcompose
   * @api
   */POSTCOMPOSE:'postcompose',/**
   * @event ol.render.Event#precompose
   * @api
   */PRECOMPOSE:'precompose',/**
   * @event ol.render.Event#render
   * @api
   */RENDER:'render'};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link ol.Map#addLayer}. Components
 * like {@link ol.interaction.Select} use unmanaged layers internally. These
 * unmanaged layers are associated with the map using
 * {@link ol.layer.Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.layer.Base}
 * @fires ol.render.Event
 * @param {olx.layer.LayerOptions} options Layer options.
 * @api
 */var _ol_layer_Layer_=function(options){var baseOptions=_ol_obj_.assign({},options);delete baseOptions.source;_ol_layer_Base_.call(this,/** @type {olx.layer.BaseOptions} */baseOptions);/**
   * @private
   * @type {?ol.EventsKey}
   */this.mapPrecomposeKey_=null;/**
   * @private
   * @type {?ol.EventsKey}
   */this.mapRenderKey_=null;/**
   * @private
   * @type {?ol.EventsKey}
   */this.sourceChangeKey_=null;if(options.map){this.setMap(options.map);}_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_layer_Property_.SOURCE),this.handleSourcePropertyChange_,this);var source=options.source?options.source:null;this.setSource(source);};_ol_.inherits(_ol_layer_Layer_,_ol_layer_Base_);/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */_ol_layer_Layer_.visibleAtResolution=function(layerState,resolution){return layerState.visible&&resolution>=layerState.minResolution&&resolution<layerState.maxResolution;};/**
 * @inheritDoc
 */_ol_layer_Layer_.prototype.getLayersArray=function(opt_array){var array=opt_array?opt_array:[];array.push(this);return array;};/**
 * @inheritDoc
 */_ol_layer_Layer_.prototype.getLayerStatesArray=function(opt_states){var states=opt_states?opt_states:[];states.push(this.getLayerState());return states;};/**
 * Get the layer source.
 * @return {ol.source.Source} The layer source (or `null` if not yet set).
 * @observable
 * @api
 */_ol_layer_Layer_.prototype.getSource=function(){var source=this.get(_ol_layer_Property_.SOURCE);return(/** @type {ol.source.Source} */source||null);};/**
  * @inheritDoc
  */_ol_layer_Layer_.prototype.getSourceState=function(){var source=this.getSource();return!source?_ol_source_State_.UNDEFINED:source.getState();};/**
 * @private
 */_ol_layer_Layer_.prototype.handleSourceChange_=function(){this.changed();};/**
 * @private
 */_ol_layer_Layer_.prototype.handleSourcePropertyChange_=function(){if(this.sourceChangeKey_){_ol_events_.unlistenByKey(this.sourceChangeKey_);this.sourceChangeKey_=null;}var source=this.getSource();if(source){this.sourceChangeKey_=_ol_events_.listen(source,_ol_events_EventType_.CHANGE,this.handleSourceChange_,this);}this.changed();};/**
 * Sets the layer to be rendered on top of other layers on a map. The map will
 * not manage this layer in its layers collection, and the callback in
 * {@link ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
 * is useful for temporary layers. To remove an unmanaged layer from the map,
 * use `#setMap(null)`.
 *
 * To add the layer to a map and have it managed by the map, use
 * {@link ol.Map#addLayer} instead.
 * @param {ol.Map} map Map.
 * @api
 */_ol_layer_Layer_.prototype.setMap=function(map){if(this.mapPrecomposeKey_){_ol_events_.unlistenByKey(this.mapPrecomposeKey_);this.mapPrecomposeKey_=null;}if(!map){this.changed();}if(this.mapRenderKey_){_ol_events_.unlistenByKey(this.mapRenderKey_);this.mapRenderKey_=null;}if(map){this.mapPrecomposeKey_=_ol_events_.listen(map,_ol_render_EventType_.PRECOMPOSE,function(evt){var layerState=this.getLayerState();layerState.managed=false;layerState.zIndex=Infinity;evt.frameState.layerStatesArray.push(layerState);evt.frameState.layerStates[_ol_.getUid(this)]=layerState;},this);this.mapRenderKey_=_ol_events_.listen(this,_ol_events_EventType_.CHANGE,map.render,map);this.changed();}};/**
 * Set the layer source.
 * @param {ol.source.Source} source The layer source.
 * @observable
 * @api
 */_ol_layer_Layer_.prototype.setSource=function(source){this.set(_ol_layer_Property_.SOURCE,source);};/**
 * Available renderers: `'canvas'` or `'webgl'`.
 * @enum {string}
 */var _ol_renderer_Type_={CANVAS:'canvas',WEBGL:'webgl'};/**
 * @enum {number}
 */var _ol_ViewHint_={ANIMATING:0,INTERACTING:1};/**
 * Base class for replay groups.
 * @constructor
 * @abstract
 */var _ol_render_ReplayGroup_=function(){};/**
 * @abstract
 * @param {number|undefined} zIndex Z index.
 * @param {ol.render.ReplayType} replayType Replay type.
 * @return {ol.render.VectorContext} Replay.
 */_ol_render_ReplayGroup_.prototype.getReplay=function(zIndex,replayType){};/**
 * @abstract
 * @return {boolean} Is empty.
 */_ol_render_ReplayGroup_.prototype.isEmpty=function(){};/**
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @constructor
 * @abstract
 * @struct
 * @api
 */var _ol_render_VectorContext_=function(){};/**
 * Render a geometry with a custom renderer.
 *
 * @param {ol.geom.SimpleGeometry} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {Function} renderer Renderer.
 */_ol_render_VectorContext_.prototype.drawCustom=function(geometry,feature,renderer){};/**
 * Render a geometry.
 *
 * @param {ol.geom.Geometry} geometry The geometry to render.
 */_ol_render_VectorContext_.prototype.drawGeometry=function(geometry){};/**
 * Set the rendering style.
 *
 * @param {ol.style.Style} style The rendering style.
 */_ol_render_VectorContext_.prototype.setStyle=function(style){};/**
 * @param {ol.geom.Circle} circleGeometry Circle geometry.
 * @param {ol.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawCircle=function(circleGeometry,feature){};/**
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 */_ol_render_VectorContext_.prototype.drawFeature=function(feature,style){};/**
 * @param {ol.geom.GeometryCollection} geometryCollectionGeometry Geometry
 *     collection.
 * @param {ol.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawGeometryCollection=function(geometryCollectionGeometry,feature){};/**
 * @param {ol.geom.LineString|ol.render.Feature} lineStringGeometry Line
 *     string geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawLineString=function(lineStringGeometry,feature){};/**
 * @param {ol.geom.MultiLineString|ol.render.Feature} multiLineStringGeometry
 *     MultiLineString geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawMultiLineString=function(multiLineStringGeometry,feature){};/**
 * @param {ol.geom.MultiPoint|ol.render.Feature} multiPointGeometry MultiPoint
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawMultiPoint=function(multiPointGeometry,feature){};/**
 * @param {ol.geom.MultiPolygon} multiPolygonGeometry MultiPolygon geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawMultiPolygon=function(multiPolygonGeometry,feature){};/**
 * @param {ol.geom.Point|ol.render.Feature} pointGeometry Point geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawPoint=function(pointGeometry,feature){};/**
 * @param {ol.geom.Polygon|ol.render.Feature} polygonGeometry Polygon
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawPolygon=function(polygonGeometry,feature){};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_VectorContext_.prototype.drawText=function(flatCoordinates,offset,end,stride,geometry,feature){};/**
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 */_ol_render_VectorContext_.prototype.setFillStrokeStyle=function(fillStyle,strokeStyle){};/**
 * @param {ol.style.Image} imageStyle Image style.
 */_ol_render_VectorContext_.prototype.setImageStyle=function(imageStyle){};/**
 * @param {ol.style.Text} textStyle Text style.
 */_ol_render_VectorContext_.prototype.setTextStyle=function(textStyle){};/**
 * @enum {number}
 */var _ol_render_canvas_Instruction_={BEGIN_GEOMETRY:0,BEGIN_PATH:1,CIRCLE:2,CLOSE_PATH:3,CUSTOM:4,DRAW_IMAGE:5,DRAW_TEXT:6,END_GEOMETRY:7,FILL:8,MOVE_TO_LINE_TO:9,SET_FILL_STYLE:10,SET_STROKE_STYLE:11,SET_TEXT_STYLE:12,STROKE:13};var _ol_transform_={};/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3x3 martrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 *//**
 * @private
 * @type {ol.Transform}
 */_ol_transform_.tmp_=new Array(6);/**
 * Create an identity transform.
 * @return {!ol.Transform} Identity transform.
 */_ol_transform_.create=function(){return[1,0,0,1,0,0];};/**
 * Resets the given transform to an identity transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Transform.
 */_ol_transform_.reset=function(transform){return _ol_transform_.set(transform,1,0,0,1,0,0);};/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!ol.Transform} transform1 Transform parameters of matrix 1.
 * @param {!ol.Transform} transform2 Transform parameters of matrix 2.
 * @return {!ol.Transform} transform1 multiplied with transform2.
 */_ol_transform_.multiply=function(transform1,transform2){var a1=transform1[0];var b1=transform1[1];var c1=transform1[2];var d1=transform1[3];var e1=transform1[4];var f1=transform1[5];var a2=transform2[0];var b2=transform2[1];var c2=transform2[2];var d2=transform2[3];var e2=transform2[4];var f2=transform2[5];transform1[0]=a1*a2+c1*b2;transform1[1]=b1*a2+d1*b2;transform1[2]=a1*c2+c1*d2;transform1[3]=b1*c2+d1*d2;transform1[4]=a1*e2+c1*f2+e1;transform1[5]=b1*e2+d1*f2+f1;return transform1;};/**
 * Set the transform components a-f on a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!ol.Transform} Matrix with transform applied.
 */_ol_transform_.set=function(transform,a,b,c,d,e,f){transform[0]=a;transform[1]=b;transform[2]=c;transform[3]=d;transform[4]=e;transform[5]=f;return transform;};/**
 * Set transform on one matrix from another matrix.
 * @param {!ol.Transform} transform1 Matrix to set transform to.
 * @param {!ol.Transform} transform2 Matrix to set transform from.
 * @return {!ol.Transform} transform1 with transform from transform2 applied.
 */_ol_transform_.setFromArray=function(transform1,transform2){transform1[0]=transform2[0];transform1[1]=transform2[1];transform1[2]=transform2[2];transform1[3]=transform2[3];transform1[4]=transform2[4];transform1[5]=transform2[5];return transform1;};/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {ol.Transform} transform The transformation.
 * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.
 * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be
 *     chained together.
 */_ol_transform_.apply=function(transform,coordinate){var x=coordinate[0],y=coordinate[1];coordinate[0]=transform[0]*x+transform[2]*y+transform[4];coordinate[1]=transform[1]*x+transform[3]*y+transform[5];return coordinate;};/**
 * Applies rotation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!ol.Transform} The rotated transform.
 */_ol_transform_.rotate=function(transform,angle){var cos=Math.cos(angle);var sin=Math.sin(angle);return _ol_transform_.multiply(transform,_ol_transform_.set(_ol_transform_.tmp_,cos,sin,-sin,cos,0,0));};/**
 * Applies scale to a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!ol.Transform} The scaled transform.
 */_ol_transform_.scale=function(transform,x,y){return _ol_transform_.multiply(transform,_ol_transform_.set(_ol_transform_.tmp_,x,0,0,y,0,0));};/**
 * Applies translation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!ol.Transform} The translated transform.
 */_ol_transform_.translate=function(transform,dx,dy){return _ol_transform_.multiply(transform,_ol_transform_.set(_ol_transform_.tmp_,1,0,0,1,dx,dy));};/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!ol.Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!ol.Transform} The composite transform.
 */_ol_transform_.compose=function(transform,dx1,dy1,sx,sy,angle,dx2,dy2){var sin=Math.sin(angle);var cos=Math.cos(angle);transform[0]=sx*cos;transform[1]=sy*sin;transform[2]=-sx*sin;transform[3]=sy*cos;transform[4]=dx2*sx*cos-dy2*sx*sin+dx1;transform[5]=dx2*sy*sin+dy2*sy*cos+dy1;return transform;};/**
 * Invert the given transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Inverse of the transform.
 */_ol_transform_.invert=function(transform){var det=_ol_transform_.determinant(transform);_ol_asserts_.assert(det!==0,32);// Transformation matrix cannot be inverted
var a=transform[0];var b=transform[1];var c=transform[2];var d=transform[3];var e=transform[4];var f=transform[5];transform[0]=d/det;transform[1]=-b/det;transform[2]=-c/det;transform[3]=a/det;transform[4]=(c*f-d*e)/det;transform[5]=-(a*f-b*e)/det;return transform;};/**
 * Returns the determinant of the given matrix.
 * @param {!ol.Transform} mat Matrix.
 * @return {number} Determinant.
 */_ol_transform_.determinant=function(mat){return mat[0]*mat[3]-mat[1]*mat[2];};/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */var _ol_render_canvas_Replay_=function(tolerance,maxExtent,resolution,overlaps){_ol_render_VectorContext_.call(this);/**
   * @protected
   * @type {number}
   */this.tolerance=tolerance;/**
   * @protected
   * @const
   * @type {ol.Extent}
   */this.maxExtent=maxExtent;/**
   * @protected
   * @type {boolean}
   */this.overlaps=overlaps;/**
   * @protected
   * @type {number}
   */this.maxLineWidth=0;/**
   * @protected
   * @const
   * @type {number}
   */this.resolution=resolution;/**
   * @private
   * @type {ol.Coordinate}
   */this.fillOrigin_;/**
   * @private
   * @type {Array.<*>}
   */this.beginGeometryInstruction1_=null;/**
   * @private
   * @type {Array.<*>}
   */this.beginGeometryInstruction2_=null;/**
   * @protected
   * @type {Array.<*>}
   */this.instructions=[];/**
   * @protected
   * @type {Array.<number>}
   */this.coordinates=[];/**
   * @private
   * @type {Object.<number,ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>>}
   */this.coordinateCache_={};/**
   * @private
   * @type {!ol.Transform}
   */this.renderedTransform_=_ol_transform_.create();/**
   * @protected
   * @type {Array.<*>}
   */this.hitDetectionInstructions=[];/**
   * @private
   * @type {Array.<number>}
   */this.pixelCoordinates_=null;/**
   * @private
   * @type {!ol.Transform}
   */this.tmpLocalTransform_=_ol_transform_.create();/**
   * @private
   * @type {!ol.Transform}
   */this.resetTransform_=_ol_transform_.create();};_ol_.inherits(_ol_render_canvas_Replay_,_ol_render_VectorContext_);/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} closed Last input coordinate equals first.
 * @param {boolean} skipFirst Skip first coordinate.
 * @protected
 * @return {number} My end.
 */_ol_render_canvas_Replay_.prototype.appendFlatCoordinates=function(flatCoordinates,offset,end,stride,closed,skipFirst){var myEnd=this.coordinates.length;var extent=this.getBufferedMaxExtent();if(skipFirst){offset+=stride;}var lastCoord=[flatCoordinates[offset],flatCoordinates[offset+1]];var nextCoord=[NaN,NaN];var skipped=true;var i,lastRel,nextRel;for(i=offset+stride;i<end;i+=stride){nextCoord[0]=flatCoordinates[i];nextCoord[1]=flatCoordinates[i+1];nextRel=_ol_extent_.coordinateRelationship(extent,nextCoord);if(nextRel!==lastRel){if(skipped){this.coordinates[myEnd++]=lastCoord[0];this.coordinates[myEnd++]=lastCoord[1];}this.coordinates[myEnd++]=nextCoord[0];this.coordinates[myEnd++]=nextCoord[1];skipped=false;}else if(nextRel===_ol_extent_Relationship_.INTERSECTING){this.coordinates[myEnd++]=nextCoord[0];this.coordinates[myEnd++]=nextCoord[1];skipped=false;}else{skipped=true;}lastCoord[0]=nextCoord[0];lastCoord[1]=nextCoord[1];lastRel=nextRel;}// Last coordinate equals first or only one point to append:
if(closed&&skipped||i===offset+stride){this.coordinates[myEnd++]=lastCoord[0];this.coordinates[myEnd++]=lastCoord[1];}return myEnd;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} replayEnds Replay ends.
 * @return {number} Offset.
 */_ol_render_canvas_Replay_.prototype.drawCustomCoordinates_=function(flatCoordinates,offset,ends,stride,replayEnds){for(var i=0,ii=ends.length;i<ii;++i){var end=ends[i];var replayEnd=this.appendFlatCoordinates(flatCoordinates,offset,end,stride,false,false);replayEnds.push(replayEnd);offset=end;}return offset;};/**
 * @inheritDoc.
 */_ol_render_canvas_Replay_.prototype.drawCustom=function(geometry,feature,renderer){this.beginGeometry(geometry,feature);var type=geometry.getType();var stride=geometry.getStride();var replayBegin=this.coordinates.length;var flatCoordinates,replayEnd,replayEnds,replayEndss;var offset;if(type==_ol_geom_GeometryType_.MULTI_POLYGON){geometry=/** @type {ol.geom.MultiPolygon} */geometry;flatCoordinates=geometry.getOrientedFlatCoordinates();replayEndss=[];var endss=geometry.getEndss();offset=0;for(var i=0,ii=endss.length;i<ii;++i){var myEnds=[];offset=this.drawCustomCoordinates_(flatCoordinates,offset,endss[i],stride,myEnds);replayEndss.push(myEnds);}this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,replayBegin,replayEndss,geometry,renderer,_ol_geom_flat_inflate_.coordinatesss]);}else if(type==_ol_geom_GeometryType_.POLYGON||type==_ol_geom_GeometryType_.MULTI_LINE_STRING){replayEnds=[];flatCoordinates=type==_ol_geom_GeometryType_.POLYGON?/** @type {ol.geom.Polygon} */geometry.getOrientedFlatCoordinates():geometry.getFlatCoordinates();offset=this.drawCustomCoordinates_(flatCoordinates,0,/** @type {ol.geom.Polygon|ol.geom.MultiLineString} */geometry.getEnds(),stride,replayEnds);this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,replayBegin,replayEnds,geometry,renderer,_ol_geom_flat_inflate_.coordinatess]);}else if(type==_ol_geom_GeometryType_.LINE_STRING||type==_ol_geom_GeometryType_.MULTI_POINT){flatCoordinates=geometry.getFlatCoordinates();replayEnd=this.appendFlatCoordinates(flatCoordinates,0,flatCoordinates.length,stride,false,false);this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,replayBegin,replayEnd,geometry,renderer,_ol_geom_flat_inflate_.coordinates]);}else if(type==_ol_geom_GeometryType_.POINT){flatCoordinates=geometry.getFlatCoordinates();this.coordinates.push(flatCoordinates[0],flatCoordinates[1]);replayEnd=this.coordinates.length;this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,replayBegin,replayEnd,geometry,renderer]);}this.endGeometry(geometry,feature);};/**
 * @protected
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_canvas_Replay_.prototype.beginGeometry=function(geometry,feature){this.beginGeometryInstruction1_=[_ol_render_canvas_Instruction_.BEGIN_GEOMETRY,feature,0];this.instructions.push(this.beginGeometryInstruction1_);this.beginGeometryInstruction2_=[_ol_render_canvas_Instruction_.BEGIN_GEOMETRY,feature,0];this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);};/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 */_ol_render_canvas_Replay_.prototype.fill_=function(context,rotation){if(this.fillOrigin_){var origin=_ol_transform_.apply(this.renderedTransform_,this.fillOrigin_.slice());context.translate(origin[0],origin[1]);context.rotate(rotation);}context.fill();if(this.fillOrigin_){context.setTransform.apply(context,this.resetTransform_);}};/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<*>} instructions Instructions array.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined}
 *     featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */_ol_render_canvas_Replay_.prototype.replay_=function(context,pixelRatio,transform,viewRotation,skippedFeaturesHash,instructions,featureCallback,opt_hitExtent){/** @type {Array.<number>} */var pixelCoordinates;if(this.pixelCoordinates_&&_ol_array_.equals(transform,this.renderedTransform_)){pixelCoordinates=this.pixelCoordinates_;}else{if(!this.pixelCoordinates_){this.pixelCoordinates_=[];}pixelCoordinates=_ol_geom_flat_transform_.transform2D(this.coordinates,0,this.coordinates.length,2,transform,this.pixelCoordinates_);_ol_transform_.setFromArray(this.renderedTransform_,transform);}var skipFeatures=!_ol_obj_.isEmpty(skippedFeaturesHash);var i=0;// instruction index
var ii=instructions.length;// end of instructions
var d=0;// data index
var dd;// end of per-instruction data
var localTransform=this.tmpLocalTransform_;var resetTransform=this.resetTransform_;var prevX,prevY,roundX,roundY;var pendingFill=0;var pendingStroke=0;var coordinateCache=this.coordinateCache_;var state=/** @type {olx.render.State} */{context:context,pixelRatio:pixelRatio,resolution:this.resolution,rotation:viewRotation};// When the batch size gets too big, performance decreases. 200 is a good
// balance between batch size and number of fill/stroke instructions.
var batchSize=this.instructions!=instructions||this.overlaps?0:200;while(i<ii){var instruction=instructions[i];var type=/** @type {ol.render.canvas.Instruction} */instruction[0];var/** @type {ol.Feature|ol.render.Feature} */feature,fill,stroke,text,x,y;switch(type){case _ol_render_canvas_Instruction_.BEGIN_GEOMETRY:feature=/** @type {ol.Feature|ol.render.Feature} */instruction[1];if(skipFeatures&&skippedFeaturesHash[_ol_.getUid(feature).toString()]||!feature.getGeometry()){i=/** @type {number} */instruction[2];}else if(opt_hitExtent!==undefined&&!_ol_extent_.intersects(opt_hitExtent,feature.getGeometry().getExtent())){i=/** @type {number} */instruction[2]+1;}else{++i;}break;case _ol_render_canvas_Instruction_.BEGIN_PATH:if(pendingFill>batchSize){this.fill_(context,viewRotation);pendingFill=0;}if(pendingStroke>batchSize){context.stroke();pendingStroke=0;}if(!pendingFill&&!pendingStroke){context.beginPath();prevX=prevY=NaN;}++i;break;case _ol_render_canvas_Instruction_.CIRCLE:d=/** @type {number} */instruction[1];var x1=pixelCoordinates[d];var y1=pixelCoordinates[d+1];var x2=pixelCoordinates[d+2];var y2=pixelCoordinates[d+3];var dx=x2-x1;var dy=y2-y1;var r=Math.sqrt(dx*dx+dy*dy);context.moveTo(x1+r,y1);context.arc(x1,y1,r,0,2*Math.PI,true);++i;break;case _ol_render_canvas_Instruction_.CLOSE_PATH:context.closePath();++i;break;case _ol_render_canvas_Instruction_.CUSTOM:d=/** @type {number} */instruction[1];dd=instruction[2];var geometry=/** @type {ol.geom.SimpleGeometry} */instruction[3];var renderer=instruction[4];var fn=instruction.length==6?instruction[5]:undefined;state.geometry=geometry;state.feature=feature;if(!(i in coordinateCache)){coordinateCache[i]=[];}var coords=coordinateCache[i];if(fn){fn(pixelCoordinates,d,dd,2,coords);}else{coords[0]=pixelCoordinates[d];coords[1]=pixelCoordinates[d+1];coords.length=2;}renderer(coords,state);++i;break;case _ol_render_canvas_Instruction_.DRAW_IMAGE:d=/** @type {number} */instruction[1];dd=/** @type {number} */instruction[2];var image=/** @type {HTMLCanvasElement|HTMLVideoElement|Image} */instruction[3];// Remaining arguments in DRAW_IMAGE are in alphabetical order
var anchorX=/** @type {number} */instruction[4]*pixelRatio;var anchorY=/** @type {number} */instruction[5]*pixelRatio;var height=/** @type {number} */instruction[6];var opacity=/** @type {number} */instruction[7];var originX=/** @type {number} */instruction[8];var originY=/** @type {number} */instruction[9];var rotateWithView=/** @type {boolean} */instruction[10];var rotation=/** @type {number} */instruction[11];var scale=/** @type {number} */instruction[12];var snapToPixel=/** @type {boolean} */instruction[13];var width=/** @type {number} */instruction[14];if(rotateWithView){rotation+=viewRotation;}for(;d<dd;d+=2){x=pixelCoordinates[d]-anchorX;y=pixelCoordinates[d+1]-anchorY;if(snapToPixel){x=Math.round(x);y=Math.round(y);}if(scale!=1||rotation!==0){var centerX=x+anchorX;var centerY=y+anchorY;_ol_transform_.compose(localTransform,centerX,centerY,scale,scale,rotation,-centerX,-centerY);context.setTransform.apply(context,localTransform);}var alpha=context.globalAlpha;if(opacity!=1){context.globalAlpha=alpha*opacity;}var w=width+originX>image.width?image.width-originX:width;var h=height+originY>image.height?image.height-originY:height;context.drawImage(image,originX,originY,w,h,x,y,w*pixelRatio,h*pixelRatio);if(opacity!=1){context.globalAlpha=alpha;}if(scale!=1||rotation!==0){context.setTransform.apply(context,resetTransform);}}++i;break;case _ol_render_canvas_Instruction_.DRAW_TEXT:d=/** @type {number} */instruction[1];dd=/** @type {number} */instruction[2];text=/** @type {string} */instruction[3];var offsetX=/** @type {number} */instruction[4]*pixelRatio;var offsetY=/** @type {number} */instruction[5]*pixelRatio;rotation=/** @type {number} */instruction[6];scale=/** @type {number} */instruction[7]*pixelRatio;fill=/** @type {boolean} */instruction[8];stroke=/** @type {boolean} */instruction[9];rotateWithView=/** @type {boolean} */instruction[10];if(rotateWithView){rotation+=viewRotation;}for(;d<dd;d+=2){x=pixelCoordinates[d]+offsetX;y=pixelCoordinates[d+1]+offsetY;if(scale!=1||rotation!==0){_ol_transform_.compose(localTransform,x,y,scale,scale,rotation,-x,-y);context.setTransform.apply(context,localTransform);}// Support multiple lines separated by \n
var lines=text.split('\n');var numLines=lines.length;var fontSize,lineY;if(numLines>1){// Estimate line height using width of capital M, and add padding
fontSize=Math.round(context.measureText('M').width*1.5);lineY=y-(numLines-1)/2*fontSize;}else{// No need to calculate line height/offset for a single line
fontSize=0;lineY=y;}for(var lineIndex=0;lineIndex<numLines;lineIndex++){var line=lines[lineIndex];if(stroke){context.strokeText(line,x,lineY);}if(fill){context.fillText(line,x,lineY);}// Move next line down by fontSize px
lineY=lineY+fontSize;}if(scale!=1||rotation!==0){context.setTransform.apply(context,resetTransform);}}++i;break;case _ol_render_canvas_Instruction_.END_GEOMETRY:if(featureCallback!==undefined){feature=/** @type {ol.Feature|ol.render.Feature} */instruction[1];var result=featureCallback(feature);if(result){return result;}}++i;break;case _ol_render_canvas_Instruction_.FILL:if(batchSize){pendingFill++;}else{this.fill_(context,viewRotation);}++i;break;case _ol_render_canvas_Instruction_.MOVE_TO_LINE_TO:d=/** @type {number} */instruction[1];dd=/** @type {number} */instruction[2];x=pixelCoordinates[d];y=pixelCoordinates[d+1];roundX=x+0.5|0;roundY=y+0.5|0;if(roundX!==prevX||roundY!==prevY){context.moveTo(x,y);prevX=roundX;prevY=roundY;}for(d+=2;d<dd;d+=2){x=pixelCoordinates[d];y=pixelCoordinates[d+1];roundX=x+0.5|0;roundY=y+0.5|0;if(d==dd-2||roundX!==prevX||roundY!==prevY){context.lineTo(x,y);prevX=roundX;prevY=roundY;}}++i;break;case _ol_render_canvas_Instruction_.SET_FILL_STYLE:this.fillOrigin_=instruction[2];if(pendingFill){this.fill_(context,viewRotation);pendingFill=0;if(pendingStroke){context.stroke();pendingStroke=0;}}context.fillStyle=/** @type {ol.ColorLike} */instruction[1];++i;break;case _ol_render_canvas_Instruction_.SET_STROKE_STYLE:var usePixelRatio=instruction[8]!==undefined?instruction[8]:true;var renderedPixelRatio=instruction[9];var lineWidth=/** @type {number} */instruction[2];if(pendingStroke){context.stroke();pendingStroke=0;}context.strokeStyle=/** @type {ol.ColorLike} */instruction[1];context.lineWidth=usePixelRatio?lineWidth*pixelRatio:lineWidth;context.lineCap=/** @type {string} */instruction[3];context.lineJoin=/** @type {string} */instruction[4];context.miterLimit=/** @type {number} */instruction[5];if(_ol_has_.CANVAS_LINE_DASH){var lineDash=/** @type {Array.<number>} */instruction[6];var lineDashOffset=/** @type {number} */instruction[7];if(usePixelRatio&&pixelRatio!==renderedPixelRatio){lineDash=lineDash.map(function(dash){return dash*pixelRatio/renderedPixelRatio;});lineDashOffset*=pixelRatio/renderedPixelRatio;instruction[6]=lineDash;instruction[7]=lineDashOffset;instruction[9]=pixelRatio;}context.lineDashOffset=lineDashOffset;context.setLineDash(lineDash);}++i;break;case _ol_render_canvas_Instruction_.SET_TEXT_STYLE:context.font=/** @type {string} */instruction[1];context.textAlign=/** @type {string} */instruction[2];context.textBaseline=/** @type {string} */instruction[3];++i;break;case _ol_render_canvas_Instruction_.STROKE:if(batchSize){pendingStroke++;}else{context.stroke();}++i;break;default:++i;// consume the instruction anyway, to avoid an infinite loop
break;}}if(pendingFill){this.fill_(context,viewRotation);}if(pendingStroke){context.stroke();}return undefined;};/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 */_ol_render_canvas_Replay_.prototype.replay=function(context,pixelRatio,transform,viewRotation,skippedFeaturesHash){var instructions=this.instructions;this.replay_(context,pixelRatio,transform,viewRotation,skippedFeaturesHash,instructions,undefined,undefined);};/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */_ol_render_canvas_Replay_.prototype.replayHitDetection=function(context,transform,viewRotation,skippedFeaturesHash,opt_featureCallback,opt_hitExtent){var instructions=this.hitDetectionInstructions;return this.replay_(context,1,transform,viewRotation,skippedFeaturesHash,instructions,opt_featureCallback,opt_hitExtent);};/**
 * Reverse the hit detection instructions.
 */_ol_render_canvas_Replay_.prototype.reverseHitDetectionInstructions=function(){var hitDetectionInstructions=this.hitDetectionInstructions;// step 1 - reverse array
hitDetectionInstructions.reverse();// step 2 - reverse instructions within geometry blocks
var i;var n=hitDetectionInstructions.length;var instruction;var type;var begin=-1;for(i=0;i<n;++i){instruction=hitDetectionInstructions[i];type=/** @type {ol.render.canvas.Instruction} */instruction[0];if(type==_ol_render_canvas_Instruction_.END_GEOMETRY){begin=i;}else if(type==_ol_render_canvas_Instruction_.BEGIN_GEOMETRY){instruction[2]=i;_ol_array_.reverseSubArray(this.hitDetectionInstructions,begin,i);begin=-1;}}};/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */_ol_render_canvas_Replay_.prototype.endGeometry=function(geometry,feature){this.beginGeometryInstruction1_[2]=this.instructions.length;this.beginGeometryInstruction1_=null;this.beginGeometryInstruction2_[2]=this.hitDetectionInstructions.length;this.beginGeometryInstruction2_=null;var endGeometryInstruction=[_ol_render_canvas_Instruction_.END_GEOMETRY,feature];this.instructions.push(endGeometryInstruction);this.hitDetectionInstructions.push(endGeometryInstruction);};/**
 * FIXME empty description for jsdoc
 */_ol_render_canvas_Replay_.prototype.finish=_ol_.nullFunction;/**
 * Get the buffered rendering extent.  Rendering will be clipped to the extent
 * provided to the constructor.  To account for symbolizers that may intersect
 * this extent, we calculate a buffered extent (e.g. based on stroke width).
 * @return {ol.Extent} The buffered rendering extent.
 * @protected
 */_ol_render_canvas_Replay_.prototype.getBufferedMaxExtent=function(){return this.maxExtent;};/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */var _ol_render_canvas_ImageReplay_=function(tolerance,maxExtent,resolution,overlaps){_ol_render_canvas_Replay_.call(this,tolerance,maxExtent,resolution,overlaps);/**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */this.hitDetectionImage_=null;/**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */this.image_=null;/**
   * @private
   * @type {number|undefined}
   */this.anchorX_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.anchorY_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.height_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.opacity_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.originX_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.originY_=undefined;/**
   * @private
   * @type {boolean|undefined}
   */this.rotateWithView_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.rotation_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.scale_=undefined;/**
   * @private
   * @type {boolean|undefined}
   */this.snapToPixel_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.width_=undefined;};_ol_.inherits(_ol_render_canvas_ImageReplay_,_ol_render_canvas_Replay_);/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} My end.
 */_ol_render_canvas_ImageReplay_.prototype.drawCoordinates_=function(flatCoordinates,offset,end,stride){return this.appendFlatCoordinates(flatCoordinates,offset,end,stride,false,false);};/**
 * @inheritDoc
 */_ol_render_canvas_ImageReplay_.prototype.drawPoint=function(pointGeometry,feature){if(!this.image_){return;}this.beginGeometry(pointGeometry,feature);var flatCoordinates=pointGeometry.getFlatCoordinates();var stride=pointGeometry.getStride();var myBegin=this.coordinates.length;var myEnd=this.drawCoordinates_(flatCoordinates,0,flatCoordinates.length,stride);this.instructions.push([_ol_render_canvas_Instruction_.DRAW_IMAGE,myBegin,myEnd,this.image_,// Remaining arguments to DRAW_IMAGE are in alphabetical order
this.anchorX_,this.anchorY_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]);this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.DRAW_IMAGE,myBegin,myEnd,this.hitDetectionImage_,// Remaining arguments to DRAW_IMAGE are in alphabetical order
this.anchorX_,this.anchorY_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]);this.endGeometry(pointGeometry,feature);};/**
 * @inheritDoc
 */_ol_render_canvas_ImageReplay_.prototype.drawMultiPoint=function(multiPointGeometry,feature){if(!this.image_){return;}this.beginGeometry(multiPointGeometry,feature);var flatCoordinates=multiPointGeometry.getFlatCoordinates();var stride=multiPointGeometry.getStride();var myBegin=this.coordinates.length;var myEnd=this.drawCoordinates_(flatCoordinates,0,flatCoordinates.length,stride);this.instructions.push([_ol_render_canvas_Instruction_.DRAW_IMAGE,myBegin,myEnd,this.image_,// Remaining arguments to DRAW_IMAGE are in alphabetical order
this.anchorX_,this.anchorY_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]);this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.DRAW_IMAGE,myBegin,myEnd,this.hitDetectionImage_,// Remaining arguments to DRAW_IMAGE are in alphabetical order
this.anchorX_,this.anchorY_,this.height_,this.opacity_,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.snapToPixel_,this.width_]);this.endGeometry(multiPointGeometry,feature);};/**
 * @inheritDoc
 */_ol_render_canvas_ImageReplay_.prototype.finish=function(){this.reverseHitDetectionInstructions();// FIXME this doesn't really protect us against further calls to draw*Geometry
this.anchorX_=undefined;this.anchorY_=undefined;this.hitDetectionImage_=null;this.image_=null;this.height_=undefined;this.scale_=undefined;this.opacity_=undefined;this.originX_=undefined;this.originY_=undefined;this.rotateWithView_=undefined;this.rotation_=undefined;this.snapToPixel_=undefined;this.width_=undefined;};/**
 * @inheritDoc
 */_ol_render_canvas_ImageReplay_.prototype.setImageStyle=function(imageStyle){var anchor=imageStyle.getAnchor();var size=imageStyle.getSize();var hitDetectionImage=imageStyle.getHitDetectionImage(1);var image=imageStyle.getImage(1);var origin=imageStyle.getOrigin();this.anchorX_=anchor[0];this.anchorY_=anchor[1];this.hitDetectionImage_=hitDetectionImage;this.image_=image;this.height_=size[1];this.opacity_=imageStyle.getOpacity();this.originX_=origin[0];this.originY_=origin[1];this.rotateWithView_=imageStyle.getRotateWithView();this.rotation_=imageStyle.getRotation();this.scale_=imageStyle.getScale();this.snapToPixel_=imageStyle.getSnapToPixel();this.width_=size[0];};/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */var _ol_render_canvas_LineStringReplay_=function(tolerance,maxExtent,resolution,overlaps){_ol_render_canvas_Replay_.call(this,tolerance,maxExtent,resolution,overlaps);/**
   * @private
   * @type {ol.Extent}
   */this.bufferedMaxExtent_=null;/**
   * @private
   * @type {{currentStrokeStyle: (ol.ColorLike|undefined),
   *         currentLineCap: (string|undefined),
   *         currentLineDash: Array.<number>,
   *         currentLineDashOffset: (number|undefined),
   *         currentLineJoin: (string|undefined),
   *         currentLineWidth: (number|undefined),
   *         currentMiterLimit: (number|undefined),
   *         lastStroke: (number|undefined),
   *         strokeStyle: (ol.ColorLike|undefined),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: (number|undefined),
   *         miterLimit: (number|undefined)}|null}
   */this.state_={currentStrokeStyle:undefined,currentLineCap:undefined,currentLineDash:null,currentLineDashOffset:undefined,currentLineJoin:undefined,currentLineWidth:undefined,currentMiterLimit:undefined,lastStroke:undefined,strokeStyle:undefined,lineCap:undefined,lineDash:null,lineDashOffset:undefined,lineJoin:undefined,lineWidth:undefined,miterLimit:undefined};};_ol_.inherits(_ol_render_canvas_LineStringReplay_,_ol_render_canvas_Replay_);/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} end.
 */_ol_render_canvas_LineStringReplay_.prototype.drawFlatCoordinates_=function(flatCoordinates,offset,end,stride){var myBegin=this.coordinates.length;var myEnd=this.appendFlatCoordinates(flatCoordinates,offset,end,stride,false,false);var moveToLineToInstruction=[_ol_render_canvas_Instruction_.MOVE_TO_LINE_TO,myBegin,myEnd];this.instructions.push(moveToLineToInstruction);this.hitDetectionInstructions.push(moveToLineToInstruction);return end;};/**
 * @inheritDoc
 */_ol_render_canvas_LineStringReplay_.prototype.getBufferedMaxExtent=function(){if(!this.bufferedMaxExtent_){this.bufferedMaxExtent_=_ol_extent_.clone(this.maxExtent);if(this.maxLineWidth>0){var width=this.resolution*(this.maxLineWidth+1)/2;_ol_extent_.buffer(this.bufferedMaxExtent_,width,this.bufferedMaxExtent_);}}return this.bufferedMaxExtent_;};/**
 * @private
 */_ol_render_canvas_LineStringReplay_.prototype.setStrokeStyle_=function(){var state=this.state_;var strokeStyle=state.strokeStyle;var lineCap=state.lineCap;var lineDash=state.lineDash;var lineDashOffset=state.lineDashOffset;var lineJoin=state.lineJoin;var lineWidth=state.lineWidth;var miterLimit=state.miterLimit;if(state.currentStrokeStyle!=strokeStyle||state.currentLineCap!=lineCap||!_ol_array_.equals(state.currentLineDash,lineDash)||state.currentLineDashOffset!=lineDashOffset||state.currentLineJoin!=lineJoin||state.currentLineWidth!=lineWidth||state.currentMiterLimit!=miterLimit){if(state.lastStroke!=undefined&&state.lastStroke!=this.coordinates.length){this.instructions.push([_ol_render_canvas_Instruction_.STROKE]);state.lastStroke=this.coordinates.length;}state.lastStroke=0;this.instructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE,strokeStyle,lineWidth,lineCap,lineJoin,miterLimit,lineDash,lineDashOffset,true,1],[_ol_render_canvas_Instruction_.BEGIN_PATH]);state.currentStrokeStyle=strokeStyle;state.currentLineCap=lineCap;state.currentLineDash=lineDash;state.currentLineDashOffset=lineDashOffset;state.currentLineJoin=lineJoin;state.currentLineWidth=lineWidth;state.currentMiterLimit=miterLimit;}};/**
 * @inheritDoc
 */_ol_render_canvas_LineStringReplay_.prototype.drawLineString=function(lineStringGeometry,feature){var state=this.state_;var strokeStyle=state.strokeStyle;var lineWidth=state.lineWidth;if(strokeStyle===undefined||lineWidth===undefined){return;}this.setStrokeStyle_();this.beginGeometry(lineStringGeometry,feature);this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE,state.strokeStyle,state.lineWidth,state.lineCap,state.lineJoin,state.miterLimit,state.lineDash,state.lineDashOffset,true,1],[_ol_render_canvas_Instruction_.BEGIN_PATH]);var flatCoordinates=lineStringGeometry.getFlatCoordinates();var stride=lineStringGeometry.getStride();this.drawFlatCoordinates_(flatCoordinates,0,flatCoordinates.length,stride);this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.STROKE]);this.endGeometry(lineStringGeometry,feature);};/**
 * @inheritDoc
 */_ol_render_canvas_LineStringReplay_.prototype.drawMultiLineString=function(multiLineStringGeometry,feature){var state=this.state_;var strokeStyle=state.strokeStyle;var lineWidth=state.lineWidth;if(strokeStyle===undefined||lineWidth===undefined){return;}this.setStrokeStyle_();this.beginGeometry(multiLineStringGeometry,feature);this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE,state.strokeStyle,state.lineWidth,state.lineCap,state.lineJoin,state.miterLimit,state.lineDash,state.lineDashOffset,true,1],[_ol_render_canvas_Instruction_.BEGIN_PATH]);var ends=multiLineStringGeometry.getEnds();var flatCoordinates=multiLineStringGeometry.getFlatCoordinates();var stride=multiLineStringGeometry.getStride();var offset=0;var i,ii;for(i=0,ii=ends.length;i<ii;++i){offset=this.drawFlatCoordinates_(flatCoordinates,offset,ends[i],stride);}this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.STROKE]);this.endGeometry(multiLineStringGeometry,feature);};/**
 * @inheritDoc
 */_ol_render_canvas_LineStringReplay_.prototype.finish=function(){var state=this.state_;if(state.lastStroke!=undefined&&state.lastStroke!=this.coordinates.length){this.instructions.push([_ol_render_canvas_Instruction_.STROKE]);}this.reverseHitDetectionInstructions();this.state_=null;};/**
 * @inheritDoc
 */_ol_render_canvas_LineStringReplay_.prototype.setFillStrokeStyle=function(fillStyle,strokeStyle){var strokeStyleColor=strokeStyle.getColor();this.state_.strokeStyle=_ol_colorlike_.asColorLike(strokeStyleColor?strokeStyleColor:_ol_render_canvas_.defaultStrokeStyle);var strokeStyleLineCap=strokeStyle.getLineCap();this.state_.lineCap=strokeStyleLineCap!==undefined?strokeStyleLineCap:_ol_render_canvas_.defaultLineCap;var strokeStyleLineDash=strokeStyle.getLineDash();this.state_.lineDash=strokeStyleLineDash?strokeStyleLineDash:_ol_render_canvas_.defaultLineDash;var strokeStyleLineDashOffset=strokeStyle.getLineDashOffset();this.state_.lineDashOffset=strokeStyleLineDashOffset?strokeStyleLineDashOffset:_ol_render_canvas_.defaultLineDashOffset;var strokeStyleLineJoin=strokeStyle.getLineJoin();this.state_.lineJoin=strokeStyleLineJoin!==undefined?strokeStyleLineJoin:_ol_render_canvas_.defaultLineJoin;var strokeStyleWidth=strokeStyle.getWidth();this.state_.lineWidth=strokeStyleWidth!==undefined?strokeStyleWidth:_ol_render_canvas_.defaultLineWidth;var strokeStyleMiterLimit=strokeStyle.getMiterLimit();this.state_.miterLimit=strokeStyleMiterLimit!==undefined?strokeStyleMiterLimit:_ol_render_canvas_.defaultMiterLimit;if(this.state_.lineWidth>this.maxLineWidth){this.maxLineWidth=this.state_.lineWidth;// invalidate the buffered max extent cache
this.bufferedMaxExtent_=null;}};/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */var _ol_render_canvas_PolygonReplay_=function(tolerance,maxExtent,resolution,overlaps){_ol_render_canvas_Replay_.call(this,tolerance,maxExtent,resolution,overlaps);/**
   * @private
   * @type {ol.Extent}
   */this.bufferedMaxExtent_=null;/**
   * @private
   * @type {{currentFillStyle: (ol.ColorLike|undefined),
   *         currentStrokeStyle: (ol.ColorLike|undefined),
   *         currentLineCap: (string|undefined),
   *         currentLineDash: Array.<number>,
   *         currentLineDashOffset: (number|undefined),
   *         currentLineJoin: (string|undefined),
   *         currentLineWidth: (number|undefined),
   *         currentMiterLimit: (number|undefined),
   *         fillStyle: (ol.ColorLike|undefined),
   *         strokeStyle: (ol.ColorLike|undefined),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: (number|undefined),
   *         miterLimit: (number|undefined)}|null}
   */this.state_={currentFillStyle:undefined,currentStrokeStyle:undefined,currentLineCap:undefined,currentLineDash:null,currentLineDashOffset:undefined,currentLineJoin:undefined,currentLineWidth:undefined,currentMiterLimit:undefined,fillStyle:undefined,strokeStyle:undefined,lineCap:undefined,lineDash:null,lineDashOffset:undefined,lineJoin:undefined,lineWidth:undefined,miterLimit:undefined};};_ol_.inherits(_ol_render_canvas_PolygonReplay_,_ol_render_canvas_Replay_);/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */_ol_render_canvas_PolygonReplay_.prototype.drawFlatCoordinatess_=function(flatCoordinates,offset,ends,stride){var state=this.state_;var fill=state.fillStyle!==undefined;var stroke=state.strokeStyle!=undefined;var numEnds=ends.length;var beginPathInstruction=[_ol_render_canvas_Instruction_.BEGIN_PATH];this.instructions.push(beginPathInstruction);this.hitDetectionInstructions.push(beginPathInstruction);for(var i=0;i<numEnds;++i){var end=ends[i];var myBegin=this.coordinates.length;var myEnd=this.appendFlatCoordinates(flatCoordinates,offset,end,stride,true,!stroke);var moveToLineToInstruction=[_ol_render_canvas_Instruction_.MOVE_TO_LINE_TO,myBegin,myEnd];this.instructions.push(moveToLineToInstruction);this.hitDetectionInstructions.push(moveToLineToInstruction);if(stroke){// Performance optimization: only call closePath() when we have a stroke.
// Otherwise the ring is closed already (see appendFlatCoordinates above).
var closePathInstruction=[_ol_render_canvas_Instruction_.CLOSE_PATH];this.instructions.push(closePathInstruction);this.hitDetectionInstructions.push(closePathInstruction);}offset=end;}var fillInstruction=[_ol_render_canvas_Instruction_.FILL];this.hitDetectionInstructions.push(fillInstruction);if(fill){this.instructions.push(fillInstruction);}if(stroke){var strokeInstruction=[_ol_render_canvas_Instruction_.STROKE];this.instructions.push(strokeInstruction);this.hitDetectionInstructions.push(strokeInstruction);}return offset;};/**
 * @inheritDoc
 */_ol_render_canvas_PolygonReplay_.prototype.drawCircle=function(circleGeometry,feature){var state=this.state_;var fillStyle=state.fillStyle;var strokeStyle=state.strokeStyle;if(fillStyle===undefined&&strokeStyle===undefined){return;}this.setFillStrokeStyles_(circleGeometry);this.beginGeometry(circleGeometry,feature);// always fill the circle for hit detection
this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_FILL_STYLE,_ol_color_.asString(_ol_render_canvas_.defaultFillStyle)]);if(state.strokeStyle!==undefined){this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE,state.strokeStyle,state.lineWidth,state.lineCap,state.lineJoin,state.miterLimit,state.lineDash,state.lineDashOffset,true,1]);}var flatCoordinates=circleGeometry.getFlatCoordinates();var stride=circleGeometry.getStride();var myBegin=this.coordinates.length;this.appendFlatCoordinates(flatCoordinates,0,flatCoordinates.length,stride,false,false);var beginPathInstruction=[_ol_render_canvas_Instruction_.BEGIN_PATH];var circleInstruction=[_ol_render_canvas_Instruction_.CIRCLE,myBegin];this.instructions.push(beginPathInstruction,circleInstruction);this.hitDetectionInstructions.push(beginPathInstruction,circleInstruction);var fillInstruction=[_ol_render_canvas_Instruction_.FILL];this.hitDetectionInstructions.push(fillInstruction);if(state.fillStyle!==undefined){this.instructions.push(fillInstruction);}if(state.strokeStyle!==undefined){var strokeInstruction=[_ol_render_canvas_Instruction_.STROKE];this.instructions.push(strokeInstruction);this.hitDetectionInstructions.push(strokeInstruction);}this.endGeometry(circleGeometry,feature);};/**
 * @inheritDoc
 */_ol_render_canvas_PolygonReplay_.prototype.drawPolygon=function(polygonGeometry,feature){var state=this.state_;this.setFillStrokeStyles_(polygonGeometry);this.beginGeometry(polygonGeometry,feature);// always fill the polygon for hit detection
this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_FILL_STYLE,_ol_color_.asString(_ol_render_canvas_.defaultFillStyle)]);if(state.strokeStyle!==undefined){this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE,state.strokeStyle,state.lineWidth,state.lineCap,state.lineJoin,state.miterLimit,state.lineDash,state.lineDashOffset,true,1]);}var ends=polygonGeometry.getEnds();var flatCoordinates=polygonGeometry.getOrientedFlatCoordinates();var stride=polygonGeometry.getStride();this.drawFlatCoordinatess_(flatCoordinates,0,ends,stride);this.endGeometry(polygonGeometry,feature);};/**
 * @inheritDoc
 */_ol_render_canvas_PolygonReplay_.prototype.drawMultiPolygon=function(multiPolygonGeometry,feature){var state=this.state_;var fillStyle=state.fillStyle;var strokeStyle=state.strokeStyle;if(fillStyle===undefined&&strokeStyle===undefined){return;}this.setFillStrokeStyles_(multiPolygonGeometry);this.beginGeometry(multiPolygonGeometry,feature);// always fill the multi-polygon for hit detection
this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_FILL_STYLE,_ol_color_.asString(_ol_render_canvas_.defaultFillStyle)]);if(state.strokeStyle!==undefined){this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE,state.strokeStyle,state.lineWidth,state.lineCap,state.lineJoin,state.miterLimit,state.lineDash,state.lineDashOffset,true,1]);}var endss=multiPolygonGeometry.getEndss();var flatCoordinates=multiPolygonGeometry.getOrientedFlatCoordinates();var stride=multiPolygonGeometry.getStride();var offset=0;var i,ii;for(i=0,ii=endss.length;i<ii;++i){offset=this.drawFlatCoordinatess_(flatCoordinates,offset,endss[i],stride);}this.endGeometry(multiPolygonGeometry,feature);};/**
 * @inheritDoc
 */_ol_render_canvas_PolygonReplay_.prototype.finish=function(){this.reverseHitDetectionInstructions();this.state_=null;// We want to preserve topology when drawing polygons.  Polygons are
// simplified using quantization and point elimination. However, we might
// have received a mix of quantized and non-quantized geometries, so ensure
// that all are quantized by quantizing all coordinates in the batch.
var tolerance=this.tolerance;if(tolerance!==0){var coordinates=this.coordinates;var i,ii;for(i=0,ii=coordinates.length;i<ii;++i){coordinates[i]=_ol_geom_flat_simplify_.snap(coordinates[i],tolerance);}}};/**
 * @inheritDoc
 */_ol_render_canvas_PolygonReplay_.prototype.getBufferedMaxExtent=function(){if(!this.bufferedMaxExtent_){this.bufferedMaxExtent_=_ol_extent_.clone(this.maxExtent);if(this.maxLineWidth>0){var width=this.resolution*(this.maxLineWidth+1)/2;_ol_extent_.buffer(this.bufferedMaxExtent_,width,this.bufferedMaxExtent_);}}return this.bufferedMaxExtent_;};/**
 * @inheritDoc
 */_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyle=function(fillStyle,strokeStyle){var state=this.state_;if(fillStyle){var fillStyleColor=fillStyle.getColor();state.fillStyle=_ol_colorlike_.asColorLike(fillStyleColor?fillStyleColor:_ol_render_canvas_.defaultFillStyle);}else{state.fillStyle=undefined;}if(strokeStyle){var strokeStyleColor=strokeStyle.getColor();state.strokeStyle=_ol_colorlike_.asColorLike(strokeStyleColor?strokeStyleColor:_ol_render_canvas_.defaultStrokeStyle);var strokeStyleLineCap=strokeStyle.getLineCap();state.lineCap=strokeStyleLineCap!==undefined?strokeStyleLineCap:_ol_render_canvas_.defaultLineCap;var strokeStyleLineDash=strokeStyle.getLineDash();state.lineDash=strokeStyleLineDash?strokeStyleLineDash.slice():_ol_render_canvas_.defaultLineDash;var strokeStyleLineDashOffset=strokeStyle.getLineDashOffset();state.lineDashOffset=strokeStyleLineDashOffset?strokeStyleLineDashOffset:_ol_render_canvas_.defaultLineDashOffset;var strokeStyleLineJoin=strokeStyle.getLineJoin();state.lineJoin=strokeStyleLineJoin!==undefined?strokeStyleLineJoin:_ol_render_canvas_.defaultLineJoin;var strokeStyleWidth=strokeStyle.getWidth();state.lineWidth=strokeStyleWidth!==undefined?strokeStyleWidth:_ol_render_canvas_.defaultLineWidth;var strokeStyleMiterLimit=strokeStyle.getMiterLimit();state.miterLimit=strokeStyleMiterLimit!==undefined?strokeStyleMiterLimit:_ol_render_canvas_.defaultMiterLimit;if(state.lineWidth>this.maxLineWidth){this.maxLineWidth=state.lineWidth;// invalidate the buffered max extent cache
this.bufferedMaxExtent_=null;}}else{state.strokeStyle=undefined;state.lineCap=undefined;state.lineDash=null;state.lineDashOffset=undefined;state.lineJoin=undefined;state.lineWidth=undefined;state.miterLimit=undefined;}};/**
 * @private
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyles_=function(geometry){var state=this.state_;var fillStyle=state.fillStyle;var strokeStyle=state.strokeStyle;var lineCap=state.lineCap;var lineDash=state.lineDash;var lineDashOffset=state.lineDashOffset;var lineJoin=state.lineJoin;var lineWidth=state.lineWidth;var miterLimit=state.miterLimit;if(fillStyle!==undefined&&(typeof fillStyle!=='string'||state.currentFillStyle!=fillStyle)){var fillInstruction=[_ol_render_canvas_Instruction_.SET_FILL_STYLE,fillStyle];if(typeof fillStyle!=='string'){var fillExtent=geometry.getExtent();fillInstruction.push([fillExtent[0],fillExtent[3]]);}this.instructions.push(fillInstruction);state.currentFillStyle=state.fillStyle;}if(strokeStyle!==undefined){if(state.currentStrokeStyle!=strokeStyle||state.currentLineCap!=lineCap||!_ol_array_.equals(state.currentLineDash,lineDash)||state.currentLineDashOffset!=lineDashOffset||state.currentLineJoin!=lineJoin||state.currentLineWidth!=lineWidth||state.currentMiterLimit!=miterLimit){this.instructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE,strokeStyle,lineWidth,lineCap,lineJoin,miterLimit,lineDash,lineDashOffset,true,1]);state.currentStrokeStyle=strokeStyle;state.currentLineCap=lineCap;state.currentLineDash=lineDash;state.currentLineDashOffset=lineDashOffset;state.currentLineJoin=lineJoin;state.currentLineWidth=lineWidth;state.currentMiterLimit=miterLimit;}}};/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */var _ol_render_canvas_TextReplay_=function(tolerance,maxExtent,resolution,overlaps){_ol_render_canvas_Replay_.call(this,tolerance,maxExtent,resolution,overlaps);/**
   * @private
   * @type {?ol.CanvasFillState}
   */this.replayFillState_=null;/**
   * @private
   * @type {?ol.CanvasStrokeState}
   */this.replayStrokeState_=null;/**
   * @private
   * @type {?ol.CanvasTextState}
   */this.replayTextState_=null;/**
   * @private
   * @type {string}
   */this.text_='';/**
   * @private
   * @type {number}
   */this.textOffsetX_=0;/**
   * @private
   * @type {number}
   */this.textOffsetY_=0;/**
   * @private
   * @type {boolean|undefined}
   */this.textRotateWithView_=undefined;/**
   * @private
   * @type {number}
   */this.textRotation_=0;/**
   * @private
   * @type {number}
   */this.textScale_=0;/**
   * @private
   * @type {?ol.CanvasFillState}
   */this.textFillState_=null;/**
   * @private
   * @type {?ol.CanvasStrokeState}
   */this.textStrokeState_=null;/**
   * @private
   * @type {?ol.CanvasTextState}
   */this.textState_=null;};_ol_.inherits(_ol_render_canvas_TextReplay_,_ol_render_canvas_Replay_);/**
 * @inheritDoc
 */_ol_render_canvas_TextReplay_.prototype.drawText=function(flatCoordinates,offset,end,stride,geometry,feature){if(this.text_===''||!this.textState_||!this.textFillState_&&!this.textStrokeState_){return;}if(this.textFillState_){this.setReplayFillState_(this.textFillState_);}if(this.textStrokeState_){this.setReplayStrokeState_(this.textStrokeState_);}this.setReplayTextState_(this.textState_);this.beginGeometry(geometry,feature);var myBegin=this.coordinates.length;var myEnd=this.appendFlatCoordinates(flatCoordinates,offset,end,stride,false,false);var fill=!!this.textFillState_;var stroke=!!this.textStrokeState_;var drawTextInstruction=[_ol_render_canvas_Instruction_.DRAW_TEXT,myBegin,myEnd,this.text_,this.textOffsetX_,this.textOffsetY_,this.textRotation_,this.textScale_,fill,stroke,this.textRotateWithView_];this.instructions.push(drawTextInstruction);this.hitDetectionInstructions.push(drawTextInstruction);this.endGeometry(geometry,feature);};/**
 * @param {ol.CanvasFillState} fillState Fill state.
 * @private
 */_ol_render_canvas_TextReplay_.prototype.setReplayFillState_=function(fillState){var replayFillState=this.replayFillState_;if(replayFillState&&replayFillState.fillStyle==fillState.fillStyle){return;}var setFillStyleInstruction=[_ol_render_canvas_Instruction_.SET_FILL_STYLE,fillState.fillStyle];this.instructions.push(setFillStyleInstruction);this.hitDetectionInstructions.push(setFillStyleInstruction);if(!replayFillState){this.replayFillState_={fillStyle:fillState.fillStyle};}else{replayFillState.fillStyle=fillState.fillStyle;}};/**
 * @param {ol.CanvasStrokeState} strokeState Stroke state.
 * @private
 */_ol_render_canvas_TextReplay_.prototype.setReplayStrokeState_=function(strokeState){var replayStrokeState=this.replayStrokeState_;if(replayStrokeState&&replayStrokeState.lineCap==strokeState.lineCap&&replayStrokeState.lineDash==strokeState.lineDash&&replayStrokeState.lineDashOffset==strokeState.lineDashOffset&&replayStrokeState.lineJoin==strokeState.lineJoin&&replayStrokeState.lineWidth==strokeState.lineWidth&&replayStrokeState.miterLimit==strokeState.miterLimit&&replayStrokeState.strokeStyle==strokeState.strokeStyle){return;}var setStrokeStyleInstruction=[_ol_render_canvas_Instruction_.SET_STROKE_STYLE,strokeState.strokeStyle,strokeState.lineWidth,strokeState.lineCap,strokeState.lineJoin,strokeState.miterLimit,strokeState.lineDash,strokeState.lineDashOffset,false,1];this.instructions.push(setStrokeStyleInstruction);this.hitDetectionInstructions.push(setStrokeStyleInstruction);if(!replayStrokeState){this.replayStrokeState_={lineCap:strokeState.lineCap,lineDash:strokeState.lineDash,lineDashOffset:strokeState.lineDashOffset,lineJoin:strokeState.lineJoin,lineWidth:strokeState.lineWidth,miterLimit:strokeState.miterLimit,strokeStyle:strokeState.strokeStyle};}else{replayStrokeState.lineCap=strokeState.lineCap;replayStrokeState.lineDash=strokeState.lineDash;replayStrokeState.lineDashOffset=strokeState.lineDashOffset;replayStrokeState.lineJoin=strokeState.lineJoin;replayStrokeState.lineWidth=strokeState.lineWidth;replayStrokeState.miterLimit=strokeState.miterLimit;replayStrokeState.strokeStyle=strokeState.strokeStyle;}};/**
 * @param {ol.CanvasTextState} textState Text state.
 * @private
 */_ol_render_canvas_TextReplay_.prototype.setReplayTextState_=function(textState){var replayTextState=this.replayTextState_;if(replayTextState&&replayTextState.font==textState.font&&replayTextState.textAlign==textState.textAlign&&replayTextState.textBaseline==textState.textBaseline){return;}var setTextStyleInstruction=[_ol_render_canvas_Instruction_.SET_TEXT_STYLE,textState.font,textState.textAlign,textState.textBaseline];this.instructions.push(setTextStyleInstruction);this.hitDetectionInstructions.push(setTextStyleInstruction);if(!replayTextState){this.replayTextState_={font:textState.font,textAlign:textState.textAlign,textBaseline:textState.textBaseline};}else{replayTextState.font=textState.font;replayTextState.textAlign=textState.textAlign;replayTextState.textBaseline=textState.textBaseline;}};/**
 * @inheritDoc
 */_ol_render_canvas_TextReplay_.prototype.setTextStyle=function(textStyle){if(!textStyle){this.text_='';}else{var textFillStyle=textStyle.getFill();if(!textFillStyle){this.textFillState_=null;}else{var textFillStyleColor=textFillStyle.getColor();var fillStyle=_ol_colorlike_.asColorLike(textFillStyleColor?textFillStyleColor:_ol_render_canvas_.defaultFillStyle);if(!this.textFillState_){this.textFillState_={fillStyle:fillStyle};}else{var textFillState=this.textFillState_;textFillState.fillStyle=fillStyle;}}var textStrokeStyle=textStyle.getStroke();if(!textStrokeStyle){this.textStrokeState_=null;}else{var textStrokeStyleColor=textStrokeStyle.getColor();var textStrokeStyleLineCap=textStrokeStyle.getLineCap();var textStrokeStyleLineDash=textStrokeStyle.getLineDash();var textStrokeStyleLineDashOffset=textStrokeStyle.getLineDashOffset();var textStrokeStyleLineJoin=textStrokeStyle.getLineJoin();var textStrokeStyleWidth=textStrokeStyle.getWidth();var textStrokeStyleMiterLimit=textStrokeStyle.getMiterLimit();var lineCap=textStrokeStyleLineCap!==undefined?textStrokeStyleLineCap:_ol_render_canvas_.defaultLineCap;var lineDash=textStrokeStyleLineDash?textStrokeStyleLineDash.slice():_ol_render_canvas_.defaultLineDash;var lineDashOffset=textStrokeStyleLineDashOffset!==undefined?textStrokeStyleLineDashOffset:_ol_render_canvas_.defaultLineDashOffset;var lineJoin=textStrokeStyleLineJoin!==undefined?textStrokeStyleLineJoin:_ol_render_canvas_.defaultLineJoin;var lineWidth=textStrokeStyleWidth!==undefined?textStrokeStyleWidth:_ol_render_canvas_.defaultLineWidth;var miterLimit=textStrokeStyleMiterLimit!==undefined?textStrokeStyleMiterLimit:_ol_render_canvas_.defaultMiterLimit;var strokeStyle=_ol_colorlike_.asColorLike(textStrokeStyleColor?textStrokeStyleColor:_ol_render_canvas_.defaultStrokeStyle);if(!this.textStrokeState_){this.textStrokeState_={lineCap:lineCap,lineDash:lineDash,lineDashOffset:lineDashOffset,lineJoin:lineJoin,lineWidth:lineWidth,miterLimit:miterLimit,strokeStyle:strokeStyle};}else{var textStrokeState=this.textStrokeState_;textStrokeState.lineCap=lineCap;textStrokeState.lineDash=lineDash;textStrokeState.lineDashOffset=lineDashOffset;textStrokeState.lineJoin=lineJoin;textStrokeState.lineWidth=lineWidth;textStrokeState.miterLimit=miterLimit;textStrokeState.strokeStyle=strokeStyle;}}var textFont=textStyle.getFont();var textOffsetX=textStyle.getOffsetX();var textOffsetY=textStyle.getOffsetY();var textRotateWithView=textStyle.getRotateWithView();var textRotation=textStyle.getRotation();var textScale=textStyle.getScale();var textText=textStyle.getText();var textTextAlign=textStyle.getTextAlign();var textTextBaseline=textStyle.getTextBaseline();var font=textFont!==undefined?textFont:_ol_render_canvas_.defaultFont;var textAlign=textTextAlign!==undefined?textTextAlign:_ol_render_canvas_.defaultTextAlign;var textBaseline=textTextBaseline!==undefined?textTextBaseline:_ol_render_canvas_.defaultTextBaseline;if(!this.textState_){this.textState_={font:font,textAlign:textAlign,textBaseline:textBaseline};}else{var textState=this.textState_;textState.font=font;textState.textAlign=textAlign;textState.textBaseline=textBaseline;}this.text_=textText!==undefined?textText:'';this.textOffsetX_=textOffsetX!==undefined?textOffsetX:0;this.textOffsetY_=textOffsetY!==undefined?textOffsetY:0;this.textRotateWithView_=textRotateWithView!==undefined?textRotateWithView:false;this.textRotation_=textRotation!==undefined?textRotation:0;this.textScale_=textScale!==undefined?textScale:1;}};/**
 * @enum {string}
 */var _ol_render_ReplayType_={CIRCLE:'Circle',DEFAULT:'Default',IMAGE:'Image',LINE_STRING:'LineString',POLYGON:'Polygon',TEXT:'Text'};var _ol_render_replay_={};/**
 * @const
 * @type {Array.<ol.render.ReplayType>}
 */_ol_render_replay_.ORDER=[_ol_render_ReplayType_.POLYGON,_ol_render_ReplayType_.CIRCLE,_ol_render_ReplayType_.LINE_STRING,_ol_render_ReplayType_.IMAGE,_ol_render_ReplayType_.TEXT,_ol_render_ReplayType_.DEFAULT];/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay group can have overlapping geometries.
 * @param {number=} opt_renderBuffer Optional rendering buffer.
 * @struct
 */var _ol_render_canvas_ReplayGroup_=function(tolerance,maxExtent,resolution,overlaps,opt_renderBuffer){_ol_render_ReplayGroup_.call(this);/**
   * @private
   * @type {number}
   */this.tolerance_=tolerance;/**
   * @private
   * @type {ol.Extent}
   */this.maxExtent_=maxExtent;/**
   * @private
   * @type {boolean}
   */this.overlaps_=overlaps;/**
   * @private
   * @type {number}
   */this.resolution_=resolution;/**
   * @private
   * @type {number|undefined}
   */this.renderBuffer_=opt_renderBuffer;/**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.canvas.Replay>>}
   */this.replaysByZIndex_={};/**
   * @private
   * @type {CanvasRenderingContext2D}
   */this.hitDetectionContext_=_ol_dom_.createCanvasContext2D(1,1);/**
   * @private
   * @type {ol.Transform}
   */this.hitDetectionTransform_=_ol_transform_.create();};_ol_.inherits(_ol_render_canvas_ReplayGroup_,_ol_render_ReplayGroup_);/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}
 * @private
 */_ol_render_canvas_ReplayGroup_.circleArrayCache_={0:[[true]]};/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @private
 */_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_=function(array,x,y){var i;var radius=Math.floor(array.length/2);if(x>=radius){for(i=radius;i<x;i++){array[i][y]=true;}}else if(x<radius){for(i=x+1;i<radius;i++){array[i][y]=true;}}};/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.
 * @private
 */_ol_render_canvas_ReplayGroup_.getCircleArray_=function(radius){if(_ol_render_canvas_ReplayGroup_.circleArrayCache_[radius]!==undefined){return _ol_render_canvas_ReplayGroup_.circleArrayCache_[radius];}var arraySize=radius*2+1;var arr=new Array(arraySize);for(var i=0;i<arraySize;i++){arr[i]=new Array(arraySize);}var x=radius;var y=0;var error=0;while(x>=y){_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius+x,radius+y);_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius+y,radius+x);_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius-y,radius+x);_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius-x,radius+y);_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius-x,radius-y);_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius-y,radius-x);_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius+y,radius-x);_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr,radius+x,radius-y);y++;error+=1+2*y;if(2*(error-x)+1>0){x-=1;error+=1-2*x;}}_ol_render_canvas_ReplayGroup_.circleArrayCache_[radius]=arr;return arr;};/**
 * @param {Array.<ol.render.ReplayType>} replays Replays.
 * @return {boolean} Has replays of the provided types.
 */_ol_render_canvas_ReplayGroup_.prototype.hasReplays=function(replays){for(var zIndex in this.replaysByZIndex_){var candidates=this.replaysByZIndex_[zIndex];for(var i=0,ii=replays.length;i<ii;++i){if(replays[i]in candidates){return true;}}}return false;};/**
 * FIXME empty description for jsdoc
 */_ol_render_canvas_ReplayGroup_.prototype.finish=function(){var zKey;for(zKey in this.replaysByZIndex_){var replays=this.replaysByZIndex_[zKey];var replayKey;for(replayKey in replays){replays[replayKey].finish();}}};/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @return {T|undefined} Callback result.
 * @template T
 */_ol_render_canvas_ReplayGroup_.prototype.forEachFeatureAtCoordinate=function(coordinate,resolution,rotation,hitTolerance,skippedFeaturesHash,callback){hitTolerance=Math.round(hitTolerance);var contextSize=hitTolerance*2+1;var transform=_ol_transform_.compose(this.hitDetectionTransform_,hitTolerance+0.5,hitTolerance+0.5,1/resolution,-1/resolution,-rotation,-coordinate[0],-coordinate[1]);var context=this.hitDetectionContext_;if(context.canvas.width!==contextSize||context.canvas.height!==contextSize){context.canvas.width=contextSize;context.canvas.height=contextSize;}else{context.clearRect(0,0,contextSize,contextSize);}/**
   * @type {ol.Extent}
   */var hitExtent;if(this.renderBuffer_!==undefined){hitExtent=_ol_extent_.createEmpty();_ol_extent_.extendCoordinate(hitExtent,coordinate);_ol_extent_.buffer(hitExtent,resolution*(this.renderBuffer_+hitTolerance),hitExtent);}var mask=_ol_render_canvas_ReplayGroup_.getCircleArray_(hitTolerance);return this.replayHitDetection_(context,transform,rotation,skippedFeaturesHash,/**
       * @param {ol.Feature|ol.render.Feature} feature Feature.
       * @return {?} Callback result.
       */function(feature){var imageData=context.getImageData(0,0,contextSize,contextSize).data;for(var i=0;i<contextSize;i++){for(var j=0;j<contextSize;j++){if(mask[i][j]){if(imageData[(j*contextSize+i)*4+3]>0){var result=callback(feature);if(result){return result;}else{context.clearRect(0,0,contextSize,contextSize);return undefined;}}}}}},hitExtent);};/**
 * @param {ol.Transform} transform Transform.
 * @return {Array.<number>} Clip coordinates.
 */_ol_render_canvas_ReplayGroup_.prototype.getClipCoords=function(transform){var maxExtent=this.maxExtent_;var minX=maxExtent[0];var minY=maxExtent[1];var maxX=maxExtent[2];var maxY=maxExtent[3];var flatClipCoords=[minX,minY,minX,maxY,maxX,maxY,maxX,minY];_ol_geom_flat_transform_.transform2D(flatClipCoords,0,8,2,transform,flatClipCoords);return flatClipCoords;};/**
 * @inheritDoc
 */_ol_render_canvas_ReplayGroup_.prototype.getReplay=function(zIndex,replayType){var zIndexKey=zIndex!==undefined?zIndex.toString():'0';var replays=this.replaysByZIndex_[zIndexKey];if(replays===undefined){replays={};this.replaysByZIndex_[zIndexKey]=replays;}var replay=replays[replayType];if(replay===undefined){var Constructor=_ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];replay=new Constructor(this.tolerance_,this.maxExtent_,this.resolution_,this.overlaps_);replays[replayType]=replay;}return replay;};/**
 * @inheritDoc
 */_ol_render_canvas_ReplayGroup_.prototype.isEmpty=function(){return _ol_obj_.isEmpty(this.replaysByZIndex_);};/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<ol.render.ReplayType>=} opt_replayTypes Ordered replay types
 *     to replay. Default is {@link ol.render.replay.ORDER}
 */_ol_render_canvas_ReplayGroup_.prototype.replay=function(context,pixelRatio,transform,viewRotation,skippedFeaturesHash,opt_replayTypes){/** @type {Array.<number>} */var zs=Object.keys(this.replaysByZIndex_).map(Number);zs.sort(_ol_array_.numberSafeCompareFunction);// setup clipping so that the parts of over-simplified geometries are not
// visible outside the current extent when panning
var flatClipCoords=this.getClipCoords(transform);context.save();context.beginPath();context.moveTo(flatClipCoords[0],flatClipCoords[1]);context.lineTo(flatClipCoords[2],flatClipCoords[3]);context.lineTo(flatClipCoords[4],flatClipCoords[5]);context.lineTo(flatClipCoords[6],flatClipCoords[7]);context.clip();var replayTypes=opt_replayTypes?opt_replayTypes:_ol_render_replay_.ORDER;var i,ii,j,jj,replays,replay;for(i=0,ii=zs.length;i<ii;++i){replays=this.replaysByZIndex_[zs[i].toString()];for(j=0,jj=replayTypes.length;j<jj;++j){replay=replays[replayTypes[j]];if(replay!==undefined){replay.replay(context,pixelRatio,transform,viewRotation,skippedFeaturesHash);}}}context.restore();};/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */_ol_render_canvas_ReplayGroup_.prototype.replayHitDetection_=function(context,transform,viewRotation,skippedFeaturesHash,featureCallback,opt_hitExtent){/** @type {Array.<number>} */var zs=Object.keys(this.replaysByZIndex_).map(Number);zs.sort(function(a,b){return b-a;});var i,ii,j,replays,replay,result;for(i=0,ii=zs.length;i<ii;++i){replays=this.replaysByZIndex_[zs[i].toString()];for(j=_ol_render_replay_.ORDER.length-1;j>=0;--j){replay=replays[_ol_render_replay_.ORDER[j]];if(replay!==undefined){result=replay.replayHitDetection(context,transform,viewRotation,skippedFeaturesHash,featureCallback,opt_hitExtent);if(result){return result;}}}}return undefined;};/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.canvas.Replay, number, ol.Extent,
 *                number, boolean)>}
 */_ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_={'Circle':_ol_render_canvas_PolygonReplay_,'Default':_ol_render_canvas_Replay_,'Image':_ol_render_canvas_ImageReplay_,'LineString':_ol_render_canvas_LineStringReplay_,'Polygon':_ol_render_canvas_PolygonReplay_,'Text':_ol_render_canvas_TextReplay_};/**
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.render.Event}
 * @param {ol.render.EventType} type Type.
 * @param {ol.render.VectorContext=} opt_vectorContext Vector context.
 * @param {olx.FrameState=} opt_frameState Frame state.
 * @param {?CanvasRenderingContext2D=} opt_context Context.
 * @param {?ol.webgl.Context=} opt_glContext WebGL Context.
 */var _ol_render_Event_=function(type,opt_vectorContext,opt_frameState,opt_context,opt_glContext){_ol_events_Event_.call(this,type);/**
   * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.
   * @type {ol.render.VectorContext|undefined}
   * @api
   */this.vectorContext=opt_vectorContext;/**
   * An object representing the current render frame state.
   * @type {olx.FrameState|undefined}
   * @api
   */this.frameState=opt_frameState;/**
   * Canvas context. Only available when a Canvas renderer is used, null
   * otherwise.
   * @type {CanvasRenderingContext2D|null|undefined}
   * @api
   */this.context=opt_context;/**
   * WebGL context. Only available when a WebGL renderer is used, null
   * otherwise.
   * @type {ol.webgl.Context|null|undefined}
   * @api
   */this.glContext=opt_glContext;};_ol_.inherits(_ol_render_Event_,_ol_events_Event_);// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol.geom.flat.transform.transform2D?
/**
 * @classdesc
 * A concrete subclass of {@link ol.render.VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link ol.render.Event} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 *
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Extent} extent Extent.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @struct
 */var _ol_render_canvas_Immediate_=function(context,pixelRatio,extent,transform,viewRotation){_ol_render_VectorContext_.call(this);/**
   * @private
   * @type {CanvasRenderingContext2D}
   */this.context_=context;/**
   * @private
   * @type {number}
   */this.pixelRatio_=pixelRatio;/**
   * @private
   * @type {ol.Extent}
   */this.extent_=extent;/**
   * @private
   * @type {ol.Transform}
   */this.transform_=transform;/**
   * @private
   * @type {number}
   */this.viewRotation_=viewRotation;/**
   * @private
   * @type {?ol.CanvasFillState}
   */this.contextFillState_=null;/**
   * @private
   * @type {?ol.CanvasStrokeState}
   */this.contextStrokeState_=null;/**
   * @private
   * @type {?ol.CanvasTextState}
   */this.contextTextState_=null;/**
   * @private
   * @type {?ol.CanvasFillState}
   */this.fillState_=null;/**
   * @private
   * @type {?ol.CanvasStrokeState}
   */this.strokeState_=null;/**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */this.image_=null;/**
   * @private
   * @type {number}
   */this.imageAnchorX_=0;/**
   * @private
   * @type {number}
   */this.imageAnchorY_=0;/**
   * @private
   * @type {number}
   */this.imageHeight_=0;/**
   * @private
   * @type {number}
   */this.imageOpacity_=0;/**
   * @private
   * @type {number}
   */this.imageOriginX_=0;/**
   * @private
   * @type {number}
   */this.imageOriginY_=0;/**
   * @private
   * @type {boolean}
   */this.imageRotateWithView_=false;/**
   * @private
   * @type {number}
   */this.imageRotation_=0;/**
   * @private
   * @type {number}
   */this.imageScale_=0;/**
   * @private
   * @type {boolean}
   */this.imageSnapToPixel_=false;/**
   * @private
   * @type {number}
   */this.imageWidth_=0;/**
   * @private
   * @type {string}
   */this.text_='';/**
   * @private
   * @type {number}
   */this.textOffsetX_=0;/**
   * @private
   * @type {number}
   */this.textOffsetY_=0;/**
   * @private
   * @type {boolean}
   */this.textRotateWithView_=false;/**
   * @private
   * @type {number}
   */this.textRotation_=0;/**
   * @private
   * @type {number}
   */this.textScale_=0;/**
   * @private
   * @type {?ol.CanvasFillState}
   */this.textFillState_=null;/**
   * @private
   * @type {?ol.CanvasStrokeState}
   */this.textStrokeState_=null;/**
   * @private
   * @type {?ol.CanvasTextState}
   */this.textState_=null;/**
   * @private
   * @type {Array.<number>}
   */this.pixelCoordinates_=[];/**
   * @private
   * @type {ol.Transform}
   */this.tmpLocalTransform_=_ol_transform_.create();};_ol_.inherits(_ol_render_canvas_Immediate_,_ol_render_VectorContext_);/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */_ol_render_canvas_Immediate_.prototype.drawImages_=function(flatCoordinates,offset,end,stride){if(!this.image_){return;}var pixelCoordinates=_ol_geom_flat_transform_.transform2D(flatCoordinates,offset,end,2,this.transform_,this.pixelCoordinates_);var context=this.context_;var localTransform=this.tmpLocalTransform_;var alpha=context.globalAlpha;if(this.imageOpacity_!=1){context.globalAlpha=alpha*this.imageOpacity_;}var rotation=this.imageRotation_;if(this.imageRotateWithView_){rotation+=this.viewRotation_;}var i,ii;for(i=0,ii=pixelCoordinates.length;i<ii;i+=2){var x=pixelCoordinates[i]-this.imageAnchorX_;var y=pixelCoordinates[i+1]-this.imageAnchorY_;if(this.imageSnapToPixel_){x=Math.round(x);y=Math.round(y);}if(rotation!==0||this.imageScale_!=1){var centerX=x+this.imageAnchorX_;var centerY=y+this.imageAnchorY_;_ol_transform_.compose(localTransform,centerX,centerY,this.imageScale_,this.imageScale_,rotation,-centerX,-centerY);context.setTransform.apply(context,localTransform);}context.drawImage(this.image_,this.imageOriginX_,this.imageOriginY_,this.imageWidth_,this.imageHeight_,x,y,this.imageWidth_,this.imageHeight_);}if(rotation!==0||this.imageScale_!=1){context.setTransform(1,0,0,1,0,0);}if(this.imageOpacity_!=1){context.globalAlpha=alpha;}};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */_ol_render_canvas_Immediate_.prototype.drawText_=function(flatCoordinates,offset,end,stride){if(!this.textState_||this.text_===''){return;}if(this.textFillState_){this.setContextFillState_(this.textFillState_);}if(this.textStrokeState_){this.setContextStrokeState_(this.textStrokeState_);}this.setContextTextState_(this.textState_);var pixelCoordinates=_ol_geom_flat_transform_.transform2D(flatCoordinates,offset,end,stride,this.transform_,this.pixelCoordinates_);var context=this.context_;var rotation=this.textRotation_;if(this.textRotateWithView_){rotation+=this.viewRotation_;}for(;offset<end;offset+=stride){var x=pixelCoordinates[offset]+this.textOffsetX_;var y=pixelCoordinates[offset+1]+this.textOffsetY_;if(rotation!==0||this.textScale_!=1){var localTransform=_ol_transform_.compose(this.tmpLocalTransform_,x,y,this.textScale_,this.textScale_,rotation,-x,-y);context.setTransform.apply(context,localTransform);}if(this.textStrokeState_){context.strokeText(this.text_,x,y);}if(this.textFillState_){context.fillText(this.text_,x,y);}}if(rotation!==0||this.textScale_!=1){context.setTransform(1,0,0,1,0,0);}};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} close Close.
 * @private
 * @return {number} end End.
 */_ol_render_canvas_Immediate_.prototype.moveToLineTo_=function(flatCoordinates,offset,end,stride,close){var context=this.context_;var pixelCoordinates=_ol_geom_flat_transform_.transform2D(flatCoordinates,offset,end,stride,this.transform_,this.pixelCoordinates_);context.moveTo(pixelCoordinates[0],pixelCoordinates[1]);var length=pixelCoordinates.length;if(close){length-=2;}for(var i=2;i<length;i+=2){context.lineTo(pixelCoordinates[i],pixelCoordinates[i+1]);}if(close){context.closePath();}return end;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */_ol_render_canvas_Immediate_.prototype.drawRings_=function(flatCoordinates,offset,ends,stride){var i,ii;for(i=0,ii=ends.length;i<ii;++i){offset=this.moveToLineTo_(flatCoordinates,offset,ends[i],stride,true);}return offset;};/**
 * Render a circle geometry into the canvas.  Rendering is immediate and uses
 * the current fill and stroke styles.
 *
 * @param {ol.geom.Circle} geometry Circle geometry.
 * @override
 * @api
 */_ol_render_canvas_Immediate_.prototype.drawCircle=function(geometry){if(!_ol_extent_.intersects(this.extent_,geometry.getExtent())){return;}if(this.fillState_||this.strokeState_){if(this.fillState_){this.setContextFillState_(this.fillState_);}if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);}var pixelCoordinates=_ol_geom_SimpleGeometry_.transform2D(geometry,this.transform_,this.pixelCoordinates_);var dx=pixelCoordinates[2]-pixelCoordinates[0];var dy=pixelCoordinates[3]-pixelCoordinates[1];var radius=Math.sqrt(dx*dx+dy*dy);var context=this.context_;context.beginPath();context.arc(pixelCoordinates[0],pixelCoordinates[1],radius,0,2*Math.PI);if(this.fillState_){context.fill();}if(this.strokeState_){context.stroke();}}if(this.text_!==''){this.drawText_(geometry.getCenter(),0,2,2);}};/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */_ol_render_canvas_Immediate_.prototype.setStyle=function(style){this.setFillStrokeStyle(style.getFill(),style.getStroke());this.setImageStyle(style.getImage());this.setTextStyle(style.getText());};/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.canvas.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */_ol_render_canvas_Immediate_.prototype.drawGeometry=function(geometry){var type=geometry.getType();switch(type){case _ol_geom_GeometryType_.POINT:this.drawPoint(/** @type {ol.geom.Point} */geometry);break;case _ol_geom_GeometryType_.LINE_STRING:this.drawLineString(/** @type {ol.geom.LineString} */geometry);break;case _ol_geom_GeometryType_.POLYGON:this.drawPolygon(/** @type {ol.geom.Polygon} */geometry);break;case _ol_geom_GeometryType_.MULTI_POINT:this.drawMultiPoint(/** @type {ol.geom.MultiPoint} */geometry);break;case _ol_geom_GeometryType_.MULTI_LINE_STRING:this.drawMultiLineString(/** @type {ol.geom.MultiLineString} */geometry);break;case _ol_geom_GeometryType_.MULTI_POLYGON:this.drawMultiPolygon(/** @type {ol.geom.MultiPolygon} */geometry);break;case _ol_geom_GeometryType_.GEOMETRY_COLLECTION:this.drawGeometryCollection(/** @type {ol.geom.GeometryCollection} */geometry);break;case _ol_geom_GeometryType_.CIRCLE:this.drawCircle(/** @type {ol.geom.Circle} */geometry);break;default:}};/**
 * Render a feature into the canvas.  Note that any `zIndex` on the provided
 * style will be ignored - features are rendered immediately in the order that
 * this method is called.  If you need `zIndex` support, you should be using an
 * {@link ol.layer.Vector} instead.
 *
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @override
 * @api
 */_ol_render_canvas_Immediate_.prototype.drawFeature=function(feature,style){var geometry=style.getGeometryFunction()(feature);if(!geometry||!_ol_extent_.intersects(this.extent_,geometry.getExtent())){return;}this.setStyle(style);this.drawGeometry(geometry);};/**
 * Render a GeometryCollection to the canvas.  Rendering is immediate and
 * uses the current styles appropriate for each geometry in the collection.
 *
 * @param {ol.geom.GeometryCollection} geometry Geometry collection.
 * @override
 */_ol_render_canvas_Immediate_.prototype.drawGeometryCollection=function(geometry){var geometries=geometry.getGeometriesArray();var i,ii;for(i=0,ii=geometries.length;i<ii;++i){this.drawGeometry(geometries[i]);}};/**
 * Render a Point geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Point|ol.render.Feature} geometry Point geometry.
 * @override
 */_ol_render_canvas_Immediate_.prototype.drawPoint=function(geometry){var flatCoordinates=geometry.getFlatCoordinates();var stride=geometry.getStride();if(this.image_){this.drawImages_(flatCoordinates,0,flatCoordinates.length,stride);}if(this.text_!==''){this.drawText_(flatCoordinates,0,flatCoordinates.length,stride);}};/**
 * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
 * uses the current style.
 *
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry MultiPoint geometry.
 * @override
 */_ol_render_canvas_Immediate_.prototype.drawMultiPoint=function(geometry){var flatCoordinates=geometry.getFlatCoordinates();var stride=geometry.getStride();if(this.image_){this.drawImages_(flatCoordinates,0,flatCoordinates.length,stride);}if(this.text_!==''){this.drawText_(flatCoordinates,0,flatCoordinates.length,stride);}};/**
 * Render a LineString into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.LineString|ol.render.Feature} geometry LineString geometry.
 * @override
 */_ol_render_canvas_Immediate_.prototype.drawLineString=function(geometry){if(!_ol_extent_.intersects(this.extent_,geometry.getExtent())){return;}if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);var context=this.context_;var flatCoordinates=geometry.getFlatCoordinates();context.beginPath();this.moveToLineTo_(flatCoordinates,0,flatCoordinates.length,geometry.getStride(),false);context.stroke();}if(this.text_!==''){var flatMidpoint=geometry.getFlatMidpoint();this.drawText_(flatMidpoint,0,2,2);}};/**
 * Render a MultiLineString geometry into the canvas.  Rendering is immediate
 * and uses the current style.
 *
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry MultiLineString
 *     geometry.
 * @override
 */_ol_render_canvas_Immediate_.prototype.drawMultiLineString=function(geometry){var geometryExtent=geometry.getExtent();if(!_ol_extent_.intersects(this.extent_,geometryExtent)){return;}if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);var context=this.context_;var flatCoordinates=geometry.getFlatCoordinates();var offset=0;var ends=geometry.getEnds();var stride=geometry.getStride();context.beginPath();var i,ii;for(i=0,ii=ends.length;i<ii;++i){offset=this.moveToLineTo_(flatCoordinates,offset,ends[i],stride,false);}context.stroke();}if(this.text_!==''){var flatMidpoints=geometry.getFlatMidpoints();this.drawText_(flatMidpoints,0,flatMidpoints.length,2);}};/**
 * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Polygon geometry.
 * @override
 */_ol_render_canvas_Immediate_.prototype.drawPolygon=function(geometry){if(!_ol_extent_.intersects(this.extent_,geometry.getExtent())){return;}if(this.strokeState_||this.fillState_){if(this.fillState_){this.setContextFillState_(this.fillState_);}if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);}var context=this.context_;context.beginPath();this.drawRings_(geometry.getOrientedFlatCoordinates(),0,geometry.getEnds(),geometry.getStride());if(this.fillState_){context.fill();}if(this.strokeState_){context.stroke();}}if(this.text_!==''){var flatInteriorPoint=geometry.getFlatInteriorPoint();this.drawText_(flatInteriorPoint,0,2,2);}};/**
 * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
 * uses the current style.
 * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.
 * @override
 */_ol_render_canvas_Immediate_.prototype.drawMultiPolygon=function(geometry){if(!_ol_extent_.intersects(this.extent_,geometry.getExtent())){return;}if(this.strokeState_||this.fillState_){if(this.fillState_){this.setContextFillState_(this.fillState_);}if(this.strokeState_){this.setContextStrokeState_(this.strokeState_);}var context=this.context_;var flatCoordinates=geometry.getOrientedFlatCoordinates();var offset=0;var endss=geometry.getEndss();var stride=geometry.getStride();var i,ii;context.beginPath();for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];offset=this.drawRings_(flatCoordinates,offset,ends,stride);}if(this.fillState_){context.fill();}if(this.strokeState_){context.stroke();}}if(this.text_!==''){var flatInteriorPoints=geometry.getFlatInteriorPoints();this.drawText_(flatInteriorPoints,0,flatInteriorPoints.length,2);}};/**
 * @param {ol.CanvasFillState} fillState Fill state.
 * @private
 */_ol_render_canvas_Immediate_.prototype.setContextFillState_=function(fillState){var context=this.context_;var contextFillState=this.contextFillState_;if(!contextFillState){context.fillStyle=fillState.fillStyle;this.contextFillState_={fillStyle:fillState.fillStyle};}else{if(contextFillState.fillStyle!=fillState.fillStyle){contextFillState.fillStyle=context.fillStyle=fillState.fillStyle;}}};/**
 * @param {ol.CanvasStrokeState} strokeState Stroke state.
 * @private
 */_ol_render_canvas_Immediate_.prototype.setContextStrokeState_=function(strokeState){var context=this.context_;var contextStrokeState=this.contextStrokeState_;if(!contextStrokeState){context.lineCap=strokeState.lineCap;if(_ol_has_.CANVAS_LINE_DASH){context.setLineDash(strokeState.lineDash);context.lineDashOffset=strokeState.lineDashOffset;}context.lineJoin=strokeState.lineJoin;context.lineWidth=strokeState.lineWidth;context.miterLimit=strokeState.miterLimit;context.strokeStyle=strokeState.strokeStyle;this.contextStrokeState_={lineCap:strokeState.lineCap,lineDash:strokeState.lineDash,lineDashOffset:strokeState.lineDashOffset,lineJoin:strokeState.lineJoin,lineWidth:strokeState.lineWidth,miterLimit:strokeState.miterLimit,strokeStyle:strokeState.strokeStyle};}else{if(contextStrokeState.lineCap!=strokeState.lineCap){contextStrokeState.lineCap=context.lineCap=strokeState.lineCap;}if(_ol_has_.CANVAS_LINE_DASH){if(!_ol_array_.equals(contextStrokeState.lineDash,strokeState.lineDash)){context.setLineDash(contextStrokeState.lineDash=strokeState.lineDash);}if(contextStrokeState.lineDashOffset!=strokeState.lineDashOffset){contextStrokeState.lineDashOffset=context.lineDashOffset=strokeState.lineDashOffset;}}if(contextStrokeState.lineJoin!=strokeState.lineJoin){contextStrokeState.lineJoin=context.lineJoin=strokeState.lineJoin;}if(contextStrokeState.lineWidth!=strokeState.lineWidth){contextStrokeState.lineWidth=context.lineWidth=strokeState.lineWidth;}if(contextStrokeState.miterLimit!=strokeState.miterLimit){contextStrokeState.miterLimit=context.miterLimit=strokeState.miterLimit;}if(contextStrokeState.strokeStyle!=strokeState.strokeStyle){contextStrokeState.strokeStyle=context.strokeStyle=strokeState.strokeStyle;}}};/**
 * @param {ol.CanvasTextState} textState Text state.
 * @private
 */_ol_render_canvas_Immediate_.prototype.setContextTextState_=function(textState){var context=this.context_;var contextTextState=this.contextTextState_;if(!contextTextState){context.font=textState.font;context.textAlign=textState.textAlign;context.textBaseline=textState.textBaseline;this.contextTextState_={font:textState.font,textAlign:textState.textAlign,textBaseline:textState.textBaseline};}else{if(contextTextState.font!=textState.font){contextTextState.font=context.font=textState.font;}if(contextTextState.textAlign!=textState.textAlign){contextTextState.textAlign=context.textAlign=textState.textAlign;}if(contextTextState.textBaseline!=textState.textBaseline){contextTextState.textBaseline=context.textBaseline=textState.textBaseline;}}};/**
 * Set the fill and stroke style for subsequent draw operations.  To clear
 * either fill or stroke styles, pass null for the appropriate parameter.
 *
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 * @override
 */_ol_render_canvas_Immediate_.prototype.setFillStrokeStyle=function(fillStyle,strokeStyle){if(!fillStyle){this.fillState_=null;}else{var fillStyleColor=fillStyle.getColor();this.fillState_={fillStyle:_ol_colorlike_.asColorLike(fillStyleColor?fillStyleColor:_ol_render_canvas_.defaultFillStyle)};}if(!strokeStyle){this.strokeState_=null;}else{var strokeStyleColor=strokeStyle.getColor();var strokeStyleLineCap=strokeStyle.getLineCap();var strokeStyleLineDash=strokeStyle.getLineDash();var strokeStyleLineDashOffset=strokeStyle.getLineDashOffset();var strokeStyleLineJoin=strokeStyle.getLineJoin();var strokeStyleWidth=strokeStyle.getWidth();var strokeStyleMiterLimit=strokeStyle.getMiterLimit();this.strokeState_={lineCap:strokeStyleLineCap!==undefined?strokeStyleLineCap:_ol_render_canvas_.defaultLineCap,lineDash:strokeStyleLineDash?strokeStyleLineDash:_ol_render_canvas_.defaultLineDash,lineDashOffset:strokeStyleLineDashOffset?strokeStyleLineDashOffset:_ol_render_canvas_.defaultLineDashOffset,lineJoin:strokeStyleLineJoin!==undefined?strokeStyleLineJoin:_ol_render_canvas_.defaultLineJoin,lineWidth:this.pixelRatio_*(strokeStyleWidth!==undefined?strokeStyleWidth:_ol_render_canvas_.defaultLineWidth),miterLimit:strokeStyleMiterLimit!==undefined?strokeStyleMiterLimit:_ol_render_canvas_.defaultMiterLimit,strokeStyle:_ol_colorlike_.asColorLike(strokeStyleColor?strokeStyleColor:_ol_render_canvas_.defaultStrokeStyle)};}};/**
 * Set the image style for subsequent draw operations.  Pass null to remove
 * the image style.
 *
 * @param {ol.style.Image} imageStyle Image style.
 * @override
 */_ol_render_canvas_Immediate_.prototype.setImageStyle=function(imageStyle){if(!imageStyle){this.image_=null;}else{var imageAnchor=imageStyle.getAnchor();// FIXME pixel ratio
var imageImage=imageStyle.getImage(1);var imageOrigin=imageStyle.getOrigin();var imageSize=imageStyle.getSize();this.imageAnchorX_=imageAnchor[0];this.imageAnchorY_=imageAnchor[1];this.imageHeight_=imageSize[1];this.image_=imageImage;this.imageOpacity_=imageStyle.getOpacity();this.imageOriginX_=imageOrigin[0];this.imageOriginY_=imageOrigin[1];this.imageRotateWithView_=imageStyle.getRotateWithView();this.imageRotation_=imageStyle.getRotation();this.imageScale_=imageStyle.getScale()*this.pixelRatio_;this.imageSnapToPixel_=imageStyle.getSnapToPixel();this.imageWidth_=imageSize[0];}};/**
 * Set the text style for subsequent draw operations.  Pass null to
 * remove the text style.
 *
 * @param {ol.style.Text} textStyle Text style.
 * @override
 */_ol_render_canvas_Immediate_.prototype.setTextStyle=function(textStyle){if(!textStyle){this.text_='';}else{var textFillStyle=textStyle.getFill();if(!textFillStyle){this.textFillState_=null;}else{var textFillStyleColor=textFillStyle.getColor();this.textFillState_={fillStyle:_ol_colorlike_.asColorLike(textFillStyleColor?textFillStyleColor:_ol_render_canvas_.defaultFillStyle)};}var textStrokeStyle=textStyle.getStroke();if(!textStrokeStyle){this.textStrokeState_=null;}else{var textStrokeStyleColor=textStrokeStyle.getColor();var textStrokeStyleLineCap=textStrokeStyle.getLineCap();var textStrokeStyleLineDash=textStrokeStyle.getLineDash();var textStrokeStyleLineDashOffset=textStrokeStyle.getLineDashOffset();var textStrokeStyleLineJoin=textStrokeStyle.getLineJoin();var textStrokeStyleWidth=textStrokeStyle.getWidth();var textStrokeStyleMiterLimit=textStrokeStyle.getMiterLimit();this.textStrokeState_={lineCap:textStrokeStyleLineCap!==undefined?textStrokeStyleLineCap:_ol_render_canvas_.defaultLineCap,lineDash:textStrokeStyleLineDash?textStrokeStyleLineDash:_ol_render_canvas_.defaultLineDash,lineDashOffset:textStrokeStyleLineDashOffset?textStrokeStyleLineDashOffset:_ol_render_canvas_.defaultLineDashOffset,lineJoin:textStrokeStyleLineJoin!==undefined?textStrokeStyleLineJoin:_ol_render_canvas_.defaultLineJoin,lineWidth:textStrokeStyleWidth!==undefined?textStrokeStyleWidth:_ol_render_canvas_.defaultLineWidth,miterLimit:textStrokeStyleMiterLimit!==undefined?textStrokeStyleMiterLimit:_ol_render_canvas_.defaultMiterLimit,strokeStyle:_ol_colorlike_.asColorLike(textStrokeStyleColor?textStrokeStyleColor:_ol_render_canvas_.defaultStrokeStyle)};}var textFont=textStyle.getFont();var textOffsetX=textStyle.getOffsetX();var textOffsetY=textStyle.getOffsetY();var textRotateWithView=textStyle.getRotateWithView();var textRotation=textStyle.getRotation();var textScale=textStyle.getScale();var textText=textStyle.getText();var textTextAlign=textStyle.getTextAlign();var textTextBaseline=textStyle.getTextBaseline();this.textState_={font:textFont!==undefined?textFont:_ol_render_canvas_.defaultFont,textAlign:textTextAlign!==undefined?textTextAlign:_ol_render_canvas_.defaultTextAlign,textBaseline:textTextBaseline!==undefined?textTextBaseline:_ol_render_canvas_.defaultTextBaseline};this.text_=textText!==undefined?textText:'';this.textOffsetX_=textOffsetX!==undefined?this.pixelRatio_*textOffsetX:0;this.textOffsetY_=textOffsetY!==undefined?this.pixelRatio_*textOffsetY:0;this.textRotateWithView_=textRotateWithView!==undefined?textRotateWithView:false;this.textRotation_=textRotation!==undefined?textRotation:0;this.textScale_=this.pixelRatio_*(textScale!==undefined?textScale:1);}};/**
 * @enum {number}
 */var _ol_TileState_={IDLE:0,LOADING:1,LOADED:2,ERROR:3,EMPTY:4,ABORT:5};/**
 * @constructor
 * @extends {ol.Observable}
 * @param {ol.layer.Layer} layer Layer.
 * @struct
 */var _ol_renderer_Layer_=function(layer){_ol_Observable_.call(this);/**
   * @private
   * @type {ol.layer.Layer}
   */this.layer_=layer;};_ol_.inherits(_ol_renderer_Layer_,_ol_Observable_);/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}
 *     callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T
 */_ol_renderer_Layer_.prototype.forEachFeatureAtCoordinate=_ol_.nullFunction;/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @return {boolean} Is there a feature at the given coordinate?
 */_ol_renderer_Layer_.prototype.hasFeatureAtCoordinate=_ol_functions_.FALSE;/**
 * Create a function that adds loaded tiles to the tile lookup.
 * @param {ol.source.Tile} source Tile source.
 * @param {ol.proj.Projection} projection Projection of the tiles.
 * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded
 *     tiles by zoom level.
 * @return {function(number, ol.TileRange):boolean} A function that can be
 *     called with a zoom level and a tile range to add loaded tiles to the
 *     lookup.
 * @protected
 */_ol_renderer_Layer_.prototype.createLoadedTileFinder=function(source,projection,tiles){return(/**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */function(zoom,tileRange){function callback(tile){if(!tiles[zoom]){tiles[zoom]={};}tiles[zoom][tile.tileCoord.toString()]=tile;}return source.forEachLoadedTile(projection,zoom,tileRange,callback);});};/**
 * @return {ol.layer.Layer} Layer.
 */_ol_renderer_Layer_.prototype.getLayer=function(){return this.layer_;};/**
 * Handle changes in image state.
 * @param {ol.events.Event} event Image change event.
 * @private
 */_ol_renderer_Layer_.prototype.handleImageChange_=function(event){var image=/** @type {ol.Image} */event.target;if(image.getState()===_ol_ImageState_.LOADED){this.renderIfReadyAndVisible();}};/**
 * Load the image if not already loaded, and register the image change
 * listener if needed.
 * @param {ol.ImageBase} image Image.
 * @return {boolean} `true` if the image is already loaded, `false`
 *     otherwise.
 * @protected
 */_ol_renderer_Layer_.prototype.loadImage=function(image){var imageState=image.getState();if(imageState!=_ol_ImageState_.LOADED&&imageState!=_ol_ImageState_.ERROR){_ol_events_.listen(image,_ol_events_EventType_.CHANGE,this.handleImageChange_,this);}if(imageState==_ol_ImageState_.IDLE){image.load();imageState=image.getState();}return imageState==_ol_ImageState_.LOADED;};/**
 * @protected
 */_ol_renderer_Layer_.prototype.renderIfReadyAndVisible=function(){var layer=this.getLayer();if(layer.getVisible()&&layer.getSourceState()==_ol_source_State_.READY){this.changed();}};/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @protected
 */_ol_renderer_Layer_.prototype.scheduleExpireCache=function(frameState,tileSource){if(tileSource.canExpireCache()){/**
     * @param {ol.source.Tile} tileSource Tile source.
     * @param {ol.Map} map Map.
     * @param {olx.FrameState} frameState Frame state.
     */var postRenderFunction=function(tileSource,map,frameState){var tileSourceKey=_ol_.getUid(tileSource).toString();if(tileSourceKey in frameState.usedTiles){tileSource.expireCache(frameState.viewState.projection,frameState.usedTiles[tileSourceKey]);}}.bind(null,tileSource);frameState.postRenderFunctions.push(/** @type {ol.PostRenderFunction} */postRenderFunction);}};/**
 * @param {Object.<string, ol.Attribution>} attributionsSet Attributions
 *     set (target).
 * @param {Array.<ol.Attribution>} attributions Attributions (source).
 * @protected
 */_ol_renderer_Layer_.prototype.updateAttributions=function(attributionsSet,attributions){if(attributions){var attribution,i,ii;for(i=0,ii=attributions.length;i<ii;++i){attribution=attributions[i];attributionsSet[_ol_.getUid(attribution).toString()]=attribution;}}};/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Source} source Source.
 * @protected
 */_ol_renderer_Layer_.prototype.updateLogos=function(frameState,source){var logo=source.getLogo();if(logo!==undefined){if(typeof logo==='string'){frameState.logos[logo]='';}else if(logo){_ol_asserts_.assert(typeof logo.href=='string',44);// `logo.href` should be a string.
_ol_asserts_.assert(typeof logo.src=='string',45);// `logo.src` should be a string.
frameState.logos[logo.src]=logo.href;}}};/**
 * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {number} z Z.
 * @param {ol.TileRange} tileRange Tile range.
 * @protected
 */_ol_renderer_Layer_.prototype.updateUsedTiles=function(usedTiles,tileSource,z,tileRange){// FIXME should we use tilesToDrawByZ instead?
var tileSourceKey=_ol_.getUid(tileSource).toString();var zKey=z.toString();if(tileSourceKey in usedTiles){if(zKey in usedTiles[tileSourceKey]){usedTiles[tileSourceKey][zKey].extend(tileRange);}else{usedTiles[tileSourceKey][zKey]=tileRange;}}else{usedTiles[tileSourceKey]={};usedTiles[tileSourceKey][zKey]=tileRange;}};/**
 * Manage tile pyramid.
 * This function performs a number of functions related to the tiles at the
 * current zoom and lower zoom levels:
 * - registers idle tiles in frameState.wantedTiles so that they are not
 *   discarded by the tile queue
 * - enqueues missing tiles
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {ol.Extent} extent Extent.
 * @param {number} currentZ Current Z.
 * @param {number} preload Load low resolution tiles up to 'preload' levels.
 * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.
 * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
 * @protected
 * @template T
 */_ol_renderer_Layer_.prototype.manageTilePyramid=function(frameState,tileSource,tileGrid,pixelRatio,projection,extent,currentZ,preload,opt_tileCallback,opt_this){var tileSourceKey=_ol_.getUid(tileSource).toString();if(!(tileSourceKey in frameState.wantedTiles)){frameState.wantedTiles[tileSourceKey]={};}var wantedTiles=frameState.wantedTiles[tileSourceKey];var tileQueue=frameState.tileQueue;var minZoom=tileGrid.getMinZoom();var tile,tileRange,tileResolution,x,y,z;for(z=currentZ;z>=minZoom;--z){tileRange=tileGrid.getTileRangeForExtentAndZ(extent,z,tileRange);tileResolution=tileGrid.getResolution(z);for(x=tileRange.minX;x<=tileRange.maxX;++x){for(y=tileRange.minY;y<=tileRange.maxY;++y){if(currentZ-z<=preload){tile=tileSource.getTile(z,x,y,pixelRatio,projection);if(tile.getState()==_ol_TileState_.IDLE){wantedTiles[tile.getKey()]=true;if(!tileQueue.isKeyQueued(tile.getKey())){tileQueue.enqueue([tile,tileSourceKey,tileGrid.getTileCoordCenter(tile.tileCoord),tileResolution]);}}if(opt_tileCallback!==undefined){opt_tileCallback.call(opt_this,tile);}}else{tileSource.useTile(z,x,y,projection);}}}}};/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */var _ol_renderer_canvas_Layer_=function(layer){_ol_renderer_Layer_.call(this,layer);/**
   * @protected
   * @type {number}
   */this.renderedResolution;/**
   * @private
   * @type {ol.Transform}
   */this.transform_=_ol_transform_.create();};_ol_.inherits(_ol_renderer_canvas_Layer_,_ol_renderer_Layer_);/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Extent} extent Clip extent.
 * @protected
 */_ol_renderer_canvas_Layer_.prototype.clip=function(context,frameState,extent){var pixelRatio=frameState.pixelRatio;var width=frameState.size[0]*pixelRatio;var height=frameState.size[1]*pixelRatio;var rotation=frameState.viewState.rotation;var topLeft=_ol_extent_.getTopLeft(/** @type {ol.Extent} */extent);var topRight=_ol_extent_.getTopRight(/** @type {ol.Extent} */extent);var bottomRight=_ol_extent_.getBottomRight(/** @type {ol.Extent} */extent);var bottomLeft=_ol_extent_.getBottomLeft(/** @type {ol.Extent} */extent);_ol_transform_.apply(frameState.coordinateToPixelTransform,topLeft);_ol_transform_.apply(frameState.coordinateToPixelTransform,topRight);_ol_transform_.apply(frameState.coordinateToPixelTransform,bottomRight);_ol_transform_.apply(frameState.coordinateToPixelTransform,bottomLeft);context.save();_ol_render_canvas_.rotateAtOffset(context,-rotation,width/2,height/2);context.beginPath();context.moveTo(topLeft[0]*pixelRatio,topLeft[1]*pixelRatio);context.lineTo(topRight[0]*pixelRatio,topRight[1]*pixelRatio);context.lineTo(bottomRight[0]*pixelRatio,bottomRight[1]*pixelRatio);context.lineTo(bottomLeft[0]*pixelRatio,bottomLeft[1]*pixelRatio);context.clip();_ol_render_canvas_.rotateAtOffset(context,rotation,width/2,height/2);};/**
 * @param {ol.render.EventType} type Event type.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @private
 */_ol_renderer_canvas_Layer_.prototype.dispatchComposeEvent_=function(type,context,frameState,opt_transform){var layer=this.getLayer();if(layer.hasListener(type)){var width=frameState.size[0]*frameState.pixelRatio;var height=frameState.size[1]*frameState.pixelRatio;var rotation=frameState.viewState.rotation;_ol_render_canvas_.rotateAtOffset(context,-rotation,width/2,height/2);var transform=opt_transform!==undefined?opt_transform:this.getTransform(frameState,0);var render=new _ol_render_canvas_Immediate_(context,frameState.pixelRatio,frameState.extent,transform,frameState.viewState.rotation);var composeEvent=new _ol_render_Event_(type,render,frameState,context,null);layer.dispatchEvent(composeEvent);_ol_render_canvas_.rotateAtOffset(context,rotation,width/2,height/2);}};/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */_ol_renderer_canvas_Layer_.prototype.forEachLayerAtCoordinate=function(coordinate,frameState,callback,thisArg){var hasFeature=this.forEachFeatureAtCoordinate(coordinate,frameState,0,_ol_functions_.TRUE,this);if(hasFeature){return callback.call(thisArg,this.getLayer(),null);}else{return undefined;}};/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */_ol_renderer_canvas_Layer_.prototype.postCompose=function(context,frameState,layerState,opt_transform){this.dispatchComposeEvent_(_ol_render_EventType_.POSTCOMPOSE,context,frameState,opt_transform);};/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */_ol_renderer_canvas_Layer_.prototype.preCompose=function(context,frameState,opt_transform){this.dispatchComposeEvent_(_ol_render_EventType_.PRECOMPOSE,context,frameState,opt_transform);};/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */_ol_renderer_canvas_Layer_.prototype.dispatchRenderEvent=function(context,frameState,opt_transform){this.dispatchComposeEvent_(_ol_render_EventType_.RENDER,context,frameState,opt_transform);};/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} offsetX Offset on the x-axis in view coordinates.
 * @protected
 * @return {!ol.Transform} Transform.
 */_ol_renderer_canvas_Layer_.prototype.getTransform=function(frameState,offsetX){var viewState=frameState.viewState;var pixelRatio=frameState.pixelRatio;var dx1=pixelRatio*frameState.size[0]/2;var dy1=pixelRatio*frameState.size[1]/2;var sx=pixelRatio/viewState.resolution;var sy=-sx;var angle=-viewState.rotation;var dx2=-viewState.center[0]+offsetX;var dy2=-viewState.center[1];return _ol_transform_.compose(this.transform_,dx1,dy1,sx,sy,angle,dx2,dy2);};/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {CanvasRenderingContext2D} context Context.
 */_ol_renderer_canvas_Layer_.prototype.composeFrame=function(frameState,layerState,context){};/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @return {boolean} whether composeFrame should be called.
 */_ol_renderer_canvas_Layer_.prototype.prepareFrame=function(frameState,layerState){};var _ol_renderer_vector_={};/**
 * @param {ol.Feature|ol.render.Feature} feature1 Feature 1.
 * @param {ol.Feature|ol.render.Feature} feature2 Feature 2.
 * @return {number} Order.
 */_ol_renderer_vector_.defaultOrder=function(feature1,feature2){return _ol_.getUid(feature1)-_ol_.getUid(feature2);};/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */_ol_renderer_vector_.getSquaredTolerance=function(resolution,pixelRatio){var tolerance=_ol_renderer_vector_.getTolerance(resolution,pixelRatio);return tolerance*tolerance;};/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */_ol_renderer_vector_.getTolerance=function(resolution,pixelRatio){return _ol_.SIMPLIFY_TOLERANCE*resolution/pixelRatio;};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Circle} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderCircleGeometry_=function(replayGroup,geometry,style,feature){var fillStyle=style.getFill();var strokeStyle=style.getStroke();if(fillStyle||strokeStyle){var circleReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.CIRCLE);circleReplay.setFillStrokeStyle(fillStyle,strokeStyle);circleReplay.drawCircle(geometry,feature);}var textStyle=style.getText();if(textStyle){var textReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.TEXT);textReplay.setTextStyle(textStyle);textReplay.drawText(geometry.getCenter(),0,2,2,geometry,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */_ol_renderer_vector_.renderFeature=function(replayGroup,feature,style,squaredTolerance,listener,thisArg){var loading=false;var imageStyle,imageState;imageStyle=style.getImage();if(imageStyle){imageState=imageStyle.getImageState();if(imageState==_ol_ImageState_.LOADED||imageState==_ol_ImageState_.ERROR){imageStyle.unlistenImageChange(listener,thisArg);}else{if(imageState==_ol_ImageState_.IDLE){imageStyle.load();}imageState=imageStyle.getImageState();imageStyle.listenImageChange(listener,thisArg);loading=true;}}_ol_renderer_vector_.renderFeature_(replayGroup,feature,style,squaredTolerance);return loading;};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @private
 */_ol_renderer_vector_.renderFeature_=function(replayGroup,feature,style,squaredTolerance){var geometry=style.getGeometryFunction()(feature);if(!geometry){return;}var simplifiedGeometry=geometry.getSimplifiedGeometry(squaredTolerance);var renderer=style.getRenderer();if(renderer){_ol_renderer_vector_.renderGeometry_(replayGroup,simplifiedGeometry,style,feature);}else{var geometryRenderer=_ol_renderer_vector_.GEOMETRY_RENDERERS_[simplifiedGeometry.getType()];geometryRenderer(replayGroup,simplifiedGeometry,style,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderGeometry_=function(replayGroup,geometry,style,feature){if(geometry.getType()==_ol_geom_GeometryType_.GEOMETRY_COLLECTION){var geometries=/** @type {ol.geom.GeometryCollection} */geometry.getGeometries();for(var i=0,ii=geometries.length;i<ii;++i){_ol_renderer_vector_.renderGeometry_(replayGroup,geometries[i],style,feature);}return;}var replay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.DEFAULT);replay.drawCustom(/** @type {ol.geom.SimpleGeometry} */geometry,feature,style.getRenderer());};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderGeometryCollectionGeometry_=function(replayGroup,geometry,style,feature){var geometries=geometry.getGeometriesArray();var i,ii;for(i=0,ii=geometries.length;i<ii;++i){var geometryRenderer=_ol_renderer_vector_.GEOMETRY_RENDERERS_[geometries[i].getType()];geometryRenderer(replayGroup,geometries[i],style,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.LineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderLineStringGeometry_=function(replayGroup,geometry,style,feature){var strokeStyle=style.getStroke();if(strokeStyle){var lineStringReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.LINE_STRING);lineStringReplay.setFillStrokeStyle(null,strokeStyle);lineStringReplay.drawLineString(geometry,feature);}var textStyle=style.getText();if(textStyle){var textReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.TEXT);textReplay.setTextStyle(textStyle);textReplay.drawText(geometry.getFlatMidpoint(),0,2,2,geometry,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderMultiLineStringGeometry_=function(replayGroup,geometry,style,feature){var strokeStyle=style.getStroke();if(strokeStyle){var lineStringReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.LINE_STRING);lineStringReplay.setFillStrokeStyle(null,strokeStyle);lineStringReplay.drawMultiLineString(geometry,feature);}var textStyle=style.getText();if(textStyle){var textReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.TEXT);textReplay.setTextStyle(textStyle);var flatMidpointCoordinates=geometry.getFlatMidpoints();textReplay.drawText(flatMidpointCoordinates,0,flatMidpointCoordinates.length,2,geometry,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderMultiPolygonGeometry_=function(replayGroup,geometry,style,feature){var fillStyle=style.getFill();var strokeStyle=style.getStroke();if(strokeStyle||fillStyle){var polygonReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.POLYGON);polygonReplay.setFillStrokeStyle(fillStyle,strokeStyle);polygonReplay.drawMultiPolygon(geometry,feature);}var textStyle=style.getText();if(textStyle){var textReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.TEXT);textReplay.setTextStyle(textStyle);var flatInteriorPointCoordinates=geometry.getFlatInteriorPoints();textReplay.drawText(flatInteriorPointCoordinates,0,flatInteriorPointCoordinates.length,2,geometry,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Point|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderPointGeometry_=function(replayGroup,geometry,style,feature){var imageStyle=style.getImage();if(imageStyle){if(imageStyle.getImageState()!=_ol_ImageState_.LOADED){return;}var imageReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.IMAGE);imageReplay.setImageStyle(imageStyle);imageReplay.drawPoint(geometry,feature);}var textStyle=style.getText();if(textStyle){var textReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.TEXT);textReplay.setTextStyle(textStyle);textReplay.drawText(geometry.getFlatCoordinates(),0,2,2,geometry,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderMultiPointGeometry_=function(replayGroup,geometry,style,feature){var imageStyle=style.getImage();if(imageStyle){if(imageStyle.getImageState()!=_ol_ImageState_.LOADED){return;}var imageReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.IMAGE);imageReplay.setImageStyle(imageStyle);imageReplay.drawMultiPoint(geometry,feature);}var textStyle=style.getText();if(textStyle){var textReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.TEXT);textReplay.setTextStyle(textStyle);var flatCoordinates=geometry.getFlatCoordinates();textReplay.drawText(flatCoordinates,0,flatCoordinates.length,geometry.getStride(),geometry,feature);}};/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */_ol_renderer_vector_.renderPolygonGeometry_=function(replayGroup,geometry,style,feature){var fillStyle=style.getFill();var strokeStyle=style.getStroke();if(fillStyle||strokeStyle){var polygonReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.POLYGON);polygonReplay.setFillStrokeStyle(fillStyle,strokeStyle);polygonReplay.drawPolygon(geometry,feature);}var textStyle=style.getText();if(textStyle){var textReplay=replayGroup.getReplay(style.getZIndex(),_ol_render_ReplayType_.TEXT);textReplay.setTextStyle(textStyle);textReplay.drawText(geometry.getFlatInteriorPoint(),0,2,2,geometry,feature);}};/**
 * @const
 * @private
 * @type {Object.<ol.geom.GeometryType,
 *                function(ol.render.ReplayGroup, ol.geom.Geometry,
 *                         ol.style.Style, Object)>}
 */_ol_renderer_vector_.GEOMETRY_RENDERERS_={'Point':_ol_renderer_vector_.renderPointGeometry_,'LineString':_ol_renderer_vector_.renderLineStringGeometry_,'Polygon':_ol_renderer_vector_.renderPolygonGeometry_,'MultiPoint':_ol_renderer_vector_.renderMultiPointGeometry_,'MultiLineString':_ol_renderer_vector_.renderMultiLineStringGeometry_,'MultiPolygon':_ol_renderer_vector_.renderMultiPolygonGeometry_,'GeometryCollection':_ol_renderer_vector_.renderGeometryCollectionGeometry_,'Circle':_ol_renderer_vector_.renderCircleGeometry_};/**
 * @constructor
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 */var _ol_renderer_canvas_VectorLayer_=function(vectorLayer){_ol_renderer_canvas_Layer_.call(this,vectorLayer);/**
   * @private
   * @type {boolean}
   */this.dirty_=false;/**
   * @private
   * @type {number}
   */this.renderedRevision_=-1;/**
   * @private
   * @type {number}
   */this.renderedResolution_=NaN;/**
   * @private
   * @type {ol.Extent}
   */this.renderedExtent_=_ol_extent_.createEmpty();/**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */this.renderedRenderOrder_=null;/**
   * @private
   * @type {ol.render.canvas.ReplayGroup}
   */this.replayGroup_=null;/**
   * @private
   * @type {CanvasRenderingContext2D}
   */this.context_=_ol_dom_.createCanvasContext2D();};_ol_.inherits(_ol_renderer_canvas_VectorLayer_,_ol_renderer_canvas_Layer_);/**
 * @inheritDoc
 */_ol_renderer_canvas_VectorLayer_.prototype.composeFrame=function(frameState,layerState,context){var extent=frameState.extent;var pixelRatio=frameState.pixelRatio;var skippedFeatureUids=layerState.managed?frameState.skippedFeatureUids:{};var viewState=frameState.viewState;var projection=viewState.projection;var rotation=viewState.rotation;var projectionExtent=projection.getExtent();var vectorSource=/** @type {ol.source.Vector} */this.getLayer().getSource();var transform=this.getTransform(frameState,0);this.preCompose(context,frameState,transform);// clipped rendering if layer extent is set
var clipExtent=layerState.extent;var clipped=clipExtent!==undefined;if(clipped){this.clip(context,frameState,/** @type {ol.Extent} */clipExtent);}var replayGroup=this.replayGroup_;if(replayGroup&&!replayGroup.isEmpty()){var layer=this.getLayer();var drawOffsetX=0;var drawOffsetY=0;var replayContext;var transparentLayer=layerState.opacity!==1;var hasRenderListeners=layer.hasListener(_ol_render_EventType_.RENDER);if(transparentLayer||hasRenderListeners){var drawWidth=context.canvas.width;var drawHeight=context.canvas.height;if(rotation){var drawSize=Math.round(Math.sqrt(drawWidth*drawWidth+drawHeight*drawHeight));drawOffsetX=(drawSize-drawWidth)/2;drawOffsetY=(drawSize-drawHeight)/2;drawWidth=drawHeight=drawSize;}// resize and clear
this.context_.canvas.width=drawWidth;this.context_.canvas.height=drawHeight;replayContext=this.context_;}else{replayContext=context;}var alpha=replayContext.globalAlpha;if(!transparentLayer){// for performance reasons, context.save / context.restore is not used
// to save and restore the transformation matrix and the opacity.
// see http://jsperf.com/context-save-restore-versus-variable
replayContext.globalAlpha=layerState.opacity;}if(replayContext!=context){replayContext.translate(drawOffsetX,drawOffsetY);}var width=frameState.size[0]*pixelRatio;var height=frameState.size[1]*pixelRatio;_ol_render_canvas_.rotateAtOffset(replayContext,-rotation,width/2,height/2);replayGroup.replay(replayContext,pixelRatio,transform,rotation,skippedFeatureUids);if(vectorSource.getWrapX()&&projection.canWrapX()&&!_ol_extent_.containsExtent(projectionExtent,extent)){var startX=extent[0];var worldWidth=_ol_extent_.getWidth(projectionExtent);var world=0;var offsetX;while(startX<projectionExtent[0]){--world;offsetX=worldWidth*world;transform=this.getTransform(frameState,offsetX);replayGroup.replay(replayContext,pixelRatio,transform,rotation,skippedFeatureUids);startX+=worldWidth;}world=0;startX=extent[2];while(startX>projectionExtent[2]){++world;offsetX=worldWidth*world;transform=this.getTransform(frameState,offsetX);replayGroup.replay(replayContext,pixelRatio,transform,rotation,skippedFeatureUids);startX-=worldWidth;}// restore original transform for render and compose events
transform=this.getTransform(frameState,0);}_ol_render_canvas_.rotateAtOffset(replayContext,rotation,width/2,height/2);if(replayContext!=context){if(hasRenderListeners){this.dispatchRenderEvent(replayContext,frameState,transform);}if(transparentLayer){var mainContextAlpha=context.globalAlpha;context.globalAlpha=layerState.opacity;context.drawImage(replayContext.canvas,-drawOffsetX,-drawOffsetY);context.globalAlpha=mainContextAlpha;}else{context.drawImage(replayContext.canvas,-drawOffsetX,-drawOffsetY);}replayContext.translate(-drawOffsetX,-drawOffsetY);}if(!transparentLayer){replayContext.globalAlpha=alpha;}}if(clipped){context.restore();}this.postCompose(context,frameState,layerState,transform);};/**
 * @inheritDoc
 */_ol_renderer_canvas_VectorLayer_.prototype.forEachFeatureAtCoordinate=function(coordinate,frameState,hitTolerance,callback,thisArg){if(!this.replayGroup_){return undefined;}else{var resolution=frameState.viewState.resolution;var rotation=frameState.viewState.rotation;var layer=this.getLayer();/** @type {Object.<string, boolean>} */var features={};return this.replayGroup_.forEachFeatureAtCoordinate(coordinate,resolution,rotation,hitTolerance,{},/**
         * @param {ol.Feature|ol.render.Feature} feature Feature.
         * @return {?} Callback result.
         */function(feature){var key=_ol_.getUid(feature).toString();if(!(key in features)){features[key]=true;return callback.call(thisArg,feature,layer);}});}};/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */_ol_renderer_canvas_VectorLayer_.prototype.handleStyleImageChange_=function(event){this.renderIfReadyAndVisible();};/**
 * @inheritDoc
 */_ol_renderer_canvas_VectorLayer_.prototype.prepareFrame=function(frameState,layerState){var vectorLayer=/** @type {ol.layer.Vector} */this.getLayer();var vectorSource=vectorLayer.getSource();this.updateAttributions(frameState.attributions,vectorSource.getAttributions());this.updateLogos(frameState,vectorSource);var animating=frameState.viewHints[_ol_ViewHint_.ANIMATING];var interacting=frameState.viewHints[_ol_ViewHint_.INTERACTING];var updateWhileAnimating=vectorLayer.getUpdateWhileAnimating();var updateWhileInteracting=vectorLayer.getUpdateWhileInteracting();if(!this.dirty_&&!updateWhileAnimating&&animating||!updateWhileInteracting&&interacting){return true;}var frameStateExtent=frameState.extent;var viewState=frameState.viewState;var projection=viewState.projection;var resolution=viewState.resolution;var pixelRatio=frameState.pixelRatio;var vectorLayerRevision=vectorLayer.getRevision();var vectorLayerRenderBuffer=vectorLayer.getRenderBuffer();var vectorLayerRenderOrder=vectorLayer.getRenderOrder();if(vectorLayerRenderOrder===undefined){vectorLayerRenderOrder=_ol_renderer_vector_.defaultOrder;}var extent=_ol_extent_.buffer(frameStateExtent,vectorLayerRenderBuffer*resolution);var projectionExtent=viewState.projection.getExtent();if(vectorSource.getWrapX()&&viewState.projection.canWrapX()&&!_ol_extent_.containsExtent(projectionExtent,frameState.extent)){// For the replay group, we need an extent that intersects the real world
// (-180 to +180). To support geometries in a coordinate range from -540
// to +540, we add at least 1 world width on each side of the projection
// extent. If the viewport is wider than the world, we need to add half of
// the viewport width to make sure we cover the whole viewport.
var worldWidth=_ol_extent_.getWidth(projectionExtent);var buffer=Math.max(_ol_extent_.getWidth(extent)/2,worldWidth);extent[0]=projectionExtent[0]-buffer;extent[2]=projectionExtent[2]+buffer;}if(!this.dirty_&&this.renderedResolution_==resolution&&this.renderedRevision_==vectorLayerRevision&&this.renderedRenderOrder_==vectorLayerRenderOrder&&_ol_extent_.containsExtent(this.renderedExtent_,extent)){return true;}this.replayGroup_=null;this.dirty_=false;var replayGroup=new _ol_render_canvas_ReplayGroup_(_ol_renderer_vector_.getTolerance(resolution,pixelRatio),extent,resolution,vectorSource.getOverlaps(),vectorLayer.getRenderBuffer());vectorSource.loadFeatures(extent,resolution,projection);/**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.canvas.VectorLayer}
   */var renderFeature=function(feature){var styles;var styleFunction=feature.getStyleFunction();if(styleFunction){styles=styleFunction.call(feature,resolution);}else{styleFunction=vectorLayer.getStyleFunction();if(styleFunction){styles=styleFunction(feature,resolution);}}if(styles){var dirty=this.renderFeature(feature,resolution,pixelRatio,styles,replayGroup);this.dirty_=this.dirty_||dirty;}}.bind(this);if(vectorLayerRenderOrder){/** @type {Array.<ol.Feature>} */var features=[];vectorSource.forEachFeatureInExtent(extent,/**
         * @param {ol.Feature} feature Feature.
         */function(feature){features.push(feature);},this);features.sort(vectorLayerRenderOrder);for(var i=0,ii=features.length;i<ii;++i){renderFeature(features[i]);}}else{vectorSource.forEachFeatureInExtent(extent,renderFeature,this);}replayGroup.finish();this.renderedResolution_=resolution;this.renderedRevision_=vectorLayerRevision;this.renderedRenderOrder_=vectorLayerRenderOrder;this.renderedExtent_=extent;this.replayGroup_=replayGroup;return true;};/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */_ol_renderer_canvas_VectorLayer_.prototype.renderFeature=function(feature,resolution,pixelRatio,styles,replayGroup){if(!styles){return false;}var loading=false;if(Array.isArray(styles)){for(var i=0,ii=styles.length;i<ii;++i){loading=_ol_renderer_vector_.renderFeature(replayGroup,feature,styles[i],_ol_renderer_vector_.getSquaredTolerance(resolution,pixelRatio),this.handleStyleImageChange_,this)||loading;}}else{loading=_ol_renderer_vector_.renderFeature(replayGroup,feature,styles,_ol_renderer_vector_.getSquaredTolerance(resolution,pixelRatio),this.handleStyleImageChange_,this)||loading;}return loading;};// This file is automatically generated, do not edit
/* eslint openlayers-internal/no-missing-requires: 0 */// This file is automatically generated, do not edit
/* eslint openlayers-internal/no-missing-requires: 0 *//**
 * @enum {string}
 */// This file is automatically generated, do not edit
/* eslint openlayers-internal/no-missing-requires: 0 */// This file is automatically generated, do not edit
/* eslint openlayers-internal/no-missing-requires: 0 *//**
 * Creates an empty linked list structure.
 *
 * @constructor
 * @struct
 * @param {boolean=} opt_circular The last item is connected to the first one,
 * and the first item to the last one. Default is true.
 */var _ol_structs_LinkedList_=function(opt_circular){/**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */this.first_=undefined;/**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */this.last_=undefined;/**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */this.head_=undefined;/**
   * @private
   * @type {boolean}
   */this.circular_=opt_circular===undefined?true:opt_circular;/**
   * @private
   * @type {number}
   */this.length_=0;};/**
 * Inserts an item into the linked list right after the current one.
 *
 * @param {?} data Item data.
 */_ol_structs_LinkedList_.prototype.insertItem=function(data){/** @type {ol.LinkedListItem} */var item={prev:undefined,next:undefined,data:data};var head=this.head_;//Initialize the list.
if(!head){this.first_=item;this.last_=item;if(this.circular_){item.next=item;item.prev=item;}}else{//Link the new item to the adjacent ones.
var next=head.next;item.prev=head;item.next=next;head.next=item;if(next){next.prev=item;}if(head===this.last_){this.last_=item;}}this.head_=item;this.length_++;};/**
 * Removes the current item from the list. Sets the cursor to the next item,
 * if possible.
 */_ol_structs_LinkedList_.prototype.removeItem=function(){var head=this.head_;if(head){var next=head.next;var prev=head.prev;if(next){next.prev=prev;}if(prev){prev.next=next;}this.head_=next||prev;if(this.first_===this.last_){this.head_=undefined;this.first_=undefined;this.last_=undefined;}else if(this.first_===head){this.first_=this.head_;}else if(this.last_===head){this.last_=prev?this.head_.prev:this.head_;}this.length_--;}};/**
 * Sets the cursor to the first item, and returns the associated data.
 *
 * @return {?} Item data.
 */_ol_structs_LinkedList_.prototype.firstItem=function(){this.head_=this.first_;if(this.head_){return this.head_.data;}return undefined;};/**
* Sets the cursor to the last item, and returns the associated data.
*
* @return {?} Item data.
*/_ol_structs_LinkedList_.prototype.lastItem=function(){this.head_=this.last_;if(this.head_){return this.head_.data;}return undefined;};/**
 * Sets the cursor to the next item, and returns the associated data.
 *
 * @return {?} Item data.
 */_ol_structs_LinkedList_.prototype.nextItem=function(){if(this.head_&&this.head_.next){this.head_=this.head_.next;return this.head_.data;}return undefined;};/**
 * Returns the next item's data without moving the cursor.
 *
 * @return {?} Item data.
 */_ol_structs_LinkedList_.prototype.getNextItem=function(){if(this.head_&&this.head_.next){return this.head_.next.data;}return undefined;};/**
 * Sets the cursor to the previous item, and returns the associated data.
 *
 * @return {?} Item data.
 */_ol_structs_LinkedList_.prototype.prevItem=function(){if(this.head_&&this.head_.prev){this.head_=this.head_.prev;return this.head_.data;}return undefined;};/**
 * Returns the previous item's data without moving the cursor.
 *
 * @return {?} Item data.
 */_ol_structs_LinkedList_.prototype.getPrevItem=function(){if(this.head_&&this.head_.prev){return this.head_.prev.data;}return undefined;};/**
 * Returns the current item's data.
 *
 * @return {?} Item data.
 */_ol_structs_LinkedList_.prototype.getCurrItem=function(){if(this.head_){return this.head_.data;}return undefined;};/**
 * Sets the first item of the list. This only works for circular lists, and sets
 * the last item accordingly.
 */_ol_structs_LinkedList_.prototype.setFirstItem=function(){if(this.circular_&&this.head_){this.first_=this.head_;this.last_=this.head_.prev;}};/**
 * Concatenates two lists.
 * @param {ol.structs.LinkedList} list List to merge into the current list.
 */_ol_structs_LinkedList_.prototype.concat=function(list){if(list.head_){if(this.head_){var end=this.head_.next;this.head_.next=list.first_;list.first_.prev=this.head_;end.prev=list.last_;list.last_.next=end;this.length_+=list.length_;}else{this.head_=list.head_;this.first_=list.first_;this.last_=list.last_;this.length_=list.length_;}list.head_=undefined;list.first_=undefined;list.last_=undefined;list.length_=0;}};/**
 * Returns the current length of the list.
 *
 * @return {number} Length.
 */_ol_structs_LinkedList_.prototype.getLength=function(){return this.length_;};/**
 * This class facilitates the creation of image atlases.
 *
 * Images added to an atlas will be rendered onto a single
 * atlas canvas. The distribution of images on the canvas is
 * managed with the bin packing algorithm described in:
 * http://www.blackpawn.com/texts/lightmaps/
 *
 * @constructor
 * @struct
 * @param {number} size The size in pixels of the sprite image.
 * @param {number} space The space in pixels between images.
 *    Because texture coordinates are float values, the edges of
 *    images might not be completely correct (in a way that the
 *    edges overlap when being rendered). To avoid this we add a
 *    padding around each image.
 */var _ol_style_Atlas_=function(size,space){/**
   * @private
   * @type {number}
   */this.space_=space;/**
   * @private
   * @type {Array.<ol.AtlasBlock>}
   */this.emptyBlocks_=[{x:0,y:0,width:size,height:size}];/**
   * @private
   * @type {Object.<string, ol.AtlasInfo>}
   */this.entries_={};/**
   * @private
   * @type {CanvasRenderingContext2D}
   */this.context_=_ol_dom_.createCanvasContext2D(size,size);/**
   * @private
   * @type {HTMLCanvasElement}
   */this.canvas_=this.context_.canvas;};/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The atlas info.
 */_ol_style_Atlas_.prototype.get=function(id){return this.entries_[id]||null;};/**
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback`.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry.
 */_ol_style_Atlas_.prototype.add=function(id,width,height,renderCallback,opt_this){var block,i,ii;for(i=0,ii=this.emptyBlocks_.length;i<ii;++i){block=this.emptyBlocks_[i];if(block.width>=width+this.space_&&block.height>=height+this.space_){// we found a block that is big enough for our entry
var entry={offsetX:block.x+this.space_,offsetY:block.y+this.space_,image:this.canvas_};this.entries_[id]=entry;// render the image on the atlas image
renderCallback.call(opt_this,this.context_,block.x+this.space_,block.y+this.space_);// split the block after the insertion, either horizontally or vertically
this.split_(i,block,width+this.space_,height+this.space_);return entry;}}// there is no space for the new entry in this atlas
return null;};/**
 * @private
 * @param {number} index The index of the block.
 * @param {ol.AtlasBlock} block The block to split.
 * @param {number} width The width of the entry to insert.
 * @param {number} height The height of the entry to insert.
 */_ol_style_Atlas_.prototype.split_=function(index,block,width,height){var deltaWidth=block.width-width;var deltaHeight=block.height-height;/** @type {ol.AtlasBlock} */var newBlock1;/** @type {ol.AtlasBlock} */var newBlock2;if(deltaWidth>deltaHeight){// split vertically
// block right of the inserted entry
newBlock1={x:block.x+width,y:block.y,width:block.width-width,height:block.height};// block below the inserted entry
newBlock2={x:block.x,y:block.y+height,width:width,height:block.height-height};this.updateBlocks_(index,newBlock1,newBlock2);}else{// split horizontally
// block right of the inserted entry
newBlock1={x:block.x+width,y:block.y,width:block.width-width,height:height};// block below the inserted entry
newBlock2={x:block.x,y:block.y+height,width:block.width,height:block.height-height};this.updateBlocks_(index,newBlock1,newBlock2);}};/**
 * Remove the old block and insert new blocks at the same array position.
 * The new blocks are inserted at the same position, so that splitted
 * blocks (that are potentially smaller) are filled first.
 * @private
 * @param {number} index The index of the block to remove.
 * @param {ol.AtlasBlock} newBlock1 The 1st block to add.
 * @param {ol.AtlasBlock} newBlock2 The 2nd block to add.
 */_ol_style_Atlas_.prototype.updateBlocks_=function(index,newBlock1,newBlock2){var args=[index,1];if(newBlock1.width>0&&newBlock1.height>0){args.push(newBlock1);}if(newBlock2.width>0&&newBlock2.height>0){args.push(newBlock2);}this.emptyBlocks_.splice.apply(this.emptyBlocks_,args);};/**
 * Manages the creation of image atlases.
 *
 * Images added to this manager will be inserted into an atlas, which
 * will be used for rendering.
 * The `size` given in the constructor is the size for the first
 * atlas. After that, when new atlases are created, they will have
 * twice the size as the latest atlas (until `maxSize` is reached).
 *
 * If an application uses many images or very large images, it is recommended
 * to set a higher `size` value to avoid the creation of too many atlases.
 *
 * @constructor
 * @struct
 * @api
 * @param {olx.style.AtlasManagerOptions=} opt_options Options.
 */var _ol_style_AtlasManager_=function(opt_options){var options=opt_options||{};/**
   * The size in pixels of the latest atlas image.
   * @private
   * @type {number}
   */this.currentSize_=options.initialSize!==undefined?options.initialSize:_ol_.INITIAL_ATLAS_SIZE;/**
   * The maximum size in pixels of atlas images.
   * @private
   * @type {number}
   */this.maxSize_=options.maxSize!==undefined?options.maxSize:_ol_.MAX_ATLAS_SIZE!=-1?_ol_.MAX_ATLAS_SIZE:_ol_.WEBGL_MAX_TEXTURE_SIZE!==undefined?_ol_.WEBGL_MAX_TEXTURE_SIZE:2048;/**
   * The size in pixels between images.
   * @private
   * @type {number}
   */this.space_=options.space!==undefined?options.space:1;/**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */this.atlases_=[new _ol_style_Atlas_(this.currentSize_,this.space_)];/**
   * The size in pixels of the latest atlas image for hit-detection images.
   * @private
   * @type {number}
   */this.currentHitSize_=this.currentSize_;/**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */this.hitAtlases_=[new _ol_style_Atlas_(this.currentHitSize_,this.space_)];};/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlas manager.
 */_ol_style_AtlasManager_.prototype.getInfo=function(id){/** @type {?ol.AtlasInfo} */var info=this.getInfo_(this.atlases_,id);if(!info){return null;}var hitInfo=/** @type {ol.AtlasInfo} */this.getInfo_(this.hitAtlases_,id);return this.mergeInfos_(info,hitInfo);};/**
 * @private
 * @param {Array.<ol.style.Atlas>} atlases The atlases to search.
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry,
 *    or `null` if the entry is not part of the atlases.
 */_ol_style_AtlasManager_.prototype.getInfo_=function(atlases,id){var atlas,info,i,ii;for(i=0,ii=atlases.length;i<ii;++i){atlas=atlases[i];info=atlas.get(id);if(info){return info;}}return null;};/**
 * @private
 * @param {ol.AtlasInfo} info The info for the real image.
 * @param {ol.AtlasInfo} hitInfo The info for the hit-detection
 *    image.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlases.
 */_ol_style_AtlasManager_.prototype.mergeInfos_=function(info,hitInfo){return(/** @type {ol.AtlasManagerInfo} */{offsetX:info.offsetX,offsetY:info.offsetY,image:info.image,hitImage:hitInfo.image});};/**
 * Add an image to the atlas manager.
 *
 * If an entry for the given id already exists, the entry will
 * be overridden (but the space on the atlas graphic will not be freed).
 *
 * If `renderHitCallback` is provided, the image (or the hit-detection version
 * of the image) will be rendered into a separate hit-detection atlas image.
 *
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {function(CanvasRenderingContext2D, number, number)=}
 *    opt_renderHitCallback Called to render a hit-detection image onto a hit
 *    detection atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasManagerInfo}  The position and atlas image for the
 *    entry, or `null` if the image is too big.
 */_ol_style_AtlasManager_.prototype.add=function(id,width,height,renderCallback,opt_renderHitCallback,opt_this){if(width+this.space_>this.maxSize_||height+this.space_>this.maxSize_){return null;}/** @type {?ol.AtlasInfo} */var info=this.add_(false,id,width,height,renderCallback,opt_this);if(!info){return null;}// even if no hit-detection entry is requested, we insert a fake entry into
// the hit-detection atlas, to make sure that the offset is the same for
// the original image and the hit-detection image.
var renderHitCallback=opt_renderHitCallback!==undefined?opt_renderHitCallback:_ol_.nullFunction;var hitInfo=/** @type {ol.AtlasInfo} */this.add_(true,id,width,height,renderHitCallback,opt_this);return this.mergeInfos_(info,hitInfo);};/**
 * @private
 * @param {boolean} isHitAtlas If the hit-detection atlases are used.
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasInfo}  The position and atlas image for the entry,
 *    or `null` if the image is too big.
 */_ol_style_AtlasManager_.prototype.add_=function(isHitAtlas,id,width,height,renderCallback,opt_this){var atlases=isHitAtlas?this.hitAtlases_:this.atlases_;var atlas,info,i,ii;for(i=0,ii=atlases.length;i<ii;++i){atlas=atlases[i];info=atlas.add(id,width,height,renderCallback,opt_this);if(info){return info;}else if(!info&&i===ii-1){// the entry could not be added to one of the existing atlases,
// create a new atlas that is twice as big and try to add to this one.
var size;if(isHitAtlas){size=Math.min(this.currentHitSize_*2,this.maxSize_);this.currentHitSize_=size;}else{size=Math.min(this.currentSize_*2,this.maxSize_);this.currentSize_=size;}atlas=new _ol_style_Atlas_(size,this.space_);atlases.push(atlas);// run the loop another time
++ii;}}return null;};// This file is automatically generated, do not edit
/* eslint openlayers-internal/no-missing-requires: 0 */var _ol_renderer_webgl_VectorLayer_;/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.VectorOptions=} opt_options Options.
 * @api
 */var _ol_layer_Vector_=function(opt_options){var options=opt_options?opt_options:/** @type {olx.layer.VectorOptions} */{};var baseOptions=_ol_obj_.assign({},options);delete baseOptions.style;delete baseOptions.renderBuffer;delete baseOptions.updateWhileAnimating;delete baseOptions.updateWhileInteracting;_ol_layer_Layer_.call(this,/** @type {olx.layer.LayerOptions} */baseOptions);/**
   * @type {number}
   * @private
   */this.renderBuffer_=options.renderBuffer!==undefined?options.renderBuffer:100;/**
   * User provided style.
   * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
   * @private
   */this.style_=null;/**
   * Style function for use within the library.
   * @type {ol.StyleFunction|undefined}
   * @private
   */this.styleFunction_=undefined;this.setStyle(options.style);/**
   * @type {boolean}
   * @private
   */this.updateWhileAnimating_=options.updateWhileAnimating!==undefined?options.updateWhileAnimating:false;/**
   * @type {boolean}
   * @private
   */this.updateWhileInteracting_=options.updateWhileInteracting!==undefined?options.updateWhileInteracting:false;};_ol_.inherits(_ol_layer_Vector_,_ol_layer_Layer_);/**
 * @inheritDoc
 */_ol_layer_Vector_.prototype.createRenderer=function(mapRenderer){var renderer=null;var type=mapRenderer.getType();if(_ol_.ENABLE_CANVAS&&type===_ol_renderer_Type_.CANVAS){renderer=new _ol_renderer_canvas_VectorLayer_(this);}else if(false&&type===_ol_renderer_Type_.WEBGL){renderer=new _ol_renderer_webgl_VectorLayer_(mapRenderer,this);}return renderer;};/**
 * @return {number|undefined} Render buffer.
 */_ol_layer_Vector_.prototype.getRenderBuffer=function(){return this.renderBuffer_;};/**
 * @return {function(ol.Feature, ol.Feature): number|null|undefined} Render
 *     order.
 */_ol_layer_Vector_.prototype.getRenderOrder=function(){return(/** @type {ol.RenderOrderFunction|null|undefined} */this.get(_ol_layer_Vector_.Property_.RENDER_ORDER));};/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 *     Layer style.
 * @api
 */_ol_layer_Vector_.prototype.getStyle=function(){return this.style_;};/**
 * Get the style function.
 * @return {ol.StyleFunction|undefined} Layer style function.
 * @api
 */_ol_layer_Vector_.prototype.getStyleFunction=function(){return this.styleFunction_;};/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     animating.
 */_ol_layer_Vector_.prototype.getUpdateWhileAnimating=function(){return this.updateWhileAnimating_;};/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     interacting.
 */_ol_layer_Vector_.prototype.getUpdateWhileInteracting=function(){return this.updateWhileInteracting_;};/**
 * @param {ol.RenderOrderFunction|null|undefined} renderOrder
 *     Render order.
 */_ol_layer_Vector_.prototype.setRenderOrder=function(renderOrder){this.set(_ol_layer_Vector_.Property_.RENDER_ORDER,renderOrder);};/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {@link ol.style} for information on the default style.
 * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|null|undefined}
 *     style Layer style.
 * @api
 */_ol_layer_Vector_.prototype.setStyle=function(style){this.style_=style!==undefined?style:_ol_style_Style_$1.defaultFunction;this.styleFunction_=style===null?undefined:_ol_style_Style_$1.createFunction(this.style_);this.changed();};/**
 * @enum {string}
 * @private
 */_ol_layer_Vector_.Property_={RENDER_ORDER:'renderOrder'};var _ol_geom_flat_interpolate_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination.
 */_ol_geom_flat_interpolate_.lineString=function(flatCoordinates,offset,end,stride,fraction,opt_dest){var pointX=NaN;var pointY=NaN;var n=(end-offset)/stride;if(n===1){pointX=flatCoordinates[offset];pointY=flatCoordinates[offset+1];}else if(n==2){pointX=(1-fraction)*flatCoordinates[offset]+fraction*flatCoordinates[offset+stride];pointY=(1-fraction)*flatCoordinates[offset+1]+fraction*flatCoordinates[offset+stride+1];}else if(n!==0){var x1=flatCoordinates[offset];var y1=flatCoordinates[offset+1];var length=0;var cumulativeLengths=[0];var i;for(i=offset+stride;i<end;i+=stride){var x2=flatCoordinates[i];var y2=flatCoordinates[i+1];length+=Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));cumulativeLengths.push(length);x1=x2;y1=y2;}var target=fraction*length;var index=_ol_array_.binarySearch(cumulativeLengths,target);if(index<0){var t=(target-cumulativeLengths[-index-2])/(cumulativeLengths[-index-1]-cumulativeLengths[-index-2]);var o=offset+(-index-2)*stride;pointX=_ol_math_.lerp(flatCoordinates[o],flatCoordinates[o+stride],t);pointY=_ol_math_.lerp(flatCoordinates[o+1],flatCoordinates[o+stride+1],t);}else{pointX=flatCoordinates[offset+index*stride];pointY=flatCoordinates[offset+index*stride+1];}}if(opt_dest){opt_dest[0]=pointX;opt_dest[1]=pointY;return opt_dest;}else{return[pointX,pointY];}};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {ol.Coordinate} Coordinate.
 */_ol_geom_flat_interpolate_.lineStringCoordinateAtM=function(flatCoordinates,offset,end,stride,m,extrapolate){if(end==offset){return null;}var coordinate;if(m<flatCoordinates[offset+stride-1]){if(extrapolate){coordinate=flatCoordinates.slice(offset,offset+stride);coordinate[stride-1]=m;return coordinate;}else{return null;}}else if(flatCoordinates[end-1]<m){if(extrapolate){coordinate=flatCoordinates.slice(end-stride,end);coordinate[stride-1]=m;return coordinate;}else{return null;}}// FIXME use O(1) search
if(m==flatCoordinates[offset+stride-1]){return flatCoordinates.slice(offset,offset+stride);}var lo=offset/stride;var hi=end/stride;while(lo<hi){var mid=lo+hi>>1;if(m<flatCoordinates[(mid+1)*stride-1]){hi=mid;}else{lo=mid+1;}}var m0=flatCoordinates[lo*stride-1];if(m==m0){return flatCoordinates.slice((lo-1)*stride,(lo-1)*stride+stride);}var m1=flatCoordinates[(lo+1)*stride-1];var t=(m-m0)/(m1-m0);coordinate=[];var i;for(i=0;i<stride-1;++i){coordinate.push(_ol_math_.lerp(flatCoordinates[(lo-1)*stride+i],flatCoordinates[lo*stride+i],t));}coordinate.push(m);return coordinate;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {ol.Coordinate} Coordinate.
 */_ol_geom_flat_interpolate_.lineStringsCoordinateAtM=function(flatCoordinates,offset,ends,stride,m,extrapolate,interpolate){if(interpolate){return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates,offset,ends[ends.length-1],stride,m,extrapolate);}var coordinate;if(m<flatCoordinates[stride-1]){if(extrapolate){coordinate=flatCoordinates.slice(0,stride);coordinate[stride-1]=m;return coordinate;}else{return null;}}if(flatCoordinates[flatCoordinates.length-1]<m){if(extrapolate){coordinate=flatCoordinates.slice(flatCoordinates.length-stride);coordinate[stride-1]=m;return coordinate;}else{return null;}}var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];if(offset==end){continue;}if(m<flatCoordinates[offset+stride-1]){return null;}else if(m<=flatCoordinates[end-1]){return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates,offset,end,stride,m,false);}offset=end;}return null;};var _ol_geom_flat_length_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */_ol_geom_flat_length_.lineString=function(flatCoordinates,offset,end,stride){var x1=flatCoordinates[offset];var y1=flatCoordinates[offset+1];var length=0;var i;for(i=offset+stride;i<end;i+=stride){var x2=flatCoordinates[i];var y2=flatCoordinates[i+1];length+=Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));x1=x2;y1=y2;}return length;};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */_ol_geom_flat_length_.linearRing=function(flatCoordinates,offset,end,stride){var perimeter=_ol_geom_flat_length_.lineString(flatCoordinates,offset,end,stride);var dx=flatCoordinates[end-stride]-flatCoordinates[offset];var dy=flatCoordinates[end-stride+1]-flatCoordinates[offset+1];perimeter+=Math.sqrt(dx*dx+dy*dy);return perimeter;};/**
 * @classdesc
 * Linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_LineString_=function(coordinates,opt_layout){_ol_geom_SimpleGeometry_.call(this);/**
   * @private
   * @type {ol.Coordinate}
   */this.flatMidpoint_=null;/**
   * @private
   * @type {number}
   */this.flatMidpointRevision_=-1;/**
   * @private
   * @type {number}
   */this.maxDelta_=-1;/**
   * @private
   * @type {number}
   */this.maxDeltaRevision_=-1;this.setCoordinates(coordinates,opt_layout);};_ol_.inherits(_ol_geom_LineString_,_ol_geom_SimpleGeometry_);/**
 * Append the passed coordinate to the coordinates of the linestring.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @api
 */_ol_geom_LineString_.prototype.appendCoordinate=function(coordinate){if(!this.flatCoordinates){this.flatCoordinates=coordinate.slice();}else{_ol_array_.extend(this.flatCoordinates,coordinate);}this.changed();};/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LineString} Clone.
 * @override
 * @api
 */_ol_geom_LineString_.prototype.clone=function(){var lineString=new _ol_geom_LineString_(null);lineString.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return lineString;};/**
 * @inheritDoc
 */_ol_geom_LineString_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){if(minSquaredDistance<_ol_extent_.closestSquaredDistanceXY(this.getExtent(),x,y)){return minSquaredDistance;}if(this.maxDeltaRevision_!=this.getRevision()){this.maxDelta_=Math.sqrt(_ol_geom_flat_closest_.getMaxSquaredDelta(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0));this.maxDeltaRevision_=this.getRevision();}return _ol_geom_flat_closest_.getClosestPoint(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,false,x,y,closestPoint,minSquaredDistance);};/**
 * Iterate over each segment, calling the provided callback.
 * If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 *
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 * @api
 */_ol_geom_LineString_.prototype.forEachSegment=function(callback,opt_this){return _ol_geom_flat_segments_.forEach(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,callback,opt_this);};/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */_ol_geom_LineString_.prototype.getCoordinateAtM=function(m,opt_extrapolate){if(this.layout!=_ol_geom_GeometryLayout_.XYM&&this.layout!=_ol_geom_GeometryLayout_.XYZM){return null;}var extrapolate=opt_extrapolate!==undefined?opt_extrapolate:false;return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,m,extrapolate);};/**
 * Return the coordinates of the linestring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */_ol_geom_LineString_.prototype.getCoordinates=function(){return _ol_geom_flat_inflate_.coordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride);};/**
 * Return the coordinate at the provided fraction along the linestring.
 * The `fraction` is a number between 0 and 1, where 0 is the start of the
 * linestring and 1 is the end.
 * @param {number} fraction Fraction.
 * @param {ol.Coordinate=} opt_dest Optional coordinate whose values will
 *     be modified. If not provided, a new coordinate will be returned.
 * @return {ol.Coordinate} Coordinate of the interpolated point.
 * @api
 */_ol_geom_LineString_.prototype.getCoordinateAt=function(fraction,opt_dest){return _ol_geom_flat_interpolate_.lineString(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,fraction,opt_dest);};/**
 * Return the length of the linestring on projected plane.
 * @return {number} Length (on projected plane).
 * @api
 */_ol_geom_LineString_.prototype.getLength=function(){return _ol_geom_flat_length_.lineString(this.flatCoordinates,0,this.flatCoordinates.length,this.stride);};/**
 * @return {Array.<number>} Flat midpoint.
 */_ol_geom_LineString_.prototype.getFlatMidpoint=function(){if(this.flatMidpointRevision_!=this.getRevision()){this.flatMidpoint_=this.getCoordinateAt(0.5,this.flatMidpoint_);this.flatMidpointRevision_=this.getRevision();}return this.flatMidpoint_;};/**
 * @inheritDoc
 */_ol_geom_LineString_.prototype.getSimplifiedGeometryInternal=function(squaredTolerance){var simplifiedFlatCoordinates=[];simplifiedFlatCoordinates.length=_ol_geom_flat_simplify_.douglasPeucker(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,squaredTolerance,simplifiedFlatCoordinates,0);var simplifiedLineString=new _ol_geom_LineString_(null);simplifiedLineString.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,simplifiedFlatCoordinates);return simplifiedLineString;};/**
 * @inheritDoc
 * @api
 */_ol_geom_LineString_.prototype.getType=function(){return _ol_geom_GeometryType_.LINE_STRING;};/**
 * @inheritDoc
 * @api
 */_ol_geom_LineString_.prototype.intersectsExtent=function(extent){return _ol_geom_flat_intersectsextent_.lineString(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,extent);};/**
 * Set the coordinates of the linestring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */_ol_geom_LineString_.prototype.setCoordinates=function(coordinates,opt_layout){if(!coordinates){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null);}else{this.setLayout(opt_layout,coordinates,1);if(!this.flatCoordinates){this.flatCoordinates=[];}this.flatCoordinates.length=_ol_geom_flat_deflate_.coordinates(this.flatCoordinates,0,coordinates,this.stride);this.changed();}};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */_ol_geom_LineString_.prototype.setFlatCoordinates=function(layout,flatCoordinates){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.changed();};/**
 * @classdesc
 * Circle geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {ol.Coordinate} center Center.
 * @param {number=} opt_radius Radius.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_Circle_=function(center,opt_radius,opt_layout){_ol_geom_SimpleGeometry_.call(this);var radius=opt_radius?opt_radius:0;this.setCenterAndRadius(center,radius,opt_layout);};_ol_.inherits(_ol_geom_Circle_,_ol_geom_SimpleGeometry_);/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Circle} Clone.
 * @override
 * @api
 */_ol_geom_Circle_.prototype.clone=function(){var circle=new _ol_geom_Circle_(null);circle.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return circle;};/**
 * @inheritDoc
 */_ol_geom_Circle_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){var flatCoordinates=this.flatCoordinates;var dx=x-flatCoordinates[0];var dy=y-flatCoordinates[1];var squaredDistance=dx*dx+dy*dy;if(squaredDistance<minSquaredDistance){var i;if(squaredDistance===0){for(i=0;i<this.stride;++i){closestPoint[i]=flatCoordinates[i];}}else{var delta=this.getRadius()/Math.sqrt(squaredDistance);closestPoint[0]=flatCoordinates[0]+delta*dx;closestPoint[1]=flatCoordinates[1]+delta*dy;for(i=2;i<this.stride;++i){closestPoint[i]=flatCoordinates[i];}}closestPoint.length=this.stride;return squaredDistance;}else{return minSquaredDistance;}};/**
 * @inheritDoc
 */_ol_geom_Circle_.prototype.containsXY=function(x,y){var flatCoordinates=this.flatCoordinates;var dx=x-flatCoordinates[0];var dy=y-flatCoordinates[1];return dx*dx+dy*dy<=this.getRadiusSquared_();};/**
 * Return the center of the circle as {@link ol.Coordinate coordinate}.
 * @return {ol.Coordinate} Center.
 * @api
 */_ol_geom_Circle_.prototype.getCenter=function(){return this.flatCoordinates.slice(0,this.stride);};/**
 * @inheritDoc
 */_ol_geom_Circle_.prototype.computeExtent=function(extent){var flatCoordinates=this.flatCoordinates;var radius=flatCoordinates[this.stride]-flatCoordinates[0];return _ol_extent_.createOrUpdate(flatCoordinates[0]-radius,flatCoordinates[1]-radius,flatCoordinates[0]+radius,flatCoordinates[1]+radius,extent);};/**
 * Return the radius of the circle.
 * @return {number} Radius.
 * @api
 */_ol_geom_Circle_.prototype.getRadius=function(){return Math.sqrt(this.getRadiusSquared_());};/**
 * @private
 * @return {number} Radius squared.
 */_ol_geom_Circle_.prototype.getRadiusSquared_=function(){var dx=this.flatCoordinates[this.stride]-this.flatCoordinates[0];var dy=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return dx*dx+dy*dy;};/**
 * @inheritDoc
 * @api
 */_ol_geom_Circle_.prototype.getType=function(){return _ol_geom_GeometryType_.CIRCLE;};/**
 * @inheritDoc
 * @api
 */_ol_geom_Circle_.prototype.intersectsExtent=function(extent){var circleExtent=this.getExtent();if(_ol_extent_.intersects(extent,circleExtent)){var center=this.getCenter();if(extent[0]<=center[0]&&extent[2]>=center[0]){return true;}if(extent[1]<=center[1]&&extent[3]>=center[1]){return true;}return _ol_extent_.forEachCorner(extent,this.intersectsCoordinate,this);}return false;};/**
 * Set the center of the circle as {@link ol.Coordinate coordinate}.
 * @param {ol.Coordinate} center Center.
 * @api
 */_ol_geom_Circle_.prototype.setCenter=function(center){var stride=this.stride;var radius=this.flatCoordinates[stride]-this.flatCoordinates[0];var flatCoordinates=center.slice();flatCoordinates[stride]=flatCoordinates[0]+radius;var i;for(i=1;i<stride;++i){flatCoordinates[stride+i]=center[i];}this.setFlatCoordinates(this.layout,flatCoordinates);};/**
 * Set the center (as {@link ol.Coordinate coordinate}) and the radius (as
 * number) of the circle.
 * @param {ol.Coordinate} center Center.
 * @param {number} radius Radius.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */_ol_geom_Circle_.prototype.setCenterAndRadius=function(center,radius,opt_layout){if(!center){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null);}else{this.setLayout(opt_layout,center,0);if(!this.flatCoordinates){this.flatCoordinates=[];}/** @type {Array.<number>} */var flatCoordinates=this.flatCoordinates;var offset=_ol_geom_flat_deflate_.coordinate(flatCoordinates,0,center,this.stride);flatCoordinates[offset++]=flatCoordinates[0]+radius;var i,ii;for(i=1,ii=this.stride;i<ii;++i){flatCoordinates[offset++]=flatCoordinates[i];}flatCoordinates.length=offset;this.changed();}};/**
 * @inheritDoc
 */_ol_geom_Circle_.prototype.getCoordinates=function(){};/**
 * @inheritDoc
 */_ol_geom_Circle_.prototype.setCoordinates=function(coordinates,opt_layout){};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */_ol_geom_Circle_.prototype.setFlatCoordinates=function(layout,flatCoordinates){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.changed();};/**
 * Set the radius of the circle. The radius is in the units of the projection.
 * @param {number} radius Radius.
 * @api
 */_ol_geom_Circle_.prototype.setRadius=function(radius){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+radius;this.changed();};/**
 * Constants for event names.
 * @enum {string}
 */var _ol_MapBrowserEventType_={/**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event ol.MapBrowserEvent#singleclick
   * @api
   */SINGLECLICK:'singleclick',/**
   * A click with no dragging. A double click will fire two of this.
   * @event ol.MapBrowserEvent#click
   * @api
   */CLICK:_ol_events_EventType_.CLICK,/**
   * A true double click, with no dragging.
   * @event ol.MapBrowserEvent#dblclick
   * @api
   */DBLCLICK:_ol_events_EventType_.DBLCLICK,/**
   * Triggered when a pointer is dragged.
   * @event ol.MapBrowserEvent#pointerdrag
   * @api
   */POINTERDRAG:'pointerdrag',/**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event ol.MapBrowserEvent#pointermove
   * @api
   */POINTERMOVE:'pointermove',POINTERDOWN:'pointerdown',POINTERUP:'pointerup',POINTEROVER:'pointerover',POINTEROUT:'pointerout',POINTERENTER:'pointerenter',POINTERLEAVE:'pointerleave',POINTERCANCEL:'pointercancel'};var _ol_string_={};/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
*/_ol_string_.padNumber=function(number,width,opt_precision){var numberString=opt_precision!==undefined?number.toFixed(opt_precision):''+number;var decimal=numberString.indexOf('.');decimal=decimal===-1?numberString.length:decimal;return decimal>width?numberString:new Array(1+width-decimal).join('0')+numberString;};/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */_ol_string_.compareVersions=function(v1,v2){var s1=(''+v1).split('.');var s2=(''+v2).split('.');for(var i=0;i<Math.max(s1.length,s2.length);i++){var n1=parseInt(s1[i]||'0',10);var n2=parseInt(s2[i]||'0',10);if(n1>n2){return 1;}if(n2>n1){return-1;}}return 0;};var _ol_coordinate_={};/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     ol.coordinate.add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} The input coordinate adjusted by the given delta.
 * @api
 */_ol_coordinate_.add=function(coordinate,delta){coordinate[0]+=delta[0];coordinate[1]+=delta[1];return coordinate;};/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {ol.geom.Circle} circle The circle.
 * @return {ol.Coordinate} Closest point on the circumference
 */_ol_coordinate_.closestOnCircle=function(coordinate,circle){var r=circle.getRadius();var center=circle.getCenter();var x0=center[0];var y0=center[1];var x1=coordinate[0];var y1=coordinate[1];var dx=x1-x0;var dy=y1-y0;if(dx===0&&dy===0){dx=1;}var d=Math.sqrt(dx*dx+dy*dy);var x,y;x=x0+r*dx/d;y=y0+r*dy/d;return[x,y];};/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {Array.<ol.Coordinate>} segment The two coordinates of the segment.
 * @return {ol.Coordinate} The foot of the perpendicular of the coordinate to
 *     the segment.
 */_ol_coordinate_.closestOnSegment=function(coordinate,segment){var x0=coordinate[0];var y0=coordinate[1];var start=segment[0];var end=segment[1];var x1=start[0];var y1=start[1];var x2=end[0];var y2=end[1];var dx=x2-x1;var dy=y2-y1;var along=dx===0&&dy===0?0:(dx*(x0-x1)+dy*(y0-y1))/(dx*dx+dy*dy||0);var x,y;if(along<=0){x=x1;y=y1;}else if(along>=1){x=x2;y=y2;}else{x=x1+along*dx;y=y1+along*dy;}return[x,y];};/**
 * Returns a {@link ol.CoordinateFormatType} function that can be used to format
 * a {ol.Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {ol.CoordinateFormatType} Coordinate format.
 * @api
 */_ol_coordinate_.createStringXY=function(opt_fractionDigits){return(/**
     * @param {ol.Coordinate|undefined} coordinate Coordinate.
     * @return {string} String XY.
     */function(coordinate){return _ol_coordinate_.toStringXY(coordinate,opt_fractionDigits);});};/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */_ol_coordinate_.degreesToStringHDMS=function(hemispheres,degrees,opt_fractionDigits){var normalizedDegrees=_ol_math_.modulo(degrees+180,360)-180;var x=Math.abs(3600*normalizedDegrees);var dflPrecision=opt_fractionDigits||0;var precision=Math.pow(10,dflPrecision);var deg=Math.floor(x/3600);var min=Math.floor((x-deg*3600)/60);var sec=x-deg*3600-min*60;sec=Math.ceil(sec*precision)/precision;if(sec>=60){sec=0;min+=1;}if(min>=60){min=0;deg+=1;}return deg+'\u00b0 '+_ol_string_.padNumber(min,2)+'\u2032 '+_ol_string_.padNumber(sec,2,dflPrecision)+'\u2033'+(normalizedDegrees==0?'':' '+hemispheres.charAt(normalizedDegrees<0?1:0));};/**
 * Transforms the given {@link ol.Coordinate} to a string using the given string
 * template. The strings `{x}` and `{y}` in the template will be replaced with
 * the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */_ol_coordinate_.format=function(coordinate,template,opt_fractionDigits){if(coordinate){return template.replace('{x}',coordinate[0].toFixed(opt_fractionDigits)).replace('{y}',coordinate[1].toFixed(opt_fractionDigits));}else{return'';}};/**
 * @param {ol.Coordinate} coordinate1 First coordinate.
 * @param {ol.Coordinate} coordinate2 Second coordinate.
 * @return {boolean} Whether the passed coordinates are equal.
 */_ol_coordinate_.equals=function(coordinate1,coordinate2){var equals=true;for(var i=coordinate1.length-1;i>=0;--i){if(coordinate1[i]!=coordinate2[i]){equals=false;break;}}return equals;};/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     ol.coordinate.rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */_ol_coordinate_.rotate=function(coordinate,angle){var cosAngle=Math.cos(angle);var sinAngle=Math.sin(angle);var x=coordinate[0]*cosAngle-coordinate[1]*sinAngle;var y=coordinate[1]*cosAngle+coordinate[0]*sinAngle;coordinate[0]=x;coordinate[1]=y;return coordinate;};/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     ol.coordinate.scale(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {ol.Coordinate} Coordinate.
 */_ol_coordinate_.scale=function(coordinate,scale){coordinate[0]*=scale;coordinate[1]*=scale;return coordinate;};/**
 * Subtract `delta` to `coordinate`. `coordinate` is modified in place and
 * returned by the function.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} Coordinate.
 */_ol_coordinate_.sub=function(coordinate,delta){coordinate[0]-=delta[0];coordinate[1]-=delta[1];return coordinate;};/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */_ol_coordinate_.squaredDistance=function(coord1,coord2){var dx=coord1[0]-coord2[0];var dy=coord1[1]-coord2[1];return dx*dx+dy*dy;};/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */_ol_coordinate_.distance=function(coord1,coord2){return Math.sqrt(_ol_coordinate_.squaredDistance(coord1,coord2));};/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {ol.Coordinate} coordinate Coordinate of the point.
 * @param {Array.<ol.Coordinate>} segment Line segment (2 coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */_ol_coordinate_.squaredDistanceToSegment=function(coordinate,segment){return _ol_coordinate_.squaredDistance(coordinate,_ol_coordinate_.closestOnSegment(coordinate,segment));};/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord);
 *     // out is now '47 58 60 N 7 50 60 E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord, 1);
 *     // out is now '47 58 60.0 N 7 50 60.0 E'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */_ol_coordinate_.toStringHDMS=function(coordinate,opt_fractionDigits){if(coordinate){return _ol_coordinate_.degreesToStringHDMS('NS',coordinate[1],opt_fractionDigits)+' '+_ol_coordinate_.degreesToStringHDMS('EW',coordinate[0],opt_fractionDigits);}else{return'';}};/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */_ol_coordinate_.toStringXY=function(coordinate,opt_fractionDigits){return _ol_coordinate_.format(coordinate,'{x}, {y}',opt_fractionDigits);};var _ol_events_condition_={};/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */_ol_events_condition_.altKeyOnly=function(mapBrowserEvent){var originalEvent=mapBrowserEvent.originalEvent;return originalEvent.altKey&&!(originalEvent.metaKey||originalEvent.ctrlKey)&&!originalEvent.shiftKey;};/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */_ol_events_condition_.altShiftKeysOnly=function(mapBrowserEvent){var originalEvent=mapBrowserEvent.originalEvent;return originalEvent.altKey&&!(originalEvent.metaKey||originalEvent.ctrlKey)&&originalEvent.shiftKey;};/**
 * Return always true.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @function
 * @api
 */_ol_events_condition_.always=_ol_functions_.TRUE;/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */_ol_events_condition_.click=function(mapBrowserEvent){return mapBrowserEvent.type==_ol_MapBrowserEventType_.CLICK;};/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */_ol_events_condition_.mouseActionButton=function(mapBrowserEvent){var originalEvent=mapBrowserEvent.originalEvent;return originalEvent.button==0&&!(_ol_has_.WEBKIT&&_ol_has_.MAC&&originalEvent.ctrlKey);};/**
 * Return always false.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @function
 * @api
 */_ol_events_condition_.never=_ol_functions_.FALSE;/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */_ol_events_condition_.pointerMove=function(mapBrowserEvent){return mapBrowserEvent.type=='pointermove';};/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */_ol_events_condition_.singleClick=function(mapBrowserEvent){return mapBrowserEvent.type==_ol_MapBrowserEventType_.SINGLECLICK;};/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */_ol_events_condition_.doubleClick=function(mapBrowserEvent){return mapBrowserEvent.type==_ol_MapBrowserEventType_.DBLCLICK;};/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */_ol_events_condition_.noModifierKeys=function(mapBrowserEvent){var originalEvent=mapBrowserEvent.originalEvent;return!originalEvent.altKey&&!(originalEvent.metaKey||originalEvent.ctrlKey)&&!originalEvent.shiftKey;};/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */_ol_events_condition_.platformModifierKeyOnly=function(mapBrowserEvent){var originalEvent=mapBrowserEvent.originalEvent;return!originalEvent.altKey&&(_ol_has_.MAC?originalEvent.metaKey:originalEvent.ctrlKey)&&!originalEvent.shiftKey;};/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */_ol_events_condition_.shiftKeyOnly=function(mapBrowserEvent){var originalEvent=mapBrowserEvent.originalEvent;return!originalEvent.altKey&&!(originalEvent.metaKey||originalEvent.ctrlKey)&&originalEvent.shiftKey;};/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */_ol_events_condition_.targetNotEditable=function(mapBrowserEvent){var target=mapBrowserEvent.originalEvent.target;var tagName=target.tagName;return tagName!=='INPUT'&&tagName!=='SELECT'&&tagName!=='TEXTAREA';};/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */_ol_events_condition_.mouseOnly=function(mapBrowserEvent){_ol_asserts_.assert(mapBrowserEvent.pointerEvent,56);// mapBrowserEvent must originate from a pointer event
// see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
return(/** @type {ol.MapBrowserEvent} */mapBrowserEvent.pointerEvent.pointerType=='mouse');};/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * @see http://www.w3.org/TR/pointerevents/#button-states
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */_ol_events_condition_.primaryAction=function(mapBrowserEvent){var pointerEvent=mapBrowserEvent.pointerEvent;return pointerEvent.isPrimary&&pointerEvent.button===0;};/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_MultiLineString_=function(coordinates,opt_layout){_ol_geom_SimpleGeometry_.call(this);/**
   * @type {Array.<number>}
   * @private
   */this.ends_=[];/**
   * @private
   * @type {number}
   */this.maxDelta_=-1;/**
   * @private
   * @type {number}
   */this.maxDeltaRevision_=-1;this.setCoordinates(coordinates,opt_layout);};_ol_.inherits(_ol_geom_MultiLineString_,_ol_geom_SimpleGeometry_);/**
 * Append the passed linestring to the multilinestring.
 * @param {ol.geom.LineString} lineString LineString.
 * @api
 */_ol_geom_MultiLineString_.prototype.appendLineString=function(lineString){if(!this.flatCoordinates){this.flatCoordinates=lineString.getFlatCoordinates().slice();}else{_ol_array_.extend(this.flatCoordinates,lineString.getFlatCoordinates().slice());}this.ends_.push(this.flatCoordinates.length);this.changed();};/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiLineString} Clone.
 * @override
 * @api
 */_ol_geom_MultiLineString_.prototype.clone=function(){var multiLineString=new _ol_geom_MultiLineString_(null);multiLineString.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),this.ends_.slice());return multiLineString;};/**
 * @inheritDoc
 */_ol_geom_MultiLineString_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){if(minSquaredDistance<_ol_extent_.closestSquaredDistanceXY(this.getExtent(),x,y)){return minSquaredDistance;}if(this.maxDeltaRevision_!=this.getRevision()){this.maxDelta_=Math.sqrt(_ol_geom_flat_closest_.getsMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0));this.maxDeltaRevision_=this.getRevision();}return _ol_geom_flat_closest_.getsClosestPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,false,x,y,closestPoint,minSquaredDistance);};/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * `opt_interpolate` controls interpolation between consecutive LineStrings
 * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
 * will be linearly interpolated between the last coordinate of one LineString
 * and the first coordinate of the next LineString.  If `opt_interpolate` is
 * `false` then the function will return `null` for Ms falling between
 * LineStrings.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */_ol_geom_MultiLineString_.prototype.getCoordinateAtM=function(m,opt_extrapolate,opt_interpolate){if(this.layout!=_ol_geom_GeometryLayout_.XYM&&this.layout!=_ol_geom_GeometryLayout_.XYZM||this.flatCoordinates.length===0){return null;}var extrapolate=opt_extrapolate!==undefined?opt_extrapolate:false;var interpolate=opt_interpolate!==undefined?opt_interpolate:false;return _ol_geom_flat_interpolate_.lineStringsCoordinateAtM(this.flatCoordinates,0,this.ends_,this.stride,m,extrapolate,interpolate);};/**
 * Return the coordinates of the multilinestring.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */_ol_geom_MultiLineString_.prototype.getCoordinates=function(){return _ol_geom_flat_inflate_.coordinatess(this.flatCoordinates,0,this.ends_,this.stride);};/**
 * @return {Array.<number>} Ends.
 */_ol_geom_MultiLineString_.prototype.getEnds=function(){return this.ends_;};/**
 * Return the linestring at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.LineString} LineString.
 * @api
 */_ol_geom_MultiLineString_.prototype.getLineString=function(index){if(index<0||this.ends_.length<=index){return null;}var lineString=new _ol_geom_LineString_(null);lineString.setFlatCoordinates(this.layout,this.flatCoordinates.slice(index===0?0:this.ends_[index-1],this.ends_[index]));return lineString;};/**
 * Return the linestrings of this multilinestring.
 * @return {Array.<ol.geom.LineString>} LineStrings.
 * @api
 */_ol_geom_MultiLineString_.prototype.getLineStrings=function(){var flatCoordinates=this.flatCoordinates;var ends=this.ends_;var layout=this.layout;/** @type {Array.<ol.geom.LineString>} */var lineStrings=[];var offset=0;var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];var lineString=new _ol_geom_LineString_(null);lineString.setFlatCoordinates(layout,flatCoordinates.slice(offset,end));lineStrings.push(lineString);offset=end;}return lineStrings;};/**
 * @return {Array.<number>} Flat midpoints.
 */_ol_geom_MultiLineString_.prototype.getFlatMidpoints=function(){var midpoints=[];var flatCoordinates=this.flatCoordinates;var offset=0;var ends=this.ends_;var stride=this.stride;var i,ii;for(i=0,ii=ends.length;i<ii;++i){var end=ends[i];var midpoint=_ol_geom_flat_interpolate_.lineString(flatCoordinates,offset,end,stride,0.5);_ol_array_.extend(midpoints,midpoint);offset=end;}return midpoints;};/**
 * @inheritDoc
 */_ol_geom_MultiLineString_.prototype.getSimplifiedGeometryInternal=function(squaredTolerance){var simplifiedFlatCoordinates=[];var simplifiedEnds=[];simplifiedFlatCoordinates.length=_ol_geom_flat_simplify_.douglasPeuckers(this.flatCoordinates,0,this.ends_,this.stride,squaredTolerance,simplifiedFlatCoordinates,0,simplifiedEnds);var simplifiedMultiLineString=new _ol_geom_MultiLineString_(null);simplifiedMultiLineString.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,simplifiedFlatCoordinates,simplifiedEnds);return simplifiedMultiLineString;};/**
 * @inheritDoc
 * @api
 */_ol_geom_MultiLineString_.prototype.getType=function(){return _ol_geom_GeometryType_.MULTI_LINE_STRING;};/**
 * @inheritDoc
 * @api
 */_ol_geom_MultiLineString_.prototype.intersectsExtent=function(extent){return _ol_geom_flat_intersectsextent_.lineStrings(this.flatCoordinates,0,this.ends_,this.stride,extent);};/**
 * Set the coordinates of the multilinestring.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */_ol_geom_MultiLineString_.prototype.setCoordinates=function(coordinates,opt_layout){if(!coordinates){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null,this.ends_);}else{this.setLayout(opt_layout,coordinates,2);if(!this.flatCoordinates){this.flatCoordinates=[];}var ends=_ol_geom_flat_deflate_.coordinatess(this.flatCoordinates,0,coordinates,this.stride,this.ends_);this.flatCoordinates.length=ends.length===0?0:ends[ends.length-1];this.changed();}};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */_ol_geom_MultiLineString_.prototype.setFlatCoordinates=function(layout,flatCoordinates,ends){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.ends_=ends;this.changed();};/**
 * @param {Array.<ol.geom.LineString>} lineStrings LineStrings.
 */_ol_geom_MultiLineString_.prototype.setLineStrings=function(lineStrings){var layout=this.getLayout();var flatCoordinates=[];var ends=[];var i,ii;for(i=0,ii=lineStrings.length;i<ii;++i){var lineString=lineStrings[i];if(i===0){layout=lineString.getLayout();}_ol_array_.extend(flatCoordinates,lineString.getFlatCoordinates());ends.push(flatCoordinates.length);}this.setFlatCoordinates(layout,flatCoordinates,ends);};/**
 * @classdesc
 * Multi-point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_MultiPoint_=function(coordinates,opt_layout){_ol_geom_SimpleGeometry_.call(this);this.setCoordinates(coordinates,opt_layout);};_ol_.inherits(_ol_geom_MultiPoint_,_ol_geom_SimpleGeometry_);/**
 * Append the passed point to this multipoint.
 * @param {ol.geom.Point} point Point.
 * @api
 */_ol_geom_MultiPoint_.prototype.appendPoint=function(point){if(!this.flatCoordinates){this.flatCoordinates=point.getFlatCoordinates().slice();}else{_ol_array_.extend(this.flatCoordinates,point.getFlatCoordinates());}this.changed();};/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPoint} Clone.
 * @override
 * @api
 */_ol_geom_MultiPoint_.prototype.clone=function(){var multiPoint=new _ol_geom_MultiPoint_(null);multiPoint.setFlatCoordinates(this.layout,this.flatCoordinates.slice());return multiPoint;};/**
 * @inheritDoc
 */_ol_geom_MultiPoint_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){if(minSquaredDistance<_ol_extent_.closestSquaredDistanceXY(this.getExtent(),x,y)){return minSquaredDistance;}var flatCoordinates=this.flatCoordinates;var stride=this.stride;var i,ii,j;for(i=0,ii=flatCoordinates.length;i<ii;i+=stride){var squaredDistance=_ol_math_.squaredDistance(x,y,flatCoordinates[i],flatCoordinates[i+1]);if(squaredDistance<minSquaredDistance){minSquaredDistance=squaredDistance;for(j=0;j<stride;++j){closestPoint[j]=flatCoordinates[i+j];}closestPoint.length=stride;}}return minSquaredDistance;};/**
 * Return the coordinates of the multipoint.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */_ol_geom_MultiPoint_.prototype.getCoordinates=function(){return _ol_geom_flat_inflate_.coordinates(this.flatCoordinates,0,this.flatCoordinates.length,this.stride);};/**
 * Return the point at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Point} Point.
 * @api
 */_ol_geom_MultiPoint_.prototype.getPoint=function(index){var n=!this.flatCoordinates?0:this.flatCoordinates.length/this.stride;if(index<0||n<=index){return null;}var point=new _ol_geom_Point_(null);point.setFlatCoordinates(this.layout,this.flatCoordinates.slice(index*this.stride,(index+1)*this.stride));return point;};/**
 * Return the points of this multipoint.
 * @return {Array.<ol.geom.Point>} Points.
 * @api
 */_ol_geom_MultiPoint_.prototype.getPoints=function(){var flatCoordinates=this.flatCoordinates;var layout=this.layout;var stride=this.stride;/** @type {Array.<ol.geom.Point>} */var points=[];var i,ii;for(i=0,ii=flatCoordinates.length;i<ii;i+=stride){var point=new _ol_geom_Point_(null);point.setFlatCoordinates(layout,flatCoordinates.slice(i,i+stride));points.push(point);}return points;};/**
 * @inheritDoc
 * @api
 */_ol_geom_MultiPoint_.prototype.getType=function(){return _ol_geom_GeometryType_.MULTI_POINT;};/**
 * @inheritDoc
 * @api
 */_ol_geom_MultiPoint_.prototype.intersectsExtent=function(extent){var flatCoordinates=this.flatCoordinates;var stride=this.stride;var i,ii,x,y;for(i=0,ii=flatCoordinates.length;i<ii;i+=stride){x=flatCoordinates[i];y=flatCoordinates[i+1];if(_ol_extent_.containsXY(extent,x,y)){return true;}}return false;};/**
 * Set the coordinates of the multipoint.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */_ol_geom_MultiPoint_.prototype.setCoordinates=function(coordinates,opt_layout){if(!coordinates){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null);}else{this.setLayout(opt_layout,coordinates,1);if(!this.flatCoordinates){this.flatCoordinates=[];}this.flatCoordinates.length=_ol_geom_flat_deflate_.coordinates(this.flatCoordinates,0,coordinates,this.stride);this.changed();}};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */_ol_geom_MultiPoint_.prototype.setFlatCoordinates=function(layout,flatCoordinates){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.changed();};var _ol_geom_flat_center_={};/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array.<number>} Flat centers.
 */_ol_geom_flat_center_.linearRingss=function(flatCoordinates,offset,endss,stride){var flatCenters=[];var i,ii;var extent=_ol_extent_.createEmpty();for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i];extent=_ol_extent_.createOrUpdateFromFlatCoordinates(flatCoordinates,offset,ends[0],stride);flatCenters.push((extent[0]+extent[2])/2,(extent[1]+extent[3])/2);offset=ends[ends.length-1];}return flatCenters;};/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */var _ol_geom_MultiPolygon_=function(coordinates,opt_layout){_ol_geom_SimpleGeometry_.call(this);/**
   * @type {Array.<Array.<number>>}
   * @private
   */this.endss_=[];/**
   * @private
   * @type {number}
   */this.flatInteriorPointsRevision_=-1;/**
   * @private
   * @type {Array.<number>}
   */this.flatInteriorPoints_=null;/**
   * @private
   * @type {number}
   */this.maxDelta_=-1;/**
   * @private
   * @type {number}
   */this.maxDeltaRevision_=-1;/**
   * @private
   * @type {number}
   */this.orientedRevision_=-1;/**
   * @private
   * @type {Array.<number>}
   */this.orientedFlatCoordinates_=null;this.setCoordinates(coordinates,opt_layout);};_ol_.inherits(_ol_geom_MultiPolygon_,_ol_geom_SimpleGeometry_);/**
 * Append the passed polygon to this multipolygon.
 * @param {ol.geom.Polygon} polygon Polygon.
 * @api
 */_ol_geom_MultiPolygon_.prototype.appendPolygon=function(polygon){/** @type {Array.<number>} */var ends;if(!this.flatCoordinates){this.flatCoordinates=polygon.getFlatCoordinates().slice();ends=polygon.getEnds().slice();this.endss_.push();}else{var offset=this.flatCoordinates.length;_ol_array_.extend(this.flatCoordinates,polygon.getFlatCoordinates());ends=polygon.getEnds().slice();var i,ii;for(i=0,ii=ends.length;i<ii;++i){ends[i]+=offset;}}this.endss_.push(ends);this.changed();};/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPolygon} Clone.
 * @override
 * @api
 */_ol_geom_MultiPolygon_.prototype.clone=function(){var multiPolygon=new _ol_geom_MultiPolygon_(null);var len=this.endss_.length;var newEndss=new Array(len);for(var i=0;i<len;++i){newEndss[i]=this.endss_[i].slice();}multiPolygon.setFlatCoordinates(this.layout,this.flatCoordinates.slice(),newEndss);return multiPolygon;};/**
 * @inheritDoc
 */_ol_geom_MultiPolygon_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){if(minSquaredDistance<_ol_extent_.closestSquaredDistanceXY(this.getExtent(),x,y)){return minSquaredDistance;}if(this.maxDeltaRevision_!=this.getRevision()){this.maxDelta_=Math.sqrt(_ol_geom_flat_closest_.getssMaxSquaredDelta(this.flatCoordinates,0,this.endss_,this.stride,0));this.maxDeltaRevision_=this.getRevision();}return _ol_geom_flat_closest_.getssClosestPoint(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,true,x,y,closestPoint,minSquaredDistance);};/**
 * @inheritDoc
 */_ol_geom_MultiPolygon_.prototype.containsXY=function(x,y){return _ol_geom_flat_contains_.linearRingssContainsXY(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,x,y);};/**
 * Return the area of the multipolygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */_ol_geom_MultiPolygon_.prototype.getArea=function(){return _ol_geom_flat_area_.linearRingss(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride);};/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for multi-polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinates.
 * @override
 * @api
 */_ol_geom_MultiPolygon_.prototype.getCoordinates=function(opt_right){var flatCoordinates;if(opt_right!==undefined){flatCoordinates=this.getOrientedFlatCoordinates().slice();_ol_geom_flat_orient_.orientLinearRingss(flatCoordinates,0,this.endss_,this.stride,opt_right);}else{flatCoordinates=this.flatCoordinates;}return _ol_geom_flat_inflate_.coordinatesss(flatCoordinates,0,this.endss_,this.stride);};/**
 * @return {Array.<Array.<number>>} Endss.
 */_ol_geom_MultiPolygon_.prototype.getEndss=function(){return this.endss_;};/**
 * @return {Array.<number>} Flat interior points.
 */_ol_geom_MultiPolygon_.prototype.getFlatInteriorPoints=function(){if(this.flatInteriorPointsRevision_!=this.getRevision()){var flatCenters=_ol_geom_flat_center_.linearRingss(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=_ol_geom_flat_interiorpoint_.linearRingss(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,flatCenters);this.flatInteriorPointsRevision_=this.getRevision();}return this.flatInteriorPoints_;};/**
 * Return the interior points as {@link ol.geom.MultiPoint multipoint}.
 * @return {ol.geom.MultiPoint} Interior points.
 * @api
 */_ol_geom_MultiPolygon_.prototype.getInteriorPoints=function(){var interiorPoints=new _ol_geom_MultiPoint_(null);interiorPoints.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,this.getFlatInteriorPoints().slice());return interiorPoints;};/**
 * @return {Array.<number>} Oriented flat coordinates.
 */_ol_geom_MultiPolygon_.prototype.getOrientedFlatCoordinates=function(){if(this.orientedRevision_!=this.getRevision()){var flatCoordinates=this.flatCoordinates;if(_ol_geom_flat_orient_.linearRingssAreOriented(flatCoordinates,0,this.endss_,this.stride)){this.orientedFlatCoordinates_=flatCoordinates;}else{this.orientedFlatCoordinates_=flatCoordinates.slice();this.orientedFlatCoordinates_.length=_ol_geom_flat_orient_.orientLinearRingss(this.orientedFlatCoordinates_,0,this.endss_,this.stride);}this.orientedRevision_=this.getRevision();}return this.orientedFlatCoordinates_;};/**
 * @inheritDoc
 */_ol_geom_MultiPolygon_.prototype.getSimplifiedGeometryInternal=function(squaredTolerance){var simplifiedFlatCoordinates=[];var simplifiedEndss=[];simplifiedFlatCoordinates.length=_ol_geom_flat_simplify_.quantizess(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(squaredTolerance),simplifiedFlatCoordinates,0,simplifiedEndss);var simplifiedMultiPolygon=new _ol_geom_MultiPolygon_(null);simplifiedMultiPolygon.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,simplifiedFlatCoordinates,simplifiedEndss);return simplifiedMultiPolygon;};/**
 * Return the polygon at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Polygon} Polygon.
 * @api
 */_ol_geom_MultiPolygon_.prototype.getPolygon=function(index){if(index<0||this.endss_.length<=index){return null;}var offset;if(index===0){offset=0;}else{var prevEnds=this.endss_[index-1];offset=prevEnds[prevEnds.length-1];}var ends=this.endss_[index].slice();var end=ends[ends.length-1];if(offset!==0){var i,ii;for(i=0,ii=ends.length;i<ii;++i){ends[i]-=offset;}}var polygon=new _ol_geom_Polygon_(null);polygon.setFlatCoordinates(this.layout,this.flatCoordinates.slice(offset,end),ends);return polygon;};/**
 * Return the polygons of this multipolygon.
 * @return {Array.<ol.geom.Polygon>} Polygons.
 * @api
 */_ol_geom_MultiPolygon_.prototype.getPolygons=function(){var layout=this.layout;var flatCoordinates=this.flatCoordinates;var endss=this.endss_;var polygons=[];var offset=0;var i,ii,j,jj;for(i=0,ii=endss.length;i<ii;++i){var ends=endss[i].slice();var end=ends[ends.length-1];if(offset!==0){for(j=0,jj=ends.length;j<jj;++j){ends[j]-=offset;}}var polygon=new _ol_geom_Polygon_(null);polygon.setFlatCoordinates(layout,flatCoordinates.slice(offset,end),ends);polygons.push(polygon);offset=end;}return polygons;};/**
 * @inheritDoc
 * @api
 */_ol_geom_MultiPolygon_.prototype.getType=function(){return _ol_geom_GeometryType_.MULTI_POLYGON;};/**
 * @inheritDoc
 * @api
 */_ol_geom_MultiPolygon_.prototype.intersectsExtent=function(extent){return _ol_geom_flat_intersectsextent_.linearRingss(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,extent);};/**
 * Set the coordinates of the multipolygon.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */_ol_geom_MultiPolygon_.prototype.setCoordinates=function(coordinates,opt_layout){if(!coordinates){this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY,null,this.endss_);}else{this.setLayout(opt_layout,coordinates,3);if(!this.flatCoordinates){this.flatCoordinates=[];}var endss=_ol_geom_flat_deflate_.coordinatesss(this.flatCoordinates,0,coordinates,this.stride,this.endss_);if(endss.length===0){this.flatCoordinates.length=0;}else{var lastEnds=endss[endss.length-1];this.flatCoordinates.length=lastEnds.length===0?0:lastEnds[lastEnds.length-1];}this.changed();}};/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} endss Endss.
 */_ol_geom_MultiPolygon_.prototype.setFlatCoordinates=function(layout,flatCoordinates,endss){this.setFlatCoordinatesInternal(layout,flatCoordinates);this.endss_=endss;this.changed();};/**
 * @param {Array.<ol.geom.Polygon>} polygons Polygons.
 */_ol_geom_MultiPolygon_.prototype.setPolygons=function(polygons){var layout=this.getLayout();var flatCoordinates=[];var endss=[];var i,ii,ends;for(i=0,ii=polygons.length;i<ii;++i){var polygon=polygons[i];if(i===0){layout=polygon.getLayout();}var offset=flatCoordinates.length;ends=polygon.getEnds();var j,jj;for(j=0,jj=ends.length;j<jj;++j){ends[j]+=offset;}_ol_array_.extend(flatCoordinates,polygon.getFlatCoordinates());endss.push(ends);}this.setFlatCoordinates(layout,flatCoordinates,endss);};/**
 * @enum {string}
 */var _ol_interaction_DrawEventType_={/**
   * Triggered upon feature draw start
   * @event ol.interaction.Draw.Event#drawstart
   * @api
   */DRAWSTART:'drawstart',/**
   * Triggered upon feature draw end
   * @event ol.interaction.Draw.Event#drawend
   * @api
   */DRAWEND:'drawend'};/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link ol.Map} for which events trigger a map event.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.MapEvent}
 * @param {string} type Event type.
 * @param {ol.Map} map Map.
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */var _ol_MapEvent_=function(type,map,opt_frameState){_ol_events_Event_.call(this,type);/**
   * The map where the event occurred.
   * @type {ol.Map}
   * @api
   */this.map=map;/**
   * The frame state at the time of the event.
   * @type {?olx.FrameState}
   * @api
   */this.frameState=opt_frameState!==undefined?opt_frameState:null;};_ol_.inherits(_ol_MapEvent_,_ol_events_Event_);/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link ol.Map} for which events trigger a map browser event.
 *
 * @constructor
 * @extends {ol.MapEvent}
 * @implements {oli.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.Map} map Map.
 * @param {Event} browserEvent Browser event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */var _ol_MapBrowserEvent_=function(type,map,browserEvent,opt_dragging,opt_frameState){_ol_MapEvent_.call(this,type,map,opt_frameState);/**
   * The original browser event.
   * @const
   * @type {Event}
   * @api
   */this.originalEvent=browserEvent;/**
   * The map pixel relative to the viewport corresponding to the original browser event.
   * @type {ol.Pixel}
   * @api
   */this.pixel=map.getEventPixel(browserEvent);/**
   * The coordinate in view projection corresponding to the original browser event.
   * @type {ol.Coordinate}
   * @api
   */this.coordinate=map.getCoordinateFromPixel(this.pixel);/**
   * Indicates if the map is currently being dragged. Only set for
   * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
   *
   * @type {boolean}
   * @api
   */this.dragging=opt_dragging!==undefined?opt_dragging:false;};_ol_.inherits(_ol_MapBrowserEvent_,_ol_MapEvent_);/**
 * Prevents the default browser action.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault
 * @override
 * @api
 */_ol_MapBrowserEvent_.prototype.preventDefault=function(){_ol_MapEvent_.prototype.preventDefault.call(this);this.originalEvent.preventDefault();};/**
 * Prevents further propagation of the current event.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation
 * @override
 * @api
 */_ol_MapBrowserEvent_.prototype.stopPropagation=function(){_ol_MapEvent_.prototype.stopPropagation.call(this);this.originalEvent.stopPropagation();};/**
 * @constructor
 * @extends {ol.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.Map} map Map.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */var _ol_MapBrowserPointerEvent_=function(type,map,pointerEvent,opt_dragging,opt_frameState){_ol_MapBrowserEvent_.call(this,type,map,pointerEvent.originalEvent,opt_dragging,opt_frameState);/**
   * @const
   * @type {ol.pointer.PointerEvent}
   */this.pointerEvent=pointerEvent;};_ol_.inherits(_ol_MapBrowserPointerEvent_,_ol_MapBrowserEvent_);var _ol_easing_={};/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */_ol_easing_.easeIn=function(t){return Math.pow(t,3);};/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */_ol_easing_.easeOut=function(t){return 1-_ol_easing_.easeIn(1-t);};/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */_ol_easing_.inAndOut=function(t){return 3*t*t-2*t*t*t;};/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */_ol_easing_.linear=function(t){return t;};/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link ol.easing.inAndOut}, but the final slowdown
 * is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */_ol_easing_.upAndDown=function(t){if(t<0.5){return _ol_easing_.inAndOut(2*t);}else{return 1-_ol_easing_.inAndOut(2*(t-0.5));}};/**
 * @enum {string}
 */var _ol_interaction_Property_={ACTIVE:'active'};// FIXME factor out key precondition (shift et. al)
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link ol.interaction.KeyboardZoom} is functionally the same as
 * {@link ol.control.Zoom}, but triggered by a keyboard event not a button
 * element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 *
 * @constructor
 * @param {olx.interaction.InteractionOptions} options Options.
 * @extends {ol.Object}
 * @api
 */var _ol_interaction_Interaction_=function(options){_ol_Object_.call(this);/**
   * @private
   * @type {ol.Map}
   */this.map_=null;this.setActive(true);/**
   * @type {function(ol.MapBrowserEvent):boolean}
   */this.handleEvent=options.handleEvent;};_ol_.inherits(_ol_interaction_Interaction_,_ol_Object_);/**
 * Return whether the interaction is currently active.
 * @return {boolean} `true` if the interaction is active, `false` otherwise.
 * @observable
 * @api
 */_ol_interaction_Interaction_.prototype.getActive=function(){return(/** @type {boolean} */this.get(_ol_interaction_Property_.ACTIVE));};/**
 * Get the map associated with this interaction.
 * @return {ol.Map} Map.
 * @api
 */_ol_interaction_Interaction_.prototype.getMap=function(){return this.map_;};/**
 * Activate or deactivate the interaction.
 * @param {boolean} active Active.
 * @observable
 * @api
 */_ol_interaction_Interaction_.prototype.setActive=function(active){this.set(_ol_interaction_Property_.ACTIVE,active);};/**
 * Remove the interaction from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.Map} map Map.
 */_ol_interaction_Interaction_.prototype.setMap=function(map){this.map_=map;};/**
 * @param {ol.View} view View.
 * @param {ol.Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */_ol_interaction_Interaction_.pan=function(view,delta,opt_duration){var currentCenter=view.getCenter();if(currentCenter){var center=view.constrainCenter([currentCenter[0]+delta[0],currentCenter[1]+delta[1]]);if(opt_duration){view.animate({duration:opt_duration,easing:_ol_easing_.linear,center:center});}else{view.setCenter(center);}}};/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */_ol_interaction_Interaction_.rotate=function(view,rotation,opt_anchor,opt_duration){rotation=view.constrainRotation(rotation,0);_ol_interaction_Interaction_.rotateWithoutConstraints(view,rotation,opt_anchor,opt_duration);};/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */_ol_interaction_Interaction_.rotateWithoutConstraints=function(view,rotation,opt_anchor,opt_duration){if(rotation!==undefined){var currentRotation=view.getRotation();var currentCenter=view.getCenter();if(currentRotation!==undefined&&currentCenter&&opt_duration>0){view.animate({rotation:rotation,anchor:opt_anchor,duration:opt_duration,easing:_ol_easing_.easeOut});}else{view.rotate(rotation,opt_anchor);}}};/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */_ol_interaction_Interaction_.zoom=function(view,resolution,opt_anchor,opt_duration,opt_direction){resolution=view.constrainResolution(resolution,0,opt_direction);_ol_interaction_Interaction_.zoomWithoutConstraints(view,resolution,opt_anchor,opt_duration);};/**
 * @param {ol.View} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */_ol_interaction_Interaction_.zoomByDelta=function(view,delta,opt_anchor,opt_duration){var currentResolution=view.getResolution();var resolution=view.constrainResolution(currentResolution,delta,0);// If we have a constraint on center, we need to change the anchor so that the
// new center is within the extent. We first calculate the new center, apply
// the constraint to it, and then calculate back the anchor
if(opt_anchor&&resolution!==undefined&&resolution!==currentResolution){var currentCenter=view.getCenter();var center=view.calculateCenterZoom(resolution,opt_anchor);center=view.constrainCenter(center);opt_anchor=[(resolution*currentCenter[0]-currentResolution*center[0])/(resolution-currentResolution),(resolution*currentCenter[1]-currentResolution*center[1])/(resolution-currentResolution)];}_ol_interaction_Interaction_.zoomWithoutConstraints(view,resolution,opt_anchor,opt_duration);};/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */_ol_interaction_Interaction_.zoomWithoutConstraints=function(view,resolution,opt_anchor,opt_duration){if(resolution){var currentResolution=view.getResolution();var currentCenter=view.getCenter();if(currentResolution!==undefined&&currentCenter&&resolution!==currentResolution&&opt_duration){view.animate({resolution:resolution,anchor:opt_anchor,duration:opt_duration,easing:_ol_easing_.easeOut});}else{if(opt_anchor){var center=view.calculateCenterZoom(resolution,opt_anchor);view.setCenter(center);}view.setResolution(resolution);}}};/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 *
 * @constructor
 * @param {olx.interaction.PointerOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */var _ol_interaction_Pointer_=function(opt_options){var options=opt_options?opt_options:{};var handleEvent=options.handleEvent?options.handleEvent:_ol_interaction_Pointer_.handleEvent;_ol_interaction_Interaction_.call(this,{handleEvent:handleEvent});/**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */this.handleDownEvent_=options.handleDownEvent?options.handleDownEvent:_ol_interaction_Pointer_.handleDownEvent;/**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */this.handleDragEvent_=options.handleDragEvent?options.handleDragEvent:_ol_interaction_Pointer_.handleDragEvent;/**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */this.handleMoveEvent_=options.handleMoveEvent?options.handleMoveEvent:_ol_interaction_Pointer_.handleMoveEvent;/**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */this.handleUpEvent_=options.handleUpEvent?options.handleUpEvent:_ol_interaction_Pointer_.handleUpEvent;/**
   * @type {boolean}
   * @protected
   */this.handlingDownUpSequence=false;/**
   * @type {Object.<number, ol.pointer.PointerEvent>}
   * @private
   */this.trackedPointers_={};/**
   * @type {Array.<ol.pointer.PointerEvent>}
   * @protected
   */this.targetPointers=[];};_ol_.inherits(_ol_interaction_Pointer_,_ol_interaction_Interaction_);/**
 * @param {Array.<ol.pointer.PointerEvent>} pointerEvents List of events.
 * @return {ol.Pixel} Centroid pixel.
 */_ol_interaction_Pointer_.centroid=function(pointerEvents){var length=pointerEvents.length;var clientX=0;var clientY=0;for(var i=0;i<length;i++){clientX+=pointerEvents[i].clientX;clientY+=pointerEvents[i].clientY;}return[clientX/length,clientY/length];};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 * @private
 */_ol_interaction_Pointer_.prototype.isPointerDraggingEvent_=function(mapBrowserEvent){var type=mapBrowserEvent.type;return type===_ol_MapBrowserEventType_.POINTERDOWN||type===_ol_MapBrowserEventType_.POINTERDRAG||type===_ol_MapBrowserEventType_.POINTERUP;};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @private
 */_ol_interaction_Pointer_.prototype.updateTrackedPointers_=function(mapBrowserEvent){if(this.isPointerDraggingEvent_(mapBrowserEvent)){var event=mapBrowserEvent.pointerEvent;if(mapBrowserEvent.type==_ol_MapBrowserEventType_.POINTERUP){delete this.trackedPointers_[event.pointerId];}else if(mapBrowserEvent.type==_ol_MapBrowserEventType_.POINTERDOWN){this.trackedPointers_[event.pointerId]=event;}else if(event.pointerId in this.trackedPointers_){// update only when there was a pointerdown event for this pointer
this.trackedPointers_[event.pointerId]=event;}this.targetPointers=_ol_obj_.getValues(this.trackedPointers_);}};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */_ol_interaction_Pointer_.handleDragEvent=_ol_.nullFunction;/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */_ol_interaction_Pointer_.handleUpEvent=_ol_functions_.FALSE;/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */_ol_interaction_Pointer_.handleDownEvent=_ol_functions_.FALSE;/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */_ol_interaction_Pointer_.handleMoveEvent=_ol_.nullFunction;/**
 * Handles the {@link ol.MapBrowserEvent map browser event} and may call into
 * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
 * detected.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.Pointer}
 * @api
 */_ol_interaction_Pointer_.handleEvent=function(mapBrowserEvent){if(!(mapBrowserEvent instanceof _ol_MapBrowserPointerEvent_)){return true;}var stopEvent=false;this.updateTrackedPointers_(mapBrowserEvent);if(this.handlingDownUpSequence){if(mapBrowserEvent.type==_ol_MapBrowserEventType_.POINTERDRAG){this.handleDragEvent_(mapBrowserEvent);}else if(mapBrowserEvent.type==_ol_MapBrowserEventType_.POINTERUP){var handledUp=this.handleUpEvent_(mapBrowserEvent);this.handlingDownUpSequence=handledUp&&this.targetPointers.length>0;}}else{if(mapBrowserEvent.type==_ol_MapBrowserEventType_.POINTERDOWN){var handled=this.handleDownEvent_(mapBrowserEvent);this.handlingDownUpSequence=handled;stopEvent=this.shouldStopEvent(handled);}else if(mapBrowserEvent.type==_ol_MapBrowserEventType_.POINTERMOVE){this.handleMoveEvent_(mapBrowserEvent);}}return!stopEvent;};/**
 * This method is used to determine if "down" events should be propagated to
 * other interactions or should be stopped.
 *
 * The method receives the return code of the "handleDownEvent" function.
 *
 * By default this function is the "identity" function. It's overidden in
 * child classes.
 *
 * @param {boolean} handled Was the event handled by the interaction?
 * @return {boolean} Should the event be stopped?
 * @protected
 */_ol_interaction_Pointer_.prototype.shouldStopEvent=function(handled){return handled;};/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires ol.interaction.Draw.Event
 * @param {olx.interaction.DrawOptions} options Options.
 * @api
 */var _ol_interaction_Draw_=function(options){_ol_interaction_Pointer_.call(this,{handleDownEvent:_ol_interaction_Draw_.handleDownEvent_,handleEvent:_ol_interaction_Draw_.handleEvent,handleUpEvent:_ol_interaction_Draw_.handleUpEvent_});/**
   * @type {boolean}
   * @private
   */this.shouldHandle_=false;/**
   * @type {ol.Pixel}
   * @private
   */this.downPx_=null;/**
   * @type {boolean}
   * @private
   */this.freehand_=false;/**
   * Target source for drawn features.
   * @type {ol.source.Vector}
   * @private
   */this.source_=options.source?options.source:null;/**
   * Target collection for drawn features.
   * @type {ol.Collection.<ol.Feature>}
   * @private
   */this.features_=options.features?options.features:null;/**
   * Pixel distance for snapping.
   * @type {number}
   * @private
   */this.snapTolerance_=options.snapTolerance?options.snapTolerance:12;/**
   * Geometry type.
   * @type {ol.geom.GeometryType}
   * @private
   */this.type_=options.type;/**
   * Drawing mode (derived from geometry type.
   * @type {ol.interaction.Draw.Mode_}
   * @private
   */this.mode_=_ol_interaction_Draw_.getMode_(this.type_);/**
   * The number of points that must be drawn before a polygon ring or line
   * string can be finished.  The default is 3 for polygon rings and 2 for
   * line strings.
   * @type {number}
   * @private
   */this.minPoints_=options.minPoints?options.minPoints:this.mode_===_ol_interaction_Draw_.Mode_.POLYGON?3:2;/**
   * The number of points that can be drawn before a polygon ring or line string
   * is finished. The default is no restriction.
   * @type {number}
   * @private
   */this.maxPoints_=options.maxPoints?options.maxPoints:Infinity;/**
   * A function to decide if a potential finish coordinate is permissible
   * @private
   * @type {ol.EventsConditionType}
   */this.finishCondition_=options.finishCondition?options.finishCondition:_ol_functions_.TRUE;var geometryFunction=options.geometryFunction;if(!geometryFunction){if(this.type_===_ol_geom_GeometryType_.CIRCLE){/**
       * @param {!Array.<ol.Coordinate>} coordinates
       *     The coordinates.
       * @param {ol.geom.SimpleGeometry=} opt_geometry Optional geometry.
       * @return {ol.geom.SimpleGeometry} A geometry.
       */geometryFunction=function(coordinates,opt_geometry){var circle=opt_geometry?/** @type {ol.geom.Circle} */opt_geometry:new _ol_geom_Circle_([NaN,NaN]);var squaredLength=_ol_coordinate_.squaredDistance(coordinates[0],coordinates[1]);circle.setCenterAndRadius(coordinates[0],Math.sqrt(squaredLength));return circle;};}else{var Constructor;var mode=this.mode_;if(mode===_ol_interaction_Draw_.Mode_.POINT){Constructor=_ol_geom_Point_;}else if(mode===_ol_interaction_Draw_.Mode_.LINE_STRING){Constructor=_ol_geom_LineString_;}else if(mode===_ol_interaction_Draw_.Mode_.POLYGON){Constructor=_ol_geom_Polygon_;}/**
       * @param {!Array.<ol.Coordinate>} coordinates
       *     The coordinates.
       * @param {ol.geom.SimpleGeometry=} opt_geometry Optional geometry.
       * @return {ol.geom.SimpleGeometry} A geometry.
       */geometryFunction=function(coordinates,opt_geometry){var geometry=opt_geometry;if(geometry){if(mode===_ol_interaction_Draw_.Mode_.POLYGON){geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);}else{geometry.setCoordinates(coordinates);}}else{geometry=new Constructor(coordinates);}return geometry;};}}/**
   * @type {ol.DrawGeometryFunctionType}
   * @private
   */this.geometryFunction_=geometryFunction;/**
   * Finish coordinate for the feature (first point for polygons, last point for
   * linestrings).
   * @type {ol.Coordinate}
   * @private
   */this.finishCoordinate_=null;/**
   * Sketch feature.
   * @type {ol.Feature}
   * @private
   */this.sketchFeature_=null;/**
   * Sketch point.
   * @type {ol.Feature}
   * @private
   */this.sketchPoint_=null;/**
   * Sketch coordinates. Used when drawing a line or polygon.
   * @type {ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>}
   * @private
   */this.sketchCoords_=null;/**
   * Sketch line. Used when drawing polygon.
   * @type {ol.Feature}
   * @private
   */this.sketchLine_=null;/**
   * Sketch line coordinates. Used when drawing a polygon or circle.
   * @type {Array.<ol.Coordinate>}
   * @private
   */this.sketchLineCoords_=null;/**
   * Squared tolerance for handling up events.  If the squared distance
   * between a down and up event is greater than this tolerance, up events
   * will not be handled.
   * @type {number}
   * @private
   */this.squaredClickTolerance_=options.clickTolerance?options.clickTolerance*options.clickTolerance:36;/**
   * Draw overlay where our sketch features are drawn.
   * @type {ol.layer.Vector}
   * @private
   */this.overlay_=new _ol_layer_Vector_({source:new _ol_source_Vector_({useSpatialIndex:false,wrapX:options.wrapX?options.wrapX:false}),style:options.style?options.style:_ol_interaction_Draw_.getDefaultStyleFunction()});/**
   * Name of the geometry attribute for newly created features.
   * @type {string|undefined}
   * @private
   */this.geometryName_=options.geometryName;/**
   * @private
   * @type {ol.EventsConditionType}
   */this.condition_=options.condition?options.condition:_ol_events_condition_.noModifierKeys;/**
   * @private
   * @type {ol.EventsConditionType}
   */this.freehandCondition_;if(options.freehand){this.freehandCondition_=_ol_events_condition_.always;}else{this.freehandCondition_=options.freehandCondition?options.freehandCondition:_ol_events_condition_.shiftKeyOnly;}_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_interaction_Property_.ACTIVE),this.updateState_,this);};_ol_.inherits(_ol_interaction_Draw_,_ol_interaction_Pointer_);/**
 * @return {ol.StyleFunction} Styles.
 */_ol_interaction_Draw_.getDefaultStyleFunction=function(){var styles=_ol_style_Style_$1.createDefaultEditing();return function(feature,resolution){return styles[feature.getGeometry().getType()];};};/**
 * @inheritDoc
 */_ol_interaction_Draw_.prototype.setMap=function(map){_ol_interaction_Pointer_.prototype.setMap.call(this,map);this.updateState_();};/**
 * Handles the {@link ol.MapBrowserEvent map browser event} and may actually
 * draw or finish the drawing.
 * @param {ol.MapBrowserEvent} event Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.Draw}
 * @api
 */_ol_interaction_Draw_.handleEvent=function(event){this.freehand_=this.mode_!==_ol_interaction_Draw_.Mode_.POINT&&this.freehandCondition_(event);var pass=!this.freehand_;if(this.freehand_&&event.type===_ol_MapBrowserEventType_.POINTERDRAG&&this.sketchFeature_!==null){this.addToDrawing_(event);pass=false;}else if(event.type===_ol_MapBrowserEventType_.POINTERMOVE){pass=this.handlePointerMove_(event);}else if(event.type===_ol_MapBrowserEventType_.DBLCLICK){pass=false;}return _ol_interaction_Pointer_.handleEvent.call(this,event)&&pass;};/**
 * @param {ol.MapBrowserPointerEvent} event Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.Draw}
 * @private
 */_ol_interaction_Draw_.handleDownEvent_=function(event){this.shouldHandle_=!this.freehand_;if(this.freehand_){this.downPx_=event.pixel;if(!this.finishCoordinate_){this.startDrawing_(event);}return true;}else if(this.condition_(event)){this.downPx_=event.pixel;return true;}else{return false;}};/**
 * @param {ol.MapBrowserPointerEvent} event Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.Draw}
 * @private
 */_ol_interaction_Draw_.handleUpEvent_=function(event){var pass=true;this.handlePointerMove_(event);var circleMode=this.mode_===_ol_interaction_Draw_.Mode_.CIRCLE;if(this.shouldHandle_){if(!this.finishCoordinate_){this.startDrawing_(event);if(this.mode_===_ol_interaction_Draw_.Mode_.POINT){this.finishDrawing();}}else if(this.freehand_||circleMode){this.finishDrawing();}else if(this.atFinish_(event)){if(this.finishCondition_(event)){this.finishDrawing();}}else{this.addToDrawing_(event);}pass=false;}else if(this.freehand_){this.finishCoordinate_=null;this.abortDrawing_();}return pass;};/**
 * Handle move events.
 * @param {ol.MapBrowserEvent} event A move event.
 * @return {boolean} Pass the event to other interactions.
 * @private
 */_ol_interaction_Draw_.prototype.handlePointerMove_=function(event){if(this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){var downPx=this.downPx_;var clickPx=event.pixel;var dx=downPx[0]-clickPx[0];var dy=downPx[1]-clickPx[1];var squaredDistance=dx*dx+dy*dy;this.shouldHandle_=this.freehand_?squaredDistance>this.squaredClickTolerance_:squaredDistance<=this.squaredClickTolerance_;}if(this.finishCoordinate_){this.modifyDrawing_(event);}else{this.createOrUpdateSketchPoint_(event);}return true;};/**
 * Determine if an event is within the snapping tolerance of the start coord.
 * @param {ol.MapBrowserEvent} event Event.
 * @return {boolean} The event is within the snapping tolerance of the start.
 * @private
 */_ol_interaction_Draw_.prototype.atFinish_=function(event){var at=false;if(this.sketchFeature_){var potentiallyDone=false;var potentiallyFinishCoordinates=[this.finishCoordinate_];if(this.mode_===_ol_interaction_Draw_.Mode_.LINE_STRING){potentiallyDone=this.sketchCoords_.length>this.minPoints_;}else if(this.mode_===_ol_interaction_Draw_.Mode_.POLYGON){potentiallyDone=this.sketchCoords_[0].length>this.minPoints_;potentiallyFinishCoordinates=[this.sketchCoords_[0][0],this.sketchCoords_[0][this.sketchCoords_[0].length-2]];}if(potentiallyDone){var map=event.map;for(var i=0,ii=potentiallyFinishCoordinates.length;i<ii;i++){var finishCoordinate=potentiallyFinishCoordinates[i];var finishPixel=map.getPixelFromCoordinate(finishCoordinate);var pixel=event.pixel;var dx=pixel[0]-finishPixel[0];var dy=pixel[1]-finishPixel[1];var snapTolerance=this.freehand_?1:this.snapTolerance_;at=Math.sqrt(dx*dx+dy*dy)<=snapTolerance;if(at){this.finishCoordinate_=finishCoordinate;break;}}}}return at;};/**
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */_ol_interaction_Draw_.prototype.createOrUpdateSketchPoint_=function(event){var coordinates=event.coordinate.slice();if(!this.sketchPoint_){this.sketchPoint_=new _ol_Feature_(new _ol_geom_Point_(coordinates));this.updateSketchFeatures_();}else{var sketchPointGeom=/** @type {ol.geom.Point} */this.sketchPoint_.getGeometry();sketchPointGeom.setCoordinates(coordinates);}};/**
 * Start the drawing.
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */_ol_interaction_Draw_.prototype.startDrawing_=function(event){var start=event.coordinate;this.finishCoordinate_=start;if(this.mode_===_ol_interaction_Draw_.Mode_.POINT){this.sketchCoords_=start.slice();}else if(this.mode_===_ol_interaction_Draw_.Mode_.POLYGON){this.sketchCoords_=[[start.slice(),start.slice()]];this.sketchLineCoords_=this.sketchCoords_[0];}else{this.sketchCoords_=[start.slice(),start.slice()];if(this.mode_===_ol_interaction_Draw_.Mode_.CIRCLE){this.sketchLineCoords_=this.sketchCoords_;}}if(this.sketchLineCoords_){this.sketchLine_=new _ol_Feature_(new _ol_geom_LineString_(this.sketchLineCoords_));}var geometry=this.geometryFunction_(this.sketchCoords_);this.sketchFeature_=new _ol_Feature_();if(this.geometryName_){this.sketchFeature_.setGeometryName(this.geometryName_);}this.sketchFeature_.setGeometry(geometry);this.updateSketchFeatures_();this.dispatchEvent(new _ol_interaction_Draw_.Event(_ol_interaction_DrawEventType_.DRAWSTART,this.sketchFeature_));};/**
 * Modify the drawing.
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */_ol_interaction_Draw_.prototype.modifyDrawing_=function(event){var coordinate=event.coordinate;var geometry=/** @type {ol.geom.SimpleGeometry} */this.sketchFeature_.getGeometry();var coordinates,last;if(this.mode_===_ol_interaction_Draw_.Mode_.POINT){last=this.sketchCoords_;}else if(this.mode_===_ol_interaction_Draw_.Mode_.POLYGON){coordinates=this.sketchCoords_[0];last=coordinates[coordinates.length-1];if(this.atFinish_(event)){// snap to finish
coordinate=this.finishCoordinate_.slice();}}else{coordinates=this.sketchCoords_;last=coordinates[coordinates.length-1];}last[0]=coordinate[0];last[1]=coordinate[1];this.geometryFunction_(/** @type {!Array.<ol.Coordinate>} */this.sketchCoords_,geometry);if(this.sketchPoint_){var sketchPointGeom=/** @type {ol.geom.Point} */this.sketchPoint_.getGeometry();sketchPointGeom.setCoordinates(coordinate);}var sketchLineGeom;if(geometry instanceof _ol_geom_Polygon_&&this.mode_!==_ol_interaction_Draw_.Mode_.POLYGON){if(!this.sketchLine_){this.sketchLine_=new _ol_Feature_(new _ol_geom_LineString_(null));}var ring=geometry.getLinearRing(0);sketchLineGeom=/** @type {ol.geom.LineString} */this.sketchLine_.getGeometry();sketchLineGeom.setFlatCoordinates(ring.getLayout(),ring.getFlatCoordinates());}else if(this.sketchLineCoords_){sketchLineGeom=/** @type {ol.geom.LineString} */this.sketchLine_.getGeometry();sketchLineGeom.setCoordinates(this.sketchLineCoords_);}this.updateSketchFeatures_();};/**
 * Add a new coordinate to the drawing.
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */_ol_interaction_Draw_.prototype.addToDrawing_=function(event){var coordinate=event.coordinate;var geometry=/** @type {ol.geom.SimpleGeometry} */this.sketchFeature_.getGeometry();var done;var coordinates;if(this.mode_===_ol_interaction_Draw_.Mode_.LINE_STRING){this.finishCoordinate_=coordinate.slice();coordinates=this.sketchCoords_;if(coordinates.length>=this.maxPoints_){if(this.freehand_){coordinates.pop();}else{done=true;}}coordinates.push(coordinate.slice());this.geometryFunction_(coordinates,geometry);}else if(this.mode_===_ol_interaction_Draw_.Mode_.POLYGON){coordinates=this.sketchCoords_[0];if(coordinates.length>=this.maxPoints_){if(this.freehand_){coordinates.pop();}else{done=true;}}coordinates.push(coordinate.slice());if(done){this.finishCoordinate_=coordinates[0];}this.geometryFunction_(this.sketchCoords_,geometry);}this.updateSketchFeatures_();if(done){this.finishDrawing();}};/**
 * Remove last point of the feature currently being drawn.
 * @api
 */_ol_interaction_Draw_.prototype.removeLastPoint=function(){if(!this.sketchFeature_){return;}var geometry=/** @type {ol.geom.SimpleGeometry} */this.sketchFeature_.getGeometry();var coordinates,sketchLineGeom;if(this.mode_===_ol_interaction_Draw_.Mode_.LINE_STRING){coordinates=this.sketchCoords_;coordinates.splice(-2,1);this.geometryFunction_(coordinates,geometry);if(coordinates.length>=2){this.finishCoordinate_=coordinates[coordinates.length-2].slice();}}else if(this.mode_===_ol_interaction_Draw_.Mode_.POLYGON){coordinates=this.sketchCoords_[0];coordinates.splice(-2,1);sketchLineGeom=/** @type {ol.geom.LineString} */this.sketchLine_.getGeometry();sketchLineGeom.setCoordinates(coordinates);this.geometryFunction_(this.sketchCoords_,geometry);}if(coordinates.length===0){this.finishCoordinate_=null;}this.updateSketchFeatures_();};/**
 * Stop drawing and add the sketch feature to the target layer.
 * The {@link ol.interaction.DrawEventType.DRAWEND} event is dispatched before
 * inserting the feature.
 * @api
 */_ol_interaction_Draw_.prototype.finishDrawing=function(){var sketchFeature=this.abortDrawing_();var coordinates=this.sketchCoords_;var geometry=/** @type {ol.geom.SimpleGeometry} */sketchFeature.getGeometry();if(this.mode_===_ol_interaction_Draw_.Mode_.LINE_STRING){// remove the redundant last point
coordinates.pop();this.geometryFunction_(coordinates,geometry);}else if(this.mode_===_ol_interaction_Draw_.Mode_.POLYGON){// remove the redundant last point in ring
coordinates[0].pop();this.geometryFunction_(coordinates,geometry);coordinates=geometry.getCoordinates();}// cast multi-part geometries
if(this.type_===_ol_geom_GeometryType_.MULTI_POINT){sketchFeature.setGeometry(new _ol_geom_MultiPoint_([coordinates]));}else if(this.type_===_ol_geom_GeometryType_.MULTI_LINE_STRING){sketchFeature.setGeometry(new _ol_geom_MultiLineString_([coordinates]));}else if(this.type_===_ol_geom_GeometryType_.MULTI_POLYGON){sketchFeature.setGeometry(new _ol_geom_MultiPolygon_([coordinates]));}// First dispatch event to allow full set up of feature
this.dispatchEvent(new _ol_interaction_Draw_.Event(_ol_interaction_DrawEventType_.DRAWEND,sketchFeature));// Then insert feature
if(this.features_){this.features_.push(sketchFeature);}if(this.source_){this.source_.addFeature(sketchFeature);}};/**
 * Stop drawing without adding the sketch feature to the target layer.
 * @return {ol.Feature} The sketch feature (or null if none).
 * @private
 */_ol_interaction_Draw_.prototype.abortDrawing_=function(){this.finishCoordinate_=null;var sketchFeature=this.sketchFeature_;if(sketchFeature){this.sketchFeature_=null;this.sketchPoint_=null;this.sketchLine_=null;this.overlay_.getSource().clear(true);}return sketchFeature;};/**
 * Extend an existing geometry by adding additional points. This only works
 * on features with `LineString` geometries, where the interaction will
 * extend lines by adding points to the end of the coordinates array.
 * @param {!ol.Feature} feature Feature to be extended.
 * @api
 */_ol_interaction_Draw_.prototype.extend=function(feature){var geometry=feature.getGeometry();var lineString=/** @type {ol.geom.LineString} */geometry;this.sketchFeature_=feature;this.sketchCoords_=lineString.getCoordinates();var last=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=last.slice();this.sketchCoords_.push(last.slice());this.updateSketchFeatures_();this.dispatchEvent(new _ol_interaction_Draw_.Event(_ol_interaction_DrawEventType_.DRAWSTART,this.sketchFeature_));};/**
 * @inheritDoc
 */_ol_interaction_Draw_.prototype.shouldStopEvent=_ol_functions_.FALSE;/**
 * Redraw the sketch features.
 * @private
 */_ol_interaction_Draw_.prototype.updateSketchFeatures_=function(){var sketchFeatures=[];if(this.sketchFeature_){sketchFeatures.push(this.sketchFeature_);}if(this.sketchLine_){sketchFeatures.push(this.sketchLine_);}if(this.sketchPoint_){sketchFeatures.push(this.sketchPoint_);}var overlaySource=this.overlay_.getSource();overlaySource.clear(true);overlaySource.addFeatures(sketchFeatures);};/**
 * @private
 */_ol_interaction_Draw_.prototype.updateState_=function(){var map=this.getMap();var active=this.getActive();if(!map||!active){this.abortDrawing_();}this.overlay_.setMap(active?map:null);};/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of an
 * `ol.geom.Circle` geometry.
 * @param {number=} opt_sides Number of sides of the regular polygon. Default is
 *     32.
 * @param {number=} opt_angle Angle of the first point in radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {ol.DrawGeometryFunctionType} Function that draws a
 *     polygon.
 * @api
 */_ol_interaction_Draw_.createRegularPolygon=function(opt_sides,opt_angle){return(/**
         * @param {ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>} coordinates
         * @param {ol.geom.SimpleGeometry=} opt_geometry
         * @return {ol.geom.SimpleGeometry}
         */function(coordinates,opt_geometry){var center=coordinates[0];var end=coordinates[1];var radius=Math.sqrt(_ol_coordinate_.squaredDistance(center,end));var geometry=opt_geometry?/** @type {ol.geom.Polygon} */opt_geometry:_ol_geom_Polygon_.fromCircle(new _ol_geom_Circle_(center),opt_sides);var angle=opt_angle?opt_angle:Math.atan((end[1]-center[1])/(end[0]-center[0]));_ol_geom_Polygon_.makeRegular(geometry,center,radius,angle);return geometry;});};/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {ol.DrawGeometryFunctionType} Function that draws a box-shaped polygon.
 * @api
 */_ol_interaction_Draw_.createBox=function(){return(/**
     * @param {Array.<ol.Coordinate>} coordinates
     * @param {ol.geom.SimpleGeometry=} opt_geometry
     * @return {ol.geom.SimpleGeometry}
     */function(coordinates,opt_geometry){var extent=_ol_extent_.boundingExtent(coordinates);var geometry=opt_geometry||new _ol_geom_Polygon_(null);geometry.setCoordinates([[_ol_extent_.getBottomLeft(extent),_ol_extent_.getBottomRight(extent),_ol_extent_.getTopRight(extent),_ol_extent_.getTopLeft(extent),_ol_extent_.getBottomLeft(extent)]]);return geometry;});};/**
 * Get the drawing mode.  The mode for mult-part geometries is the same as for
 * their single-part cousins.
 * @param {ol.geom.GeometryType} type Geometry type.
 * @return {ol.interaction.Draw.Mode_} Drawing mode.
 * @private
 */_ol_interaction_Draw_.getMode_=function(type){var mode;if(type===_ol_geom_GeometryType_.POINT||type===_ol_geom_GeometryType_.MULTI_POINT){mode=_ol_interaction_Draw_.Mode_.POINT;}else if(type===_ol_geom_GeometryType_.LINE_STRING||type===_ol_geom_GeometryType_.MULTI_LINE_STRING){mode=_ol_interaction_Draw_.Mode_.LINE_STRING;}else if(type===_ol_geom_GeometryType_.POLYGON||type===_ol_geom_GeometryType_.MULTI_POLYGON){mode=_ol_interaction_Draw_.Mode_.POLYGON;}else if(type===_ol_geom_GeometryType_.CIRCLE){mode=_ol_interaction_Draw_.Mode_.CIRCLE;}return(/** @type {!ol.interaction.Draw.Mode_} */mode);};/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 * @private
 */_ol_interaction_Draw_.Mode_={POINT:'Point',LINE_STRING:'LineString',POLYGON:'Polygon',CIRCLE:'Circle'};/**
 * @classdesc
 * Events emitted by {@link ol.interaction.Draw} instances are instances of
 * this type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.DrawEvent}
 * @param {ol.interaction.DrawEventType} type Type.
 * @param {ol.Feature} feature The feature drawn.
 */_ol_interaction_Draw_.Event=function(type,feature){_ol_events_Event_.call(this,type);/**
   * The feature being drawn.
   * @type {ol.Feature}
   * @api
   */this.feature=feature;};_ol_.inherits(_ol_interaction_Draw_.Event,_ol_events_Event_);/**
 * @enum {string}
 */var _ol_MapEventType_={/**
   * Triggered after a map frame is rendered.
   * @event ol.MapEvent#postrender
   * @api
   */POSTRENDER:'postrender',/**
   * Triggered when the map starts moving.
   * @event ol.MapEvent#movestart
   * @api
   */MOVESTART:'movestart',/**
   * Triggered after the map is moved.
   * @event ol.MapEvent#moveend
   * @api
   */MOVEEND:'moveend'};/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */var _ol_OverlayPositioning_={BOTTOM_LEFT:'bottom-left',BOTTOM_CENTER:'bottom-center',BOTTOM_RIGHT:'bottom-right',CENTER_LEFT:'center-left',CENTER_CENTER:'center-center',CENTER_RIGHT:'center-right',TOP_LEFT:'top-left',TOP_CENTER:'top-center',TOP_RIGHT:'top-right'};var _ol_css_={};/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */_ol_css_.CLASS_HIDDEN='ol-hidden';/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */_ol_css_.CLASS_SELECTABLE='ol-selectable';/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */_ol_css_.CLASS_UNSELECTABLE='ol-unselectable';/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */_ol_css_.CLASS_UNSUPPORTED='ol-unsupported';/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */_ol_css_.CLASS_CONTROL='ol-control';/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link ol.control.Control}, Overlays are visible widgets.
 * Unlike Controls, they are not in a fixed position on the screen, but are tied
 * to a geographical coordinate, so panning the map will move an Overlay but not
 * a Control.
 *
 * Example:
 *
 *     var popup = new ol.Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.OverlayOptions} options Overlay options.
 * @api
 */var _ol_Overlay_=function(options){_ol_Object_.call(this);/**
   * @private
   * @type {number|string|undefined}
   */this.id_=options.id;/**
   * @private
   * @type {boolean}
   */this.insertFirst_=options.insertFirst!==undefined?options.insertFirst:true;/**
   * @private
   * @type {boolean}
   */this.stopEvent_=options.stopEvent!==undefined?options.stopEvent:true;/**
   * @private
   * @type {Element}
   */this.element_=document.createElement('DIV');this.element_.className='ol-overlay-container '+_ol_css_.CLASS_SELECTABLE;this.element_.style.position='absolute';/**
   * @protected
   * @type {boolean}
   */this.autoPan=options.autoPan!==undefined?options.autoPan:false;/**
   * @private
   * @type {olx.OverlayPanOptions}
   */this.autoPanAnimation_=options.autoPanAnimation||/** @type {olx.OverlayPanOptions} */{};/**
   * @private
   * @type {number}
   */this.autoPanMargin_=options.autoPanMargin!==undefined?options.autoPanMargin:20;/**
   * @private
   * @type {{bottom_: string,
   *         left_: string,
   *         right_: string,
   *         top_: string,
   *         visible: boolean}}
   */this.rendered_={bottom_:'',left_:'',right_:'',top_:'',visible:true};/**
   * @private
   * @type {?ol.EventsKey}
   */this.mapPostrenderListenerKey_=null;_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_Overlay_.Property_.ELEMENT),this.handleElementChanged,this);_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_Overlay_.Property_.MAP),this.handleMapChanged,this);_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_Overlay_.Property_.OFFSET),this.handleOffsetChanged,this);_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_Overlay_.Property_.POSITION),this.handlePositionChanged,this);_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_Overlay_.Property_.POSITIONING),this.handlePositioningChanged,this);if(options.element!==undefined){this.setElement(options.element);}this.setOffset(options.offset!==undefined?options.offset:[0,0]);this.setPositioning(options.positioning!==undefined?/** @type {ol.OverlayPositioning} */options.positioning:_ol_OverlayPositioning_.TOP_LEFT);if(options.position!==undefined){this.setPosition(options.position);}};_ol_.inherits(_ol_Overlay_,_ol_Object_);/**
 * Get the DOM element of this overlay.
 * @return {Element|undefined} The Element containing the overlay.
 * @observable
 * @api
 */_ol_Overlay_.prototype.getElement=function(){return(/** @type {Element|undefined} */this.get(_ol_Overlay_.Property_.ELEMENT));};/**
 * Get the overlay identifier which is set on constructor.
 * @return {number|string|undefined} Id.
 * @api
 */_ol_Overlay_.prototype.getId=function(){return this.id_;};/**
 * Get the map associated with this overlay.
 * @return {ol.Map|undefined} The map that the overlay is part of.
 * @observable
 * @api
 */_ol_Overlay_.prototype.getMap=function(){return(/** @type {ol.Map|undefined} */this.get(_ol_Overlay_.Property_.MAP));};/**
 * Get the offset of this overlay.
 * @return {Array.<number>} The offset.
 * @observable
 * @api
 */_ol_Overlay_.prototype.getOffset=function(){return(/** @type {Array.<number>} */this.get(_ol_Overlay_.Property_.OFFSET));};/**
 * Get the current position of this overlay.
 * @return {ol.Coordinate|undefined} The spatial point that the overlay is
 *     anchored at.
 * @observable
 * @api
 */_ol_Overlay_.prototype.getPosition=function(){return(/** @type {ol.Coordinate|undefined} */this.get(_ol_Overlay_.Property_.POSITION));};/**
 * Get the current positioning of this overlay.
 * @return {ol.OverlayPositioning} How the overlay is positioned
 *     relative to its point on the map.
 * @observable
 * @api
 */_ol_Overlay_.prototype.getPositioning=function(){return(/** @type {ol.OverlayPositioning} */this.get(_ol_Overlay_.Property_.POSITIONING));};/**
 * @protected
 */_ol_Overlay_.prototype.handleElementChanged=function(){_ol_dom_.removeChildren(this.element_);var element=this.getElement();if(element){this.element_.appendChild(element);}};/**
 * @protected
 */_ol_Overlay_.prototype.handleMapChanged=function(){if(this.mapPostrenderListenerKey_){_ol_dom_.removeNode(this.element_);_ol_events_.unlistenByKey(this.mapPostrenderListenerKey_);this.mapPostrenderListenerKey_=null;}var map=this.getMap();if(map){this.mapPostrenderListenerKey_=_ol_events_.listen(map,_ol_MapEventType_.POSTRENDER,this.render,this);this.updatePixelPosition();var container=this.stopEvent_?map.getOverlayContainerStopEvent():map.getOverlayContainer();if(this.insertFirst_){container.insertBefore(this.element_,container.childNodes[0]||null);}else{container.appendChild(this.element_);}}};/**
 * @protected
 */_ol_Overlay_.prototype.render=function(){this.updatePixelPosition();};/**
 * @protected
 */_ol_Overlay_.prototype.handleOffsetChanged=function(){this.updatePixelPosition();};/**
 * @protected
 */_ol_Overlay_.prototype.handlePositionChanged=function(){this.updatePixelPosition();if(this.get(_ol_Overlay_.Property_.POSITION)&&this.autoPan){this.panIntoView_();}};/**
 * @protected
 */_ol_Overlay_.prototype.handlePositioningChanged=function(){this.updatePixelPosition();};/**
 * Set the DOM element to be associated with this overlay.
 * @param {Element|undefined} element The Element containing the overlay.
 * @observable
 * @api
 */_ol_Overlay_.prototype.setElement=function(element){this.set(_ol_Overlay_.Property_.ELEMENT,element);};/**
 * Set the map to be associated with this overlay.
 * @param {ol.Map|undefined} map The map that the overlay is part of.
 * @observable
 * @api
 */_ol_Overlay_.prototype.setMap=function(map){this.set(_ol_Overlay_.Property_.MAP,map);};/**
 * Set the offset for this overlay.
 * @param {Array.<number>} offset Offset.
 * @observable
 * @api
 */_ol_Overlay_.prototype.setOffset=function(offset){this.set(_ol_Overlay_.Property_.OFFSET,offset);};/**
 * Set the position for this overlay. If the position is `undefined` the
 * overlay is hidden.
 * @param {ol.Coordinate|undefined} position The spatial point that the overlay
 *     is anchored at.
 * @observable
 * @api
 */_ol_Overlay_.prototype.setPosition=function(position){this.set(_ol_Overlay_.Property_.POSITION,position);};/**
 * Pan the map so that the overlay is entirely visible in the current viewport
 * (if necessary).
 * @private
 */_ol_Overlay_.prototype.panIntoView_=function(){var map=this.getMap();if(!map||!map.getTargetElement()){return;}var mapRect=this.getRect_(map.getTargetElement(),map.getSize());var element=/** @type {!Element} */this.getElement();var overlayRect=this.getRect_(element,[_ol_dom_.outerWidth(element),_ol_dom_.outerHeight(element)]);var margin=this.autoPanMargin_;if(!_ol_extent_.containsExtent(mapRect,overlayRect)){// the overlay is not completely inside the viewport, so pan the map
var offsetLeft=overlayRect[0]-mapRect[0];var offsetRight=mapRect[2]-overlayRect[2];var offsetTop=overlayRect[1]-mapRect[1];var offsetBottom=mapRect[3]-overlayRect[3];var delta=[0,0];if(offsetLeft<0){// move map to the left
delta[0]=offsetLeft-margin;}else if(offsetRight<0){// move map to the right
delta[0]=Math.abs(offsetRight)+margin;}if(offsetTop<0){// move map up
delta[1]=offsetTop-margin;}else if(offsetBottom<0){// move map down
delta[1]=Math.abs(offsetBottom)+margin;}if(delta[0]!==0||delta[1]!==0){var center=/** @type {ol.Coordinate} */map.getView().getCenter();var centerPx=map.getPixelFromCoordinate(center);var newCenterPx=[centerPx[0]+delta[0],centerPx[1]+delta[1]];map.getView().animate({center:map.getCoordinateFromPixel(newCenterPx),duration:this.autoPanAnimation_.duration,easing:this.autoPanAnimation_.easing});}}};/**
 * Get the extent of an element relative to the document
 * @param {Element|undefined} element The element.
 * @param {ol.Size|undefined} size The size of the element.
 * @return {ol.Extent} The extent.
 * @private
 */_ol_Overlay_.prototype.getRect_=function(element,size){var box=element.getBoundingClientRect();var offsetX=box.left+window.pageXOffset;var offsetY=box.top+window.pageYOffset;return[offsetX,offsetY,offsetX+size[0],offsetY+size[1]];};/**
 * Set the positioning for this overlay.
 * @param {ol.OverlayPositioning} positioning how the overlay is
 *     positioned relative to its point on the map.
 * @observable
 * @api
 */_ol_Overlay_.prototype.setPositioning=function(positioning){this.set(_ol_Overlay_.Property_.POSITIONING,positioning);};/**
 * Modify the visibility of the element.
 * @param {boolean} visible Element visibility.
 * @protected
 */_ol_Overlay_.prototype.setVisible=function(visible){if(this.rendered_.visible!==visible){this.element_.style.display=visible?'':'none';this.rendered_.visible=visible;}};/**
 * Update pixel position.
 * @protected
 */_ol_Overlay_.prototype.updatePixelPosition=function(){var map=this.getMap();var position=this.getPosition();if(!map||!map.isRendered()||!position){this.setVisible(false);return;}var pixel=map.getPixelFromCoordinate(position);var mapSize=map.getSize();this.updateRenderedPosition(pixel,mapSize);};/**
 * @param {ol.Pixel} pixel The pixel location.
 * @param {ol.Size|undefined} mapSize The map size.
 * @protected
 */_ol_Overlay_.prototype.updateRenderedPosition=function(pixel,mapSize){var style=this.element_.style;var offset=this.getOffset();var positioning=this.getPositioning();this.setVisible(true);var offsetX=offset[0];var offsetY=offset[1];if(positioning==_ol_OverlayPositioning_.BOTTOM_RIGHT||positioning==_ol_OverlayPositioning_.CENTER_RIGHT||positioning==_ol_OverlayPositioning_.TOP_RIGHT){if(this.rendered_.left_!==''){this.rendered_.left_=style.left='';}var right=mapSize[0]-pixel[0]-offsetX+'px';if(this.rendered_.right_!=right){this.rendered_.right_=style.right=right;}}else{if(this.rendered_.right_!==''){this.rendered_.right_=style.right='';}if(positioning==_ol_OverlayPositioning_.BOTTOM_CENTER||positioning==_ol_OverlayPositioning_.CENTER_CENTER||positioning==_ol_OverlayPositioning_.TOP_CENTER){offsetX-=this.element_.offsetWidth/2;}var left=pixel[0]+offsetX+'px';if(this.rendered_.left_!=left){this.rendered_.left_=style.left=left;}}if(positioning==_ol_OverlayPositioning_.BOTTOM_LEFT||positioning==_ol_OverlayPositioning_.BOTTOM_CENTER||positioning==_ol_OverlayPositioning_.BOTTOM_RIGHT){if(this.rendered_.top_!==''){this.rendered_.top_=style.top='';}var bottom=mapSize[1]-pixel[1]-offsetY+'px';if(this.rendered_.bottom_!=bottom){this.rendered_.bottom_=style.bottom=bottom;}}else{if(this.rendered_.bottom_!==''){this.rendered_.bottom_=style.bottom='';}if(positioning==_ol_OverlayPositioning_.CENTER_LEFT||positioning==_ol_OverlayPositioning_.CENTER_CENTER||positioning==_ol_OverlayPositioning_.CENTER_RIGHT){offsetY-=this.element_.offsetHeight/2;}var top=pixel[1]+offsetY+'px';if(this.rendered_.top_!=top){this.rendered_.top_=style.top=top;}}};/**
 * @enum {string}
 * @private
 */_ol_Overlay_.Property_={ELEMENT:'element',MAP:'map',OFFSET:'offset',POSITION:'position',POSITIONING:'positioning'};function MeasureControl(InteractiveMap){var self=this;this.InteractiveMap=InteractiveMap;this.map=InteractiveMap.map;this.info=InteractiveMap.infoControl;this.source=new _ol_source_Vector_({defaultDataProjection:'pixel'});this.layer=new _ol_layer_Vector_({source:this.source});/**
     * Currently drawn feature.
     * @type {ol.Feature}
     */var sketch;/**
     * The help tooltip element.
     * @type {Element}
     */var helpTooltipElement;/**
     * Overlay to show the help messages.
     * @type {ol.Overlay}
     */var helpTooltip;/**
     * The measure tooltip element.
     * @type {Element}
     */var measureTooltipElement;/**
     * Overlay to show the measurement.
     * @type {ol.Overlay}
     */var measureTooltip;/**
     * Message to show when the user is drawing a polygon.
     * @type {string}
     */var continuePolygonMsg='Click to continue drawing the polygon';/**
     * Message to show when the user is drawing a line.
     * @type {string}
     */var continueLineMsg='Click to continue drawing the line';/**
     * Handle pointer move.
     * @param {ol.MapBrowserEvent} evt The event.
     */var pointerMoveHandler=function(evt){if(evt.dragging){return;}/** @type {string} */var helpMsg='Click to start drawing';if(sketch){var geom=sketch.getGeometry();if(geom instanceof _ol_geom_Polygon_){helpMsg=continuePolygonMsg;}else if(geom instanceof _ol_geom_LineString_){helpMsg=continueLineMsg;}}helpTooltipElement.innerHTML=helpMsg;helpTooltip.setPosition(evt.coordinate);helpTooltipElement.classList.remove('hidden');};var pointerMoveListener;var mouseOutHandler=function(){helpTooltipElement.classList.add('hidden');};this.type='line';var draw;// global so we can remove it later
/**
     * Format length output.
     * @param {ol.geom.LineString} line The line.
     * @return {string} The formatted length.
     */var formatLength=function(line){var length=Math.round(line.getLength());var output;output='Distance: '+length+' '+'units<br>Travel Time: '+(length/self.InteractiveMap.movementSpeed).toFixed(2)+'s at '+self.InteractiveMap.movementSpeed+'ms';return output;};var formatRadius=function(circle){var length=Math.round(circle.getRadius());var output;output='Radius: '+length+' '+'units<br>Area: '+(Math.PI*length*length).toFixed(2)+' units<sup>2</sup>';return output;};/**
     * Format area output.
     * @param {ol.geom.Polygon} polygon The polygon.
     * @return {string} Formatted area.
     */var formatArea=function(polygon){var area=polygon.getArea();var output;if(area>10000){output=Math.round(area/1000000*100)/100+' '+'km<sup>2</sup>';}else{output=Math.round(area*100)/100+' '+'m<sup>2</sup>';}return output;};var self=this;function addInteraction(){var type=self.type=='circle'?'Circle':'LineString';draw=new _ol_interaction_Draw_({source:self.source,type:/** @type {ol.geom.GeometryType} */type,style:styles.measure});self.map.addInteraction(draw);//createMeasureTooltip();
createHelpTooltip();var listener;draw.on('drawstart',function(evt){self.source.clear(true);self.info.setContent("");self.info.close(true);// set sketch
sketch=evt.feature;/** @type {ol.Coordinate|undefined} */var tooltipCoord=evt.coordinate;listener=sketch.getGeometry().on('change',function(evt){var geom=evt.target;var output;if(geom instanceof _ol_geom_Circle_){output=formatRadius(geom);tooltipCoord=geom.getLastCoordinate();}else if(geom instanceof _ol_geom_LineString_){output=formatLength(geom);tooltipCoord=geom.getLastCoordinate();}self.info.setContent(output);self.info.open(true);//measureTooltipElement.innerHTML = output;
//measureTooltip.setPosition(tooltipCoord);
});},self);draw.on('drawend',function(){//measureTooltipElement.className = 'tooltip tooltip-static';
//measureTooltip.setOffset([0, -7]);
// unset sketch
sketch=null;// unset tooltip so that a new one can be created
//measureTooltipElement = null;
//createMeasureTooltip();
_ol_Observable_.unByKey(listener);},self);}/**
     * Creates a new help tooltip
     */function createHelpTooltip(){if(helpTooltipElement){helpTooltipElement.parentNode.removeChild(helpTooltipElement);}helpTooltipElement=document.createElement('div');helpTooltipElement.className='tooltip hidden';helpTooltip=new _ol_Overlay_({element:helpTooltipElement,offset:[15,0],positioning:'center-left'});self.map.addOverlay(helpTooltip);}/**
     * Creates a new measure tooltip
     */this.change=function(type){self.type=type;_ol_Observable_.unByKey(pointerMoveListener);self.map.getViewport().removeEventListener('mouseout',mouseOutHandler);self.map.removeInteraction(draw);self.source.clear(true);addInteraction.call(this);this.active=true;};this.active=false;this.activate=function(){if(!this.active){pointerMoveListener=self.map.on('pointermove',pointerMoveHandler);self.map.getViewport().addEventListener('mouseout',mouseOutHandler);addInteraction();}this.active=true;};this.deactivate=function(){_ol_Observable_.unByKey(pointerMoveListener);self.map.getViewport().removeEventListener('mouseout',mouseOutHandler);self.map.removeInteraction(draw);self.source.clear(true);this.active=false;};}function CreepControl(InteractiveMap){this.InteractiveMap=InteractiveMap;this.postComposeListener=null;this.postComposeHandler=this.animateCreeps.bind(this);this.playbackSpeed=1;this.paused=true;this.pauseTime=null;this.title='Lane Animation';}CreepControl.prototype.show=function(message){this.setContent(message);this.info.classList.remove('slideUp');this.info.classList.add('slideDown');};CreepControl.prototype.setContent=function(html){this.infoContent.innerHTML=html;};CreepControl.prototype.open=function(){this.info.classList.add('slideDown');this.info.classList.remove('slideUp');};CreepControl.prototype.close=function(){this.info.classList.add('slideUp');this.info.classList.remove('slideDown');};CreepControl.prototype.initialize=function(id){var self=this;this.id=id;this.info=document.getElementById(id);this.infoContent=document.querySelector('#timer-time');this.playPauseBtn=document.querySelector('#timer-playPause');this.playPauseHandler=function(evt){self.playPause.call(self,true);};this.playPauseBtn.addEventListener('click',this.playPauseHandler,false);this.stopBtn=document.querySelector('#timer-stop');this.stopHandler=function(evt){self.stop.call(self,true);};this.stopBtn.addEventListener('click',this.stopHandler,false);this.fasterBtn=document.querySelector('#timer-faster');this.fasterHandler=function(evt){self.faster.call(self,true);};this.fasterBtn.addEventListener('click',this.fasterHandler,false);this.slowerBtn=document.querySelector('#timer-slower');this.slowerHandler=function(evt){self.slower.call(self,true);};this.slowerBtn.addEventListener('click',this.slowerHandler,false);};CreepControl.prototype.slower=function(){var oldVal=this.playbackSpeed;this.playbackSpeed=Math.max(1,this.playbackSpeed-1);this.updatePlayback(oldVal,this.playbackSpeed);};CreepControl.prototype.faster=function(){var oldVal=this.playbackSpeed;this.playbackSpeed+=1;this.updatePlayback(oldVal,this.playbackSpeed);};CreepControl.prototype.updatePlayback=function(oldVal,newVal){var features=this.InteractiveMap.getMapLayerIndex()['npc_dota_spawner'].getSource().getFeatures();var elapsedTime=this.currentTime-this.startTime;var adjustedElapsedTime=elapsedTime*oldVal/newVal;this.startTime=this.currentTime-adjustedElapsedTime;for(var i=0;i<features.length;i++){var feature=features[i];var waveTimes=feature.get('waveTimes');if(waveTimes){var j=waveTimes.length;while(j--){var elapsedTime=this.currentTime-waveTimes[j];var adjustedElapsedTime=elapsedTime*oldVal/newVal;waveTimes[j]=this.currentTime-adjustedElapsedTime;}}}};CreepControl.prototype.start=function(){if(!this.postComposeListener){this.postComposeListener=this.InteractiveMap.map.on('postcompose',this.postComposeHandler);}if(this.paused)this.playPause();this.InteractiveMap.map.render();};CreepControl.prototype.stop=function(){_ol_Observable_.unByKey(this.postComposeListener);this.postComposeListener=null;var features=this.InteractiveMap.getMapLayerIndex()['npc_dota_spawner'].getSource().getFeatures();for(var i=0;i<features.length;i++){var feature=features[i];feature.set('waveTimes',null,true);}this.startTime=null;if(!this.paused)this.playPause();this.pauseTime=null;this.InteractiveMap.map.render();this.setContent(this.title);};CreepControl.prototype.playPause=function(){this.paused=!this.paused;if(this.paused){this.playPauseBtn.classList.add('icon-play');this.playPauseBtn.classList.remove('icon-pause');}else{this.playPauseBtn.classList.add('icon-pause');this.playPauseBtn.classList.remove('icon-play');this.start();}};CreepControl.prototype.activate=function(){this.InteractiveMap.toggleLayerMenuOption('npc_dota_spawner',true);this.InteractiveMap.toggleLayerMenuOption('path_corner',true);this.show(this.title);};CreepControl.prototype.deactivate=function(){this.InteractiveMap.toggleLayerMenuOption('npc_dota_spawner',false);this.InteractiveMap.toggleLayerMenuOption('path_corner',false);this.stop();this.close();};function getDistance(speed,elapsedTime){return speed*elapsedTime/1000*mapConstants.scale;}function getElapsedDistance(id,elapsedTime,playbackSpeed,bNoAdjust){elapsedTime=elapsedTime*playbackSpeed;var base=mapConstants.creepBaseMovementSpeed;if(bNoAdjust)return getDistance(base,elapsedTime);switch(id){case'npc_dota_spawner_good_bot':if(elapsedTime<10000){return getDistance(base*1.25,elapsedTime);}else{return getDistance(base*1.25,10000)+getDistance(base,elapsedTime-10000);}break;case'npc_dota_spawner_bad_top':if(elapsedTime<2000){return getDistance(base*1.25,elapsedTime);}else{return getDistance(base*1.25,2000)+getDistance(base,elapsedTime-2000);}break;case'npc_dota_spawner_good_top':if(elapsedTime<2000){return getDistance(base*0.75,elapsedTime);}else{return getDistance(base*0.75,2000)+getDistance(base,elapsedTime-2000);}break;case'npc_dota_spawner_bad_bot':if(elapsedTime<22000){return getDistance(base*0.75,elapsedTime);}else{return getDistance(base*0.75,22000)+getDistance(base,elapsedTime-22000);}break;default:return getDistance(base,elapsedTime);break;}}CreepControl.prototype.animateCreeps=function(event){var vectorContext=event.vectorContext;var frameState=event.frameState;this.currentTime=frameState.time;var features=this.InteractiveMap.getMapLayerIndex()['npc_dota_spawner'].getSource().getFeatures();var pathLayer=this.InteractiveMap.getMapLayerIndex()['path_corner'];if(!this.startTime)this.startTime=this.currentTime;if(this.paused){if(this.pauseTime==null)this.pauseTime=frameState.time;this.currentTime=this.pauseTime;}else{if(this.pauseTime!=null){for(var i=0;i<features.length;i++){var feature=features[i];var waveTimes=feature.get('waveTimes');if(waveTimes){var j=waveTimes.length;while(j--){waveTimes[j]+=this.currentTime-this.pauseTime;}}}this.startTime+=this.currentTime-this.pauseTime;this.pauseTime=null;}}for(var i=0;i<features.length;i++){var feature=features[i];var id=feature.getId();var pathFeature=pathLayer.getSource().getFeatureById(id);var waveTimes=feature.get('waveTimes');if(!waveTimes){waveTimes=[this.currentTime];feature.set('waveTimes',waveTimes,true);}if(this.currentTime-waveTimes[waveTimes.length-1]>=30000/this.playbackSpeed){waveTimes.push(this.currentTime);}var j=waveTimes.length;while(j--){var path=feature.get('path');if(!path){var path=pathFeature.getGeometry().clone();var coords=path.getCoordinates();coords[0]=feature.getGeometry().getCoordinates();path.setCoordinates(coords);feature.set('path',path,true);}var pathLength=path.getLength();var coords=path.getCoordinates();var elapsedTime=this.currentTime-waveTimes[j];var elapsedDistance=getElapsedDistance(id,elapsedTime,this.playbackSpeed);var elapsedFraction=Math.max(0,elapsedDistance/pathLength);if(elapsedFraction>=1){var endPoint=coords[coords.length-1];waveTimes.splice(j,1);}else{var endPoint=path.getCoordinateAt(elapsedFraction);}var point=new _ol_geom_Circle_(endPoint);vectorContext.setStyle(styles.creepColor(feature));vectorContext.drawCircle(point);}}var timeText=((this.currentTime-this.startTime)%(60000/this.playbackSpeed)/1000*this.playbackSpeed).toFixed(1)+'s';if(this.playbackSpeed>1)timeText+=', '+this.playbackSpeed+'x';this.setContent(timeText);frameState.animate=true;};var VisionSimulation$1=require("dota-vision-simulation");var key2pt=VisionSimulation$1.prototype.key2pt;var xy2pt=VisionSimulation$1.prototype.xy2pt;function processNeighbors(grid,lights,components,key,index){var pt=key2pt(key);var dirs=[[1,0],[0,-1],[-1,0],[0,1]];for(var i=0;i<dirs.length;i++){var aX=pt.x+dirs[i][0];var aY=pt.y+dirs[i][1];if(!grid[aX]||!grid[aX][aY])continue;var keyAdj=grid[aX][aY].key;if(components[keyAdj]||!lights[keyAdj])continue;components[keyAdj]=index;processNeighbors(grid,lights,components,keyAdj,index);}}function getLightUnion(grid,lights){var components={};var index=1;for(var key in lights){if(!components[key]){components[key]=index;processNeighbors(grid,lights,components,key,index);index++;}}var outlines=[];for(var i=1;i<index;i++){outlines.push(getOutline(grid,components,i));}return outlines;}function isSideFree(grid,components,pt,dir){var aX=pt.x+dir[0];var aY=pt.y+dir[1];if(!grid[aX]||!grid[aX][aY])return true;var keyAdj=grid[aX][aY].key;return!components[keyAdj];}function notSurrounded(grid,components,pt){for(var i=0;i<8;i+=2){var aX=pt.x+Math.round(Math.cos(2*Math.PI-Math.PI/4*i));var aY=pt.y+Math.round(Math.sin(2*Math.PI-Math.PI/4*i));if(!grid[aX]||!grid[aX][aY])return i;var keyAdj=grid[aX][aY].key;if(!components[keyAdj])return i;}return null;}function mod(n,m){return(n%m+m)%m;}function getOutline(grid,components,index){var outlinePoints=[];var startKey;var dir=null;for(var key in components){var pt=key2pt(key);dir=notSurrounded(grid,components,pt);if(components[key]==index&&dir!==null){startKey=key;break;}}var next=processNext(grid,components,startKey,dir);while(startKey!==next.key||dir!==next.dir){outlinePoints.push(next.point);next=processNext(grid,components,next.key,next.dir);}outlinePoints.push(next.point);return outlinePoints;}function checkAdj(grid,components,pt,key,dir,i,adjDir){var aX=pt.x+dir[0];var aY=pt.y+dir[1];if(!grid[aX]||!grid[aX][aY])return;var ptAdj=grid[pt.x+dir[0]][pt.y+dir[1]];if(components[ptAdj.key]==components[key]&&isSideFree(grid,components,ptAdj,adjDir)){return{key:ptAdj.key,dir:i};}}function processNext(grid,components,key,i){var pt=key2pt(key);var next;var x=Math.round(Math.cos(2*Math.PI-Math.PI/4*i));var y=Math.round(Math.sin(2*Math.PI-Math.PI/4*i));var nI=mod(i+2,8);var nX=Math.round(Math.cos(2*Math.PI-Math.PI/4*nI));var nY=Math.round(Math.sin(2*Math.PI-Math.PI/4*nI));var bI=mod(i-1,8);var bX=Math.round(Math.cos(2*Math.PI-Math.PI/4*bI));var bY=Math.round(Math.sin(2*Math.PI-Math.PI/4*bI));if(isSideFree(grid,components,pt,[nX,nY])){return{key:key,dir:mod(i+2,8),point:xy2pt(pt.x+bX/2,pt.y+bY/2)};}if(!next)next=checkAdj(grid,components,pt,key,[nX,nY],i,[x,y]);if(!next){var aI=mod(i+1,8);var aX=Math.round(Math.cos(2*Math.PI-Math.PI/4*aI));var aY=Math.round(Math.sin(2*Math.PI-Math.PI/4*aI));var pI=mod(i-2,8);var pX=Math.round(Math.cos(2*Math.PI-Math.PI/4*pI));var pY=Math.round(Math.sin(2*Math.PI-Math.PI/4*pI));next=checkAdj(grid,components,pt,key,[aX,aY],pI,[pX,pY]);}if(next){next.point=xy2pt(pt.x+bX/2,pt.y+bY/2);return next;}else{console.log('error');}}function VisionControl(InteractiveMap){var self=this;this.InteractiveMap=InteractiveMap;this.source=new _ol_source_Vector_({defaultDataProjection:'pixel'});this.layer=new _ol_layer_Vector_({source:this.source,style:styles.visionSimulation});}VisionControl.prototype.getVisionFeature=function(feature,coordinate,radius){var vs=this.InteractiveMap.vs;// get coordinate from feature if not provided
var worldCoordinate;if(!coordinate){var dotaProps=feature.get('dotaProps');worldCoordinate=[dotaProps.x,dotaProps.y];}else{worldCoordinate=latLonToWorld(coordinate);}// get radius from feature if not provided
radius=radius||this.InteractiveMap.getFeatureVisionRadius(feature,dotaProps);if(radius==null)return;var gridXY=vs.WorldXYtoGridXY(worldCoordinate[0],worldCoordinate[1]);if(vs.isValidXY(gridXY.x,gridXY.y,true,true,true)){vs.updateVisibility(gridXY.x,gridXY.y,getTileRadius(radius));var outlines=getLightUnion(vs.grid,vs.lights).map(function(ring){return ring.map(function(point){var worldXY=vs.GridXYtoWorldXY(point.x,point.y);return worldToLatLon([worldXY.x,worldXY.y]);});});var multiPolygon=new _ol_geom_MultiPolygon_([outlines],'XY');var feature=new _ol_Feature_({geometry:multiPolygon});feature.set('visionData',{area:vs.area,lightArea:vs.lightArea},false);return feature;}};VisionControl.prototype.toggleVisionFeature=function(feature){var visionFeature=feature.get('visionFeature');if(visionFeature){this.source.removeFeature(visionFeature);feature.set('visionFeature',null);return null;}else{return this.setVisionFeature(feature);}};VisionControl.prototype.removeVisionFeature=function(feature){var visionFeature=feature.get('visionFeature');if(visionFeature){this.source.removeFeature(visionFeature);feature.set('visionFeature',null);}};VisionControl.prototype.setVisionFeature=function(feature,coordinate,unitClass){// remove existing visionFeature for feature
this.removeVisionFeature(feature);// determine radius according to unit type
var radius=this.InteractiveMap.getFeatureVisionRadius(feature,feature.get('dotaProps'),unitClass);// create and add vision feature
var visionFeature=this.getVisionFeature(feature,coordinate,radius);if(visionFeature){this.source.addFeature(visionFeature);}feature.set('visionFeature',visionFeature,true);return visionFeature;};function WardControl(InteractiveMap,throttleTime){var self=this;this.InteractiveMap=InteractiveMap;this.source=new _ol_source_Vector_({defaultDataProjection:'pixel'});this.layer=new _ol_layer_Vector_({source:this.source});this.layerFilter=function(layer){return layer===self.layer;};this.placedWardCoordinates={observer:{},sentry:{}};this.lastPointerMoveTime=Date.now();this.pointerMoveHandler=function(evt){if(evt.dragging){return;}var pixel=self.InteractiveMap.map.getEventPixel(evt.originalEvent);// if mouse over a building feature, show info and highlight
var bBuildingHover=false;var feature=self.InteractiveMap.map.forEachFeatureAtPixel(pixel,function(feature){return feature;},{layerFilter:self.InteractiveMap.layerFilters.marker});if(feature){bBuildingHover=self.highlight(feature);if(bBuildingHover){self.showVisibilityInfo();}}else{// if mouse over a ward feature, highlight
var feature=InteractiveMap.checkAndHighlightWard(pixel);// no highlighted feature so unhighlight current feature
if(!feature){self.unhighlight();}else{self.showVisibilityInfo();}}// vision cursor
if(Date.now()-self.lastPointerMoveTime<throttleTime){return;}self.lastPointerMoveTime=Date.now();if(bBuildingHover){if(!feature.get('visionFeature')){var hoverFeature=self.InteractiveMap.visionControl.getVisionFeature(feature);}else{self.InteractiveMap.cursorControl.source.clear(true);}}else{var hoverFeature=self.InteractiveMap.visionControl.getVisionFeature(null,evt.coordinate,self.InteractiveMap.visionRadius);}if(hoverFeature){self.InteractiveMap.cursorControl.source.clear(true);self.InteractiveMap.cursorControl.source.addFeature(hoverFeature);if(!bBuildingHover){self.showVisibilityInfo();}}else if(!bBuildingHover){self.clearInfo();}};this.pointerMoveListener=null;this.clickHandler=function(evt){self.unhighlight();var feature=self.InteractiveMap.map.forEachFeatureAtPixel(evt.pixel,function(feature,layer){return feature;},{layerFilter:self.InteractiveMap.layerFilters.marker});if(feature&&self.InteractiveMap.hasVisionRadius(feature)){self.InteractiveMap.toggle(feature);if(self.InteractiveMap.visionControl.toggleVisionFeature(feature)){self.showVisibilityInfo();}else{self.clearInfo();}self.InteractiveMap.cursorControl.source.clear(true);}else{feature=self.InteractiveMap.map.forEachFeatureAtPixel(evt.pixel,function(feature,layer){return feature;},{layerFilter:self.layerFilter});if(feature){self.removeWard(feature);self.clearInfo(true);}else{self.addWard(evt.coordinate,self.InteractiveMap.MODE);self.InteractiveMap.cursorControl.source.clear(true);}}};this.clickListener=null;}WardControl.prototype.toggleAll=function(layer,state){if(state){this.showAll(layer);}else{this.hideAll(layer);}};WardControl.prototype.showAll=function(layer){var self=this;var source=layer.getSource();var features=source.getFeatures();features.forEach(function(feature){self.InteractiveMap.select(feature);self.highlight(feature);});};WardControl.prototype.hideAll=function(layer){var self=this;var source=layer.getSource();var features=source.getFeatures();features.forEach(function(feature){self.InteractiveMap.deselect(feature);self.unhighlight(feature);});};WardControl.prototype.showVisibilityInfo=function(visionFeature,bClicked){var info=this.InteractiveMap.infoControl;var vs=this.InteractiveMap.vs;var lightArea=vs.lightArea;var area=vs.area;if(visionFeature){var visionData=visionFeature.get('visionData');if(visionData){lightArea=visionData.lightArea;area=visionData.area;info.setContent("Visibility: "+(lightArea/area*100).toFixed()+'% '+lightArea+"/"+area);info.open(bClicked);}}else{info.setContent("Visibility: "+(lightArea/area*100).toFixed()+'% '+lightArea+"/"+area);info.open(bClicked);}};WardControl.prototype.clearInfo=function(bOverrideActive){this.InteractiveMap.infoControl.setContent("");this.InteractiveMap.infoControl.close(bOverrideActive);};WardControl.prototype.activate=function(){if(!this.pointerMoveListener){this.pointerMoveListener=this.InteractiveMap.map.on('pointermove',this.pointerMoveHandler);}if(!this.clickListener){this.clickListener=this.InteractiveMap.map.on('click',this.clickHandler);}};WardControl.prototype.deactivate=function(){this.InteractiveMap.unhighlightWard();this.InteractiveMap.cursorControl.source.clear(true);_ol_Observable_.unByKey(this.pointerMoveListener);this.pointerMoveListener=null;_ol_Observable_.unByKey(this.clickListener);this.clickListener=null;};WardControl.prototype.parseQueryString=function(){var self=this;['observer','sentry'].forEach(function(wardType){var values=getParameterByName(wardType);if(values){values=values.split(';');values.forEach(function(worldXY){worldXY=worldXY.split(',');if(worldXY.length==2){worldXY=worldXY.map(parseFloat);if(!worldXY.some(isNaN)){var coordinate=worldToLatLon(worldXY);self.addWard(coordinate,wardType,true);}}});}self.updateQueryString(wardType);});};WardControl.prototype.updateQueryString=function(wardType){var values=Object.keys(this.placedWardCoordinates[wardType]).join(';');setQueryString(wardType,values||null);};WardControl.prototype.addWard=function(coordinate,wardType,bSkipQueryStringUpdate){if(coordinate[0]<0||coordinate[0]>mapConstants.map_w||coordinate[1]<0||coordinate[1]>mapConstants.map_h)return;var geom=new _ol_geom_Point_(coordinate);var feature=new _ol_Feature_(geom);feature.set('wardType',wardType,true);feature.setStyle(styles[wardType].normal);this.source.addFeature(feature);if(wardType=='observer'){if(this.InteractiveMap.visionControl.setVisionFeature(feature,coordinate,wardType)){this.showVisibilityInfo();}}var circle=this.InteractiveMap.getRangeCircle(feature,coordinate,wardType);if(circle){circle.setStyle(wardType=='observer'?styles.dayVision:styles.trueSight);feature.set('wardRange',circle,true);this.InteractiveMap.wardRangeSource.addFeature(circle);}var worldXY=latLonToWorld(coordinate).map(Math.round).join(',');this.placedWardCoordinates[wardType][worldXY]=true;if(!bSkipQueryStringUpdate)this.updateQueryString(wardType);};WardControl.prototype.clearWards=function(){var self=this;var features=this.source.getFeatures();features.forEach(function(feature){self.removeWard(feature,true);});};WardControl.prototype.removeWard=function(feature,bSkipQueryStringUpdate){var wardRange=feature.get('wardRange');if(wardRange){this.InteractiveMap.wardRangeSource.removeFeature(wardRange);}this.source.removeFeature(feature);this.InteractiveMap.visionControl.removeVisionFeature(feature);var worldXY=latLonToWorld(feature.getGeometry().getCoordinates()).map(Math.round).join(',');var wardType=feature.get('wardType');delete this.placedWardCoordinates[wardType][worldXY];this.updateQueryString(wardType);};WardControl.prototype.highlight=function(feature){this.InteractiveMap.cursorControl.source.clear(true);this.unhighlight();var visionFeature=this.InteractiveMap.visionControl.setVisionFeature(feature);this.addRangeCircles(feature);this.InteractiveMap.highlight(feature);return visionFeature;};WardControl.prototype.unhighlight=function(feature){var highlightedFeature=feature||this.InteractiveMap.highlightedFeature;if(highlightedFeature&&!highlightedFeature.get("clicked")){this.InteractiveMap.visionControl.removeVisionFeature(highlightedFeature);this.removeRangeCircles(highlightedFeature);}this.InteractiveMap.unhighlight();};WardControl.prototype.addRangeCircles=function(feature){this.addRangeCircle(feature,'dayVision');this.addRangeCircle(feature,'nightVision');this.addRangeCircle(feature,'trueSight');this.addRangeCircle(feature,'attackRange');};WardControl.prototype.removeRangeCircles=function(feature){this.removeRangeCircle(feature,'dayVision');this.removeRangeCircle(feature,'nightVision');this.removeRangeCircle(feature,'trueSight');this.removeRangeCircle(feature,'attackRange');};WardControl.prototype.addRangeCircle=function(feature,rangeType){if(!feature.get(rangeType)){var circle=this.InteractiveMap.getRangeCircle(feature,null,null,rangeType);if(circle){feature.set(rangeType,circle,true);this.InteractiveMap.rangeSources[rangeType].addFeature(circle);}}};WardControl.prototype.removeRangeCircle=function(feature,rangeType){var circle=feature.get(rangeType);if(circle){feature.set(rangeType,null,true);this.InteractiveMap.rangeSources[rangeType].removeFeature(circle);}};function TreeControl(InteractiveMap){this.InteractiveMap=InteractiveMap;this.allTreesCutState=false;}TreeControl.prototype.updateQueryString=function(){var self=this;var keys=['cut_trees','uncut_trees'];var layer=this.InteractiveMap.getMapLayerIndex()['ent_dota_tree'];var source=layer.getSource();var features=source.getFeatures();var values=features.filter(function(feature){return!!feature.get('isCut')!=self.allTreesCutState;}).map(function(feature){var dotaProps=feature.get('dotaProps');return dotaProps.x+','+dotaProps.y;}).join(';');setQueryString(keys[this.allTreesCutState?1:0],values||null);setQueryString(keys[this.allTreesCutState?0:1],null);document.getElementById('toggle-ent_dota_tree').checked=this.allTreesCutState;};TreeControl.prototype.parseQueryString=function(){var self=this;var layer=this.InteractiveMap.getMapLayerIndex()['ent_dota_tree'];var source=layer.getSource();var features=source.getFeatures();var treeMap={};features.forEach(function(feature){var dotaProps=feature.get('dotaProps');var worldXY=dotaProps.x+','+dotaProps.y;treeMap[worldXY]=feature;});['uncut_trees','cut_trees'].forEach(function(treeCutState,index){var values=getParameterByName(treeCutState);if(values){self.toggleAllTrees(!index,true);values=values.split(';');values.forEach(function(worldXY){var feature=treeMap[worldXY];if(feature){if(!!feature.get('isCut')==!index){self.toggleTree(feature,feature.get('dotaProps'),true);}}});}});this.updateQueryString();};TreeControl.prototype.toggleTree=function(feature,dotaProps,bSkipQueryStringUpdate){var gridXY=this.InteractiveMap.vs.WorldXYtoGridXY(dotaProps.x,dotaProps.y);this.InteractiveMap.vs.toggleTree(gridXY.x,gridXY.y);feature.set('isCut',!feature.get('isCut'));if(!bSkipQueryStringUpdate)this.updateQueryString();};TreeControl.prototype.toggleAllTrees=function(state,bSkipQueryStringUpdate){var self=this;this.allTreesCutState=state;var layer=this.InteractiveMap.getMapLayerIndex()['ent_dota_tree'];var source=layer.getSource();var features=source.getFeatures();features.forEach(function(feature){if(!!feature.get('isCut')!=state){self.toggleTree(feature,feature.get('dotaProps'),true);}});if(!bSkipQueryStringUpdate)this.updateQueryString();};function CursorControl(InteractiveMap){var self=this;this.InteractiveMap=InteractiveMap;this.source=new _ol_source_Vector_({defaultDataProjection:'pixel'});this.layer=new _ol_layer_Vector_({source:this.source,style:styles.cursor});this.layerFilter=function(layer){return layer===self.layer;};}/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new ol.control.Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be `ol.Object`s in a `ol.Collection`, so you can use their
 * methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @constructor
 * @extends {ol.Object}
 * @implements {oli.control.Control}
 * @param {olx.control.ControlOptions} options Control options.
 * @api
 */var _ol_control_Control_=function(options){_ol_Object_.call(this);/**
   * @protected
   * @type {Element}
   */this.element=options.element?options.element:null;/**
   * @private
   * @type {Element}
   */this.target_=null;/**
   * @private
   * @type {ol.Map}
   */this.map_=null;/**
   * @protected
   * @type {!Array.<ol.EventsKey>}
   */this.listenerKeys=[];/**
   * @type {function(ol.MapEvent)}
   */this.render=options.render?options.render:_ol_.nullFunction;if(options.target){this.setTarget(options.target);}};_ol_.inherits(_ol_control_Control_,_ol_Object_);/**
 * @inheritDoc
 */_ol_control_Control_.prototype.disposeInternal=function(){_ol_dom_.removeNode(this.element);_ol_Object_.prototype.disposeInternal.call(this);};/**
 * Get the map associated with this control.
 * @return {ol.Map} Map.
 * @api
 */_ol_control_Control_.prototype.getMap=function(){return this.map_;};/**
 * Remove the control from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.Map} map Map.
 * @override
 * @api
 */_ol_control_Control_.prototype.setMap=function(map){if(this.map_){_ol_dom_.removeNode(this.element);}for(var i=0,ii=this.listenerKeys.length;i<ii;++i){_ol_events_.unlistenByKey(this.listenerKeys[i]);}this.listenerKeys.length=0;this.map_=map;if(this.map_){var target=this.target_?this.target_:map.getOverlayContainerStopEvent();target.appendChild(this.element);if(this.render!==_ol_.nullFunction){this.listenerKeys.push(_ol_events_.listen(map,_ol_MapEventType_.POSTRENDER,this.render,this));}map.render();}};/**
 * This function is used to set a target element for the control. It has no
 * effect if it is called after the control has been added to the map (i.e.
 * after `setMap` is called on the control). If no `target` is set in the
 * options passed to the control constructor and if `setTarget` is not called
 * then the control is added to the map's overlay container.
 * @param {Element|string} target Target.
 * @api
 */_ol_control_Control_.prototype.setTarget=function(target){this.target_=typeof target==='string'?document.getElementById(target):target;};// FIXME should listen on appropriate pane, once it is defined
/**
 * @classdesc
 * A control to show the 2D coordinates of the mouse cursor. By default, these
 * are in the view projection, but can be in any supported projection.
 * By default the control is shown in the top right corner of the map, but this
 * can be changed by using the css selector `.ol-mouse-position`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.MousePositionOptions=} opt_options Mouse position
 *     options.
 * @api
 */var _ol_control_MousePosition_=function(opt_options){var options=opt_options?opt_options:{};var element=document.createElement('DIV');element.className=options.className!==undefined?options.className:'ol-mouse-position';var render=options.render?options.render:_ol_control_MousePosition_.render;_ol_control_Control_.call(this,{element:element,render:render,target:options.target});_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_control_MousePosition_.Property_.PROJECTION),this.handleProjectionChanged_,this);if(options.coordinateFormat){this.setCoordinateFormat(options.coordinateFormat);}if(options.projection){this.setProjection(options.projection);}/**
   * @private
   * @type {string}
   */this.undefinedHTML_=options.undefinedHTML!==undefined?options.undefinedHTML:'';/**
   * @private
   * @type {string}
   */this.renderedHTML_=element.innerHTML;/**
   * @private
   * @type {ol.proj.Projection}
   */this.mapProjection_=null;/**
   * @private
   * @type {?ol.TransformFunction}
   */this.transform_=null;/**
   * @private
   * @type {ol.Pixel}
   */this.lastMouseMovePixel_=null;};_ol_.inherits(_ol_control_MousePosition_,_ol_control_Control_);/**
 * Update the mouseposition element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.MousePosition}
 * @api
 */_ol_control_MousePosition_.render=function(mapEvent){var frameState=mapEvent.frameState;if(!frameState){this.mapProjection_=null;}else{if(this.mapProjection_!=frameState.viewState.projection){this.mapProjection_=frameState.viewState.projection;this.transform_=null;}}this.updateHTML_(this.lastMouseMovePixel_);};/**
 * @private
 */_ol_control_MousePosition_.prototype.handleProjectionChanged_=function(){this.transform_=null;};/**
 * Return the coordinate format type used to render the current position or
 * undefined.
 * @return {ol.CoordinateFormatType|undefined} The format to render the current
 *     position in.
 * @observable
 * @api
 */_ol_control_MousePosition_.prototype.getCoordinateFormat=function(){return(/** @type {ol.CoordinateFormatType|undefined} */this.get(_ol_control_MousePosition_.Property_.COORDINATE_FORMAT));};/**
 * Return the projection that is used to report the mouse position.
 * @return {ol.proj.Projection|undefined} The projection to report mouse
 *     position in.
 * @observable
 * @api
 */_ol_control_MousePosition_.prototype.getProjection=function(){return(/** @type {ol.proj.Projection|undefined} */this.get(_ol_control_MousePosition_.Property_.PROJECTION));};/**
 * @param {Event} event Browser event.
 * @protected
 */_ol_control_MousePosition_.prototype.handleMouseMove=function(event){var map=this.getMap();this.lastMouseMovePixel_=map.getEventPixel(event);this.updateHTML_(this.lastMouseMovePixel_);};/**
 * @param {Event} event Browser event.
 * @protected
 */_ol_control_MousePosition_.prototype.handleMouseOut=function(event){this.updateHTML_(null);this.lastMouseMovePixel_=null;};/**
 * @inheritDoc
 * @api
 */_ol_control_MousePosition_.prototype.setMap=function(map){_ol_control_Control_.prototype.setMap.call(this,map);if(map){var viewport=map.getViewport();this.listenerKeys.push(_ol_events_.listen(viewport,_ol_events_EventType_.MOUSEMOVE,this.handleMouseMove,this),_ol_events_.listen(viewport,_ol_events_EventType_.MOUSEOUT,this.handleMouseOut,this));}};/**
 * Set the coordinate format type used to render the current position.
 * @param {ol.CoordinateFormatType} format The format to render the current
 *     position in.
 * @observable
 * @api
 */_ol_control_MousePosition_.prototype.setCoordinateFormat=function(format){this.set(_ol_control_MousePosition_.Property_.COORDINATE_FORMAT,format);};/**
 * Set the projection that is used to report the mouse position.
 * @param {ol.ProjectionLike} projection The projection to report mouse
 *     position in.
 * @observable
 * @api
 */_ol_control_MousePosition_.prototype.setProjection=function(projection){this.set(_ol_control_MousePosition_.Property_.PROJECTION,_ol_proj_.get(projection));};/**
 * @param {?ol.Pixel} pixel Pixel.
 * @private
 */_ol_control_MousePosition_.prototype.updateHTML_=function(pixel){var html=this.undefinedHTML_;if(pixel&&this.mapProjection_){if(!this.transform_){var projection=this.getProjection();if(projection){this.transform_=_ol_proj_.getTransformFromProjections(this.mapProjection_,projection);}else{this.transform_=_ol_proj_.identityTransform;}}var map=this.getMap();var coordinate=map.getCoordinateFromPixel(pixel);if(coordinate){this.transform_(coordinate,coordinate);var coordinateFormat=this.getCoordinateFormat();if(coordinateFormat){html=coordinateFormat(coordinate);}else{html=coordinate.toString();}}}if(!this.renderedHTML_||html!=this.renderedHTML_){this.element.innerHTML=html;this.renderedHTML_=html;}};/**
 * @enum {string}
 * @private
 */_ol_control_MousePosition_.Property_={PROJECTION:'projection',COORDINATE_FORMAT:'coordinateFormat'};function CoordinateControl(InteractiveMap,elementId){var self=this;this.InteractiveMap=InteractiveMap;this.mousePosition=new _ol_control_MousePosition_({coordinateFormat:_ol_coordinate_.createStringXY(),projection:dotaProj,target:document.getElementById(elementId),undefinedHTML:'&nbsp;'});this.InteractiveMap.map.addControl(this.mousePosition);}var _ol_CenterConstraint_={};/**
 * @param {ol.Extent} extent Extent.
 * @return {ol.CenterConstraintType} The constraint.
 */_ol_CenterConstraint_.createExtent=function(extent){return(/**
     * @param {ol.Coordinate|undefined} center Center.
     * @return {ol.Coordinate|undefined} Center.
     */function(center){if(center){return[_ol_math_.clamp(center[0],extent[0],extent[2]),_ol_math_.clamp(center[1],extent[1],extent[3])];}else{return undefined;}});};/**
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Center.
 */_ol_CenterConstraint_.none=function(center){return center;};var _ol_ResolutionConstraint_={};/**
 * @param {Array.<number>} resolutions Resolutions.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */_ol_ResolutionConstraint_.createSnapToResolutions=function(resolutions){return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */function(resolution,delta,direction){if(resolution!==undefined){var z=_ol_array_.linearFindNearest(resolutions,resolution,direction);z=_ol_math_.clamp(z+delta,0,resolutions.length-1);var index=Math.floor(z);if(z!=index&&index<resolutions.length-1){var power=resolutions[index]/resolutions[index+1];return resolutions[index]/Math.pow(power,z-index);}else{return resolutions[index];}}else{return undefined;}});};/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */_ol_ResolutionConstraint_.createSnapToPower=function(power,maxResolution,opt_maxLevel){return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */function(resolution,delta,direction){if(resolution!==undefined){var offset=-direction/2+0.5;var oldLevel=Math.floor(Math.log(maxResolution/resolution)/Math.log(power)+offset);var newLevel=Math.max(oldLevel+delta,0);if(opt_maxLevel!==undefined){newLevel=Math.min(newLevel,opt_maxLevel);}return maxResolution/Math.pow(power,newLevel);}else{return undefined;}});};var _ol_RotationConstraint_={};/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */_ol_RotationConstraint_.disable=function(rotation,delta){if(rotation!==undefined){return 0;}else{return undefined;}};/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */_ol_RotationConstraint_.none=function(rotation,delta){if(rotation!==undefined){return rotation+delta;}else{return undefined;}};/**
 * @param {number} n N.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */_ol_RotationConstraint_.createSnapToN=function(n){var theta=2*Math.PI/n;return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */function(rotation,delta){if(rotation!==undefined){rotation=Math.floor((rotation+delta)/theta+0.5)*theta;return rotation;}else{return undefined;}});};/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */_ol_RotationConstraint_.createSnapToZero=function(opt_tolerance){var tolerance=opt_tolerance||_ol_math_.toRadians(5);return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */function(rotation,delta){if(rotation!==undefined){if(Math.abs(rotation+delta)<=tolerance){return 0;}else{return rotation+delta;}}else{return undefined;}});};/**
 * @enum {string}
 */var _ol_ViewProperty_={CENTER:'center',RESOLUTION:'resolution',ROTATION:'rotation'};/**
 * @classdesc
 * An ol.View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An `ol.View` is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An `ol.View` has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But an `ol.View` object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.ViewOptions=} opt_options View options.
 * @api
 */var _ol_View_=function(opt_options){_ol_Object_.call(this);var options=_ol_obj_.assign({},opt_options);/**
   * @private
   * @type {Array.<number>}
   */this.hints_=[0,0];/**
   * @private
   * @type {Array.<Array.<ol.ViewAnimation>>}
   */this.animations_=[];/**
   * @private
   * @type {number|undefined}
   */this.updateAnimationKey_;this.updateAnimations_=this.updateAnimations_.bind(this);/**
   * @private
   * @const
   * @type {ol.proj.Projection}
   */this.projection_=_ol_proj_.createProjection(options.projection,'EPSG:3857');this.applyOptions_(options);};_ol_.inherits(_ol_View_,_ol_Object_);/**
 * Set up the view with the given options.
 * @param {olx.ViewOptions} options View options.
 */_ol_View_.prototype.applyOptions_=function(options){/**
   * @type {Object.<string, *>}
   */var properties={};properties[_ol_ViewProperty_.CENTER]=options.center!==undefined?options.center:null;var resolutionConstraintInfo=_ol_View_.createResolutionConstraint_(options);/**
   * @private
   * @type {number}
   */this.maxResolution_=resolutionConstraintInfo.maxResolution;/**
   * @private
   * @type {number}
   */this.minResolution_=resolutionConstraintInfo.minResolution;/**
   * @private
   * @type {number}
   */this.zoomFactor_=resolutionConstraintInfo.zoomFactor;/**
   * @private
   * @type {Array.<number>|undefined}
   */this.resolutions_=options.resolutions;/**
   * @private
   * @type {number}
   */this.minZoom_=resolutionConstraintInfo.minZoom;var centerConstraint=_ol_View_.createCenterConstraint_(options);var resolutionConstraint=resolutionConstraintInfo.constraint;var rotationConstraint=_ol_View_.createRotationConstraint_(options);/**
   * @private
   * @type {ol.Constraints}
   */this.constraints_={center:centerConstraint,resolution:resolutionConstraint,rotation:rotationConstraint};if(options.resolution!==undefined){properties[_ol_ViewProperty_.RESOLUTION]=options.resolution;}else if(options.zoom!==undefined){properties[_ol_ViewProperty_.RESOLUTION]=this.constrainResolution(this.maxResolution_,options.zoom-this.minZoom_);}properties[_ol_ViewProperty_.ROTATION]=options.rotation!==undefined?options.rotation:0;this.setProperties(properties);/**
   * @private
   * @type {olx.ViewOptions}
   */this.options_=options;};/**
 * Get an updated version of the view options used to construct the view.  The
 * current resolution (or zoom), center, and rotation are applied to any stored
 * options.  The provided options can be uesd to apply new min/max zoom or
 * resolution limits.
 * @param {olx.ViewOptions} newOptions New options to be applied.
 * @return {olx.ViewOptions} New options updated with the current view state.
 */_ol_View_.prototype.getUpdatedOptions_=function(newOptions){var options=_ol_obj_.assign({},this.options_);// preserve resolution (or zoom)
if(options.resolution!==undefined){options.resolution=this.getResolution();}else{options.zoom=this.getZoom();}// preserve center
options.center=this.getCenter();// preserve rotation
options.rotation=this.getRotation();return _ol_obj_.assign({},options,newOptions);};/**
 * Animate the view.  The view's center, zoom (or resolution), and rotation
 * can be animated for smooth transitions between view states.  For example,
 * to animate the view to a new zoom level:
 *
 *     view.animate({zoom: view.getZoom() + 1});
 *
 * By default, the animation lasts one second and uses in-and-out easing.  You
 * can customize this behavior by including `duration` (in milliseconds) and
 * `easing` options (see {@link ol.easing}).
 *
 * To chain together multiple animations, call the method with multiple
 * animation objects.  For example, to first zoom and then pan:
 *
 *     view.animate({zoom: 10}, {center: [0, 0]});
 *
 * If you provide a function as the last argument to the animate method, it
 * will get called at the end of an animation series.  The callback will be
 * called with `true` if the animation series completed on its own or `false`
 * if it was cancelled.
 *
 * Animations are cancelled by user interactions (e.g. dragging the map) or by
 * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
 * (or another method that calls one of these).
 *
 * @param {...(olx.AnimationOptions|function(boolean))} var_args Animation
 *     options.  Multiple animations can be run in series by passing multiple
 *     options objects.  To run multiple animations in parallel, call the method
 *     multiple times.  An optional callback can be provided as a final
 *     argument.  The callback will be called with a boolean indicating whether
 *     the animation completed without being cancelled.
 * @api
 */_ol_View_.prototype.animate=function(var_args){var start=Date.now();var center=this.getCenter().slice();var resolution=this.getResolution();var rotation=this.getRotation();var animationCount=arguments.length;var callback;if(animationCount>1&&typeof arguments[animationCount-1]==='function'){callback=arguments[animationCount-1];--animationCount;}var series=[];for(var i=0;i<animationCount;++i){var options=/** @type {olx.AnimationOptions} */arguments[i];var animation=/** @type {ol.ViewAnimation} */{start:start,complete:false,anchor:options.anchor,duration:options.duration!==undefined?options.duration:1000,easing:options.easing||_ol_easing_.inAndOut};if(options.center){animation.sourceCenter=center;animation.targetCenter=options.center;center=animation.targetCenter;}if(options.zoom!==undefined){animation.sourceResolution=resolution;animation.targetResolution=this.constrainResolution(this.maxResolution_,options.zoom-this.minZoom_,0);resolution=animation.targetResolution;}else if(options.resolution){animation.sourceResolution=resolution;animation.targetResolution=options.resolution;resolution=animation.targetResolution;}if(options.rotation!==undefined){animation.sourceRotation=rotation;var delta=_ol_math_.modulo(options.rotation-rotation+Math.PI,2*Math.PI)-Math.PI;animation.targetRotation=rotation+delta;rotation=animation.targetRotation;}animation.callback=callback;// check if animation is a no-op
if(_ol_View_.isNoopAnimation(animation)){animation.complete=true;// we still push it onto the series for callback handling
}else{start+=animation.duration;}series.push(animation);}this.animations_.push(series);this.setHint(_ol_ViewHint_.ANIMATING,1);this.updateAnimations_();};/**
 * Determine if the view is being animated.
 * @return {boolean} The view is being animated.
 * @api
 */_ol_View_.prototype.getAnimating=function(){return this.getHints()[_ol_ViewHint_.ANIMATING]>0;};/**
 * Determine if the user is interacting with the view, such as panning or zooming.
 * @return {boolean} The view is being interacted with.
 * @api
 */_ol_View_.prototype.getInteracting=function(){return this.getHints()[_ol_ViewHint_.INTERACTING]>0;};/**
 * Cancel any ongoing animations.
 * @api
 */_ol_View_.prototype.cancelAnimations=function(){this.setHint(_ol_ViewHint_.ANIMATING,-this.getHints()[_ol_ViewHint_.ANIMATING]);for(var i=0,ii=this.animations_.length;i<ii;++i){var series=this.animations_[i];if(series[0].callback){series[0].callback(false);}}this.animations_.length=0;};/**
 * Update all animations.
 */_ol_View_.prototype.updateAnimations_=function(){if(this.updateAnimationKey_!==undefined){cancelAnimationFrame(this.updateAnimationKey_);this.updateAnimationKey_=undefined;}if(!this.getAnimating()){return;}var now=Date.now();var more=false;for(var i=this.animations_.length-1;i>=0;--i){var series=this.animations_[i];var seriesComplete=true;for(var j=0,jj=series.length;j<jj;++j){var animation=series[j];if(animation.complete){continue;}var elapsed=now-animation.start;var fraction=animation.duration>0?elapsed/animation.duration:1;if(fraction>=1){animation.complete=true;fraction=1;}else{seriesComplete=false;}var progress=animation.easing(fraction);if(animation.sourceCenter){var x0=animation.sourceCenter[0];var y0=animation.sourceCenter[1];var x1=animation.targetCenter[0];var y1=animation.targetCenter[1];var x=x0+progress*(x1-x0);var y=y0+progress*(y1-y0);this.set(_ol_ViewProperty_.CENTER,[x,y]);}if(animation.sourceResolution&&animation.targetResolution){var resolution=progress===1?animation.targetResolution:animation.sourceResolution+progress*(animation.targetResolution-animation.sourceResolution);if(animation.anchor){this.set(_ol_ViewProperty_.CENTER,this.calculateCenterZoom(resolution,animation.anchor));}this.set(_ol_ViewProperty_.RESOLUTION,resolution);}if(animation.sourceRotation!==undefined&&animation.targetRotation!==undefined){var rotation=progress===1?_ol_math_.modulo(animation.targetRotation+Math.PI,2*Math.PI)-Math.PI:animation.sourceRotation+progress*(animation.targetRotation-animation.sourceRotation);if(animation.anchor){this.set(_ol_ViewProperty_.CENTER,this.calculateCenterRotate(rotation,animation.anchor));}this.set(_ol_ViewProperty_.ROTATION,rotation);}more=true;if(!animation.complete){break;}}if(seriesComplete){this.animations_[i]=null;this.setHint(_ol_ViewHint_.ANIMATING,-1);var callback=series[0].callback;if(callback){callback(true);}}}// prune completed series
this.animations_=this.animations_.filter(Boolean);if(more&&this.updateAnimationKey_===undefined){this.updateAnimationKey_=requestAnimationFrame(this.updateAnimations_);}};/**
 * @param {number} rotation Target rotation.
 * @param {ol.Coordinate} anchor Rotation anchor.
 * @return {ol.Coordinate|undefined} Center for rotation and anchor.
 */_ol_View_.prototype.calculateCenterRotate=function(rotation,anchor){var center;var currentCenter=this.getCenter();if(currentCenter!==undefined){center=[currentCenter[0]-anchor[0],currentCenter[1]-anchor[1]];_ol_coordinate_.rotate(center,rotation-this.getRotation());_ol_coordinate_.add(center,anchor);}return center;};/**
 * @param {number} resolution Target resolution.
 * @param {ol.Coordinate} anchor Zoom anchor.
 * @return {ol.Coordinate|undefined} Center for resolution and anchor.
 */_ol_View_.prototype.calculateCenterZoom=function(resolution,anchor){var center;var currentCenter=this.getCenter();var currentResolution=this.getResolution();if(currentCenter!==undefined&&currentResolution!==undefined){var x=anchor[0]-resolution*(anchor[0]-currentCenter[0])/currentResolution;var y=anchor[1]-resolution*(anchor[1]-currentCenter[1])/currentResolution;center=[x,y];}return center;};/**
 * @private
 * @return {ol.Size} Viewport size or `[100, 100]` when no viewport is found.
 */_ol_View_.prototype.getSizeFromViewport_=function(){var size=[100,100];var selector='.ol-viewport[data-view="'+_ol_.getUid(this)+'"]';var element=document.querySelector(selector);if(element){var metrics=getComputedStyle(element);size[0]=parseInt(metrics.width,10);size[1]=parseInt(metrics.height,10);}return size;};/**
 * Get the constrained center of this view.
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Constrained center.
 * @api
 */_ol_View_.prototype.constrainCenter=function(center){return this.constraints_.center(center);};/**
 * Get the constrained resolution of this view.
 * @param {number|undefined} resolution Resolution.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @param {number=} opt_direction Direction. Default is `0`.
 * @return {number|undefined} Constrained resolution.
 * @api
 */_ol_View_.prototype.constrainResolution=function(resolution,opt_delta,opt_direction){var delta=opt_delta||0;var direction=opt_direction||0;return this.constraints_.resolution(resolution,delta,direction);};/**
 * Get the constrained rotation of this view.
 * @param {number|undefined} rotation Rotation.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @return {number|undefined} Constrained rotation.
 * @api
 */_ol_View_.prototype.constrainRotation=function(rotation,opt_delta){var delta=opt_delta||0;return this.constraints_.rotation(rotation,delta);};/**
 * Get the view center.
 * @return {ol.Coordinate|undefined} The center of the view.
 * @observable
 * @api
 */_ol_View_.prototype.getCenter=function(){return(/** @type {ol.Coordinate|undefined} */this.get(_ol_ViewProperty_.CENTER));};/**
 * @return {ol.Constraints} Constraints.
 */_ol_View_.prototype.getConstraints=function(){return this.constraints_;};/**
 * @param {Array.<number>=} opt_hints Destination array.
 * @return {Array.<number>} Hint.
 */_ol_View_.prototype.getHints=function(opt_hints){if(opt_hints!==undefined){opt_hints[0]=this.hints_[0];opt_hints[1]=this.hints_[1];return opt_hints;}else{return this.hints_.slice();}};/**
 * Calculate the extent for the current view state and the passed size.
 * The size is the pixel dimensions of the box into which the calculated extent
 * should fit. In most cases you want to get the extent of the entire map,
 * that is `map.getSize()`.
 * @param {ol.Size=} opt_size Box pixel size. If not provided, the size of the
 * first map that uses this view will be used.
 * @return {ol.Extent} Extent.
 * @api
 */_ol_View_.prototype.calculateExtent=function(opt_size){var size=opt_size||this.getSizeFromViewport_();var center=/** @type {!ol.Coordinate} */this.getCenter();_ol_asserts_.assert(center,1);// The view center is not defined
var resolution=/** @type {!number} */this.getResolution();_ol_asserts_.assert(resolution!==undefined,2);// The view resolution is not defined
var rotation=/** @type {!number} */this.getRotation();_ol_asserts_.assert(rotation!==undefined,3);// The view rotation is not defined
return _ol_extent_.getForViewAndSize(center,resolution,rotation,size);};/**
 * Get the maximum resolution of the view.
 * @return {number} The maximum resolution of the view.
 * @api
 */_ol_View_.prototype.getMaxResolution=function(){return this.maxResolution_;};/**
 * Get the minimum resolution of the view.
 * @return {number} The minimum resolution of the view.
 * @api
 */_ol_View_.prototype.getMinResolution=function(){return this.minResolution_;};/**
 * Get the maximum zoom level for the view.
 * @return {number} The maximum zoom level.
 * @api
 */_ol_View_.prototype.getMaxZoom=function(){return(/** @type {number} */this.getZoomForResolution(this.minResolution_));};/**
 * Set a new maximum zoom level for the view.
 * @param {number} zoom The maximum zoom level.
 * @api
 */_ol_View_.prototype.setMaxZoom=function(zoom){this.applyOptions_(this.getUpdatedOptions_({maxZoom:zoom}));};/**
 * Get the minimum zoom level for the view.
 * @return {number} The minimum zoom level.
 * @api
 */_ol_View_.prototype.getMinZoom=function(){return(/** @type {number} */this.getZoomForResolution(this.maxResolution_));};/**
 * Set a new minimum zoom level for the view.
 * @param {number} zoom The minimum zoom level.
 * @api
 */_ol_View_.prototype.setMinZoom=function(zoom){this.applyOptions_(this.getUpdatedOptions_({minZoom:zoom}));};/**
 * Get the view projection.
 * @return {ol.proj.Projection} The projection of the view.
 * @api
 */_ol_View_.prototype.getProjection=function(){return this.projection_;};/**
 * Get the view resolution.
 * @return {number|undefined} The resolution of the view.
 * @observable
 * @api
 */_ol_View_.prototype.getResolution=function(){return(/** @type {number|undefined} */this.get(_ol_ViewProperty_.RESOLUTION));};/**
 * Get the resolutions for the view. This returns the array of resolutions
 * passed to the constructor of the {ol.View}, or undefined if none were given.
 * @return {Array.<number>|undefined} The resolutions of the view.
 * @api
 */_ol_View_.prototype.getResolutions=function(){return this.resolutions_;};/**
 * Get the resolution for a provided extent (in map units) and size (in pixels).
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size=} opt_size Box pixel size.
 * @return {number} The resolution at which the provided extent will render at
 *     the given size.
 * @api
 */_ol_View_.prototype.getResolutionForExtent=function(extent,opt_size){var size=opt_size||this.getSizeFromViewport_();var xResolution=_ol_extent_.getWidth(extent)/size[0];var yResolution=_ol_extent_.getHeight(extent)/size[1];return Math.max(xResolution,yResolution);};/**
 * Return a function that returns a value between 0 and 1 for a
 * resolution. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Resolution for value function.
 */_ol_View_.prototype.getResolutionForValueFunction=function(opt_power){var power=opt_power||2;var maxResolution=this.maxResolution_;var minResolution=this.minResolution_;var max=Math.log(maxResolution/minResolution)/Math.log(power);return(/**
     * @param {number} value Value.
     * @return {number} Resolution.
     */function(value){var resolution=maxResolution/Math.pow(power,value*max);return resolution;});};/**
 * Get the view rotation.
 * @return {number} The rotation of the view in radians.
 * @observable
 * @api
 */_ol_View_.prototype.getRotation=function(){return(/** @type {number} */this.get(_ol_ViewProperty_.ROTATION));};/**
 * Return a function that returns a resolution for a value between
 * 0 and 1. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Value for resolution function.
 */_ol_View_.prototype.getValueForResolutionFunction=function(opt_power){var power=opt_power||2;var maxResolution=this.maxResolution_;var minResolution=this.minResolution_;var max=Math.log(maxResolution/minResolution)/Math.log(power);return(/**
     * @param {number} resolution Resolution.
     * @return {number} Value.
     */function(resolution){var value=Math.log(maxResolution/resolution)/Math.log(power)/max;return value;});};/**
 * @return {olx.ViewState} View state.
 */_ol_View_.prototype.getState=function(){var center=/** @type {ol.Coordinate} */this.getCenter();var projection=this.getProjection();var resolution=/** @type {number} */this.getResolution();var rotation=this.getRotation();return(/** @type {olx.ViewState} */{center:center.slice(),projection:projection!==undefined?projection:null,resolution:resolution,rotation:rotation});};/**
 * Get the current zoom level. Return undefined if the current
 * resolution is undefined or not within the "resolution constraints".
 * @return {number|undefined} Zoom.
 * @api
 */_ol_View_.prototype.getZoom=function(){var zoom;var resolution=this.getResolution();if(resolution!==undefined){zoom=this.getZoomForResolution(resolution);}return zoom;};/**
 * Get the zoom level for a resolution.
 * @param {number} resolution The resolution.
 * @return {number|undefined} The zoom level for the provided resolution.
 * @api
 */_ol_View_.prototype.getZoomForResolution=function(resolution){var zoom;if(resolution>=this.minResolution_&&resolution<=this.maxResolution_){var offset=this.minZoom_||0;var max,zoomFactor;if(this.resolutions_){var nearest=_ol_array_.linearFindNearest(this.resolutions_,resolution,1);offset+=nearest;if(nearest==this.resolutions_.length-1){return offset;}max=this.resolutions_[nearest];zoomFactor=max/this.resolutions_[nearest+1];}else{max=this.maxResolution_;zoomFactor=this.zoomFactor_;}zoom=offset+Math.log(max/resolution)/Math.log(zoomFactor);}return zoom;};/**
 * Get the resolution for a zoom level.
 * @param {number} zoom Zoom level.
 * @return {number} The view resolution for the provided zoom level.
 * @api
 */_ol_View_.prototype.getResolutionForZoom=function(zoom){return(/** @type {number} */this.constrainResolution(this.maxResolution_,zoom-this.minZoom_,0));};/**
 * Fit the given geometry or extent based on the given map size and border.
 * The size is pixel dimensions of the box to fit the extent into.
 * In most cases you will want to use the map size, that is `map.getSize()`.
 * Takes care of the map angle.
 * @param {ol.geom.SimpleGeometry|ol.Extent} geometryOrExtent The geometry or
 *     extent to fit the view to.
 * @param {olx.view.FitOptions=} opt_options Options.
 * @api
 */_ol_View_.prototype.fit=function(geometryOrExtent,opt_options){var options=opt_options||{};var size=options.size;if(!size){size=this.getSizeFromViewport_();}/** @type {ol.geom.SimpleGeometry} */var geometry;if(!(geometryOrExtent instanceof _ol_geom_SimpleGeometry_)){_ol_asserts_.assert(Array.isArray(geometryOrExtent),24);// Invalid extent or geometry provided as `geometry`
_ol_asserts_.assert(!_ol_extent_.isEmpty(geometryOrExtent),25);// Cannot fit empty extent provided as `geometry`
geometry=_ol_geom_Polygon_.fromExtent(geometryOrExtent);}else if(geometryOrExtent.getType()===_ol_geom_GeometryType_.CIRCLE){geometryOrExtent=geometryOrExtent.getExtent();geometry=_ol_geom_Polygon_.fromExtent(geometryOrExtent);geometry.rotate(this.getRotation(),_ol_extent_.getCenter(geometryOrExtent));}else{geometry=geometryOrExtent;}var padding=options.padding!==undefined?options.padding:[0,0,0,0];var constrainResolution=options.constrainResolution!==undefined?options.constrainResolution:true;var nearest=options.nearest!==undefined?options.nearest:false;var minResolution;if(options.minResolution!==undefined){minResolution=options.minResolution;}else if(options.maxZoom!==undefined){minResolution=this.constrainResolution(this.maxResolution_,options.maxZoom-this.minZoom_,0);}else{minResolution=0;}var coords=geometry.getFlatCoordinates();// calculate rotated extent
var rotation=this.getRotation();var cosAngle=Math.cos(-rotation);var sinAngle=Math.sin(-rotation);var minRotX=+Infinity;var minRotY=+Infinity;var maxRotX=-Infinity;var maxRotY=-Infinity;var stride=geometry.getStride();for(var i=0,ii=coords.length;i<ii;i+=stride){var rotX=coords[i]*cosAngle-coords[i+1]*sinAngle;var rotY=coords[i]*sinAngle+coords[i+1]*cosAngle;minRotX=Math.min(minRotX,rotX);minRotY=Math.min(minRotY,rotY);maxRotX=Math.max(maxRotX,rotX);maxRotY=Math.max(maxRotY,rotY);}// calculate resolution
var resolution=this.getResolutionForExtent([minRotX,minRotY,maxRotX,maxRotY],[size[0]-padding[1]-padding[3],size[1]-padding[0]-padding[2]]);resolution=isNaN(resolution)?minResolution:Math.max(resolution,minResolution);if(constrainResolution){var constrainedResolution=this.constrainResolution(resolution,0,0);if(!nearest&&constrainedResolution<resolution){constrainedResolution=this.constrainResolution(constrainedResolution,-1,0);}resolution=constrainedResolution;}// calculate center
sinAngle=-sinAngle;// go back to original rotation
var centerRotX=(minRotX+maxRotX)/2;var centerRotY=(minRotY+maxRotY)/2;centerRotX+=(padding[1]-padding[3])/2*resolution;centerRotY+=(padding[0]-padding[2])/2*resolution;var centerX=centerRotX*cosAngle-centerRotY*sinAngle;var centerY=centerRotY*cosAngle+centerRotX*sinAngle;var center=[centerX,centerY];var callback=options.callback?options.callback:_ol_.nullFunction;if(options.duration!==undefined){this.animate({resolution:resolution,center:center,duration:options.duration,easing:options.easing},callback);}else{this.setResolution(resolution);this.setCenter(center);setTimeout(callback.bind(undefined,true),0);}};/**
 * Center on coordinate and view position.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Size} size Box pixel size.
 * @param {ol.Pixel} position Position on the view to center on.
 * @api
 */_ol_View_.prototype.centerOn=function(coordinate,size,position){// calculate rotated position
var rotation=this.getRotation();var cosAngle=Math.cos(-rotation);var sinAngle=Math.sin(-rotation);var rotX=coordinate[0]*cosAngle-coordinate[1]*sinAngle;var rotY=coordinate[1]*cosAngle+coordinate[0]*sinAngle;var resolution=this.getResolution();rotX+=(size[0]/2-position[0])*resolution;rotY+=(position[1]-size[1]/2)*resolution;// go back to original angle
sinAngle=-sinAngle;// go back to original rotation
var centerX=rotX*cosAngle-rotY*sinAngle;var centerY=rotY*cosAngle+rotX*sinAngle;this.setCenter([centerX,centerY]);};/**
 * @return {boolean} Is defined.
 */_ol_View_.prototype.isDef=function(){return!!this.getCenter()&&this.getResolution()!==undefined;};/**
 * Rotate the view around a given coordinate.
 * @param {number} rotation New rotation value for the view.
 * @param {ol.Coordinate=} opt_anchor The rotation center.
 * @api
 */_ol_View_.prototype.rotate=function(rotation,opt_anchor){if(opt_anchor!==undefined){var center=this.calculateCenterRotate(rotation,opt_anchor);this.setCenter(center);}this.setRotation(rotation);};/**
 * Set the center of the current view.
 * @param {ol.Coordinate|undefined} center The center of the view.
 * @observable
 * @api
 */_ol_View_.prototype.setCenter=function(center){this.set(_ol_ViewProperty_.CENTER,center);if(this.getAnimating()){this.cancelAnimations();}};/**
 * @param {ol.ViewHint} hint Hint.
 * @param {number} delta Delta.
 * @return {number} New value.
 */_ol_View_.prototype.setHint=function(hint,delta){this.hints_[hint]+=delta;this.changed();return this.hints_[hint];};/**
 * Set the resolution for this view.
 * @param {number|undefined} resolution The resolution of the view.
 * @observable
 * @api
 */_ol_View_.prototype.setResolution=function(resolution){this.set(_ol_ViewProperty_.RESOLUTION,resolution);if(this.getAnimating()){this.cancelAnimations();}};/**
 * Set the rotation for this view.
 * @param {number} rotation The rotation of the view in radians.
 * @observable
 * @api
 */_ol_View_.prototype.setRotation=function(rotation){this.set(_ol_ViewProperty_.ROTATION,rotation);if(this.getAnimating()){this.cancelAnimations();}};/**
 * Zoom to a specific zoom level.
 * @param {number} zoom Zoom level.
 * @api
 */_ol_View_.prototype.setZoom=function(zoom){this.setResolution(this.getResolutionForZoom(zoom));};/**
 * @param {olx.ViewOptions} options View options.
 * @private
 * @return {ol.CenterConstraintType} The constraint.
 */_ol_View_.createCenterConstraint_=function(options){if(options.extent!==undefined){return _ol_CenterConstraint_.createExtent(options.extent);}else{return _ol_CenterConstraint_.none;}};/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {{constraint: ol.ResolutionConstraintType, maxResolution: number,
 *     minResolution: number, zoomFactor: number}} The constraint.
 */_ol_View_.createResolutionConstraint_=function(options){var resolutionConstraint;var maxResolution;var minResolution;// TODO: move these to be ol constants
// see https://github.com/openlayers/openlayers/issues/2076
var defaultMaxZoom=28;var defaultZoomFactor=2;var minZoom=options.minZoom!==undefined?options.minZoom:_ol_.DEFAULT_MIN_ZOOM;var maxZoom=options.maxZoom!==undefined?options.maxZoom:defaultMaxZoom;var zoomFactor=options.zoomFactor!==undefined?options.zoomFactor:defaultZoomFactor;if(options.resolutions!==undefined){var resolutions=options.resolutions;maxResolution=resolutions[0];minResolution=resolutions[resolutions.length-1];resolutionConstraint=_ol_ResolutionConstraint_.createSnapToResolutions(resolutions);}else{// calculate the default min and max resolution
var projection=_ol_proj_.createProjection(options.projection,'EPSG:3857');var extent=projection.getExtent();var size=!extent?// use an extent that can fit the whole world if need be
360*_ol_proj_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES]/projection.getMetersPerUnit():Math.max(_ol_extent_.getWidth(extent),_ol_extent_.getHeight(extent));var defaultMaxResolution=size/_ol_.DEFAULT_TILE_SIZE/Math.pow(defaultZoomFactor,_ol_.DEFAULT_MIN_ZOOM);var defaultMinResolution=defaultMaxResolution/Math.pow(defaultZoomFactor,defaultMaxZoom-_ol_.DEFAULT_MIN_ZOOM);// user provided maxResolution takes precedence
maxResolution=options.maxResolution;if(maxResolution!==undefined){minZoom=0;}else{maxResolution=defaultMaxResolution/Math.pow(zoomFactor,minZoom);}// user provided minResolution takes precedence
minResolution=options.minResolution;if(minResolution===undefined){if(options.maxZoom!==undefined){if(options.maxResolution!==undefined){minResolution=maxResolution/Math.pow(zoomFactor,maxZoom);}else{minResolution=defaultMaxResolution/Math.pow(zoomFactor,maxZoom);}}else{minResolution=defaultMinResolution;}}// given discrete zoom levels, minResolution may be different than provided
maxZoom=minZoom+Math.floor(Math.log(maxResolution/minResolution)/Math.log(zoomFactor));minResolution=maxResolution/Math.pow(zoomFactor,maxZoom-minZoom);resolutionConstraint=_ol_ResolutionConstraint_.createSnapToPower(zoomFactor,maxResolution,maxZoom-minZoom);}return{constraint:resolutionConstraint,maxResolution:maxResolution,minResolution:minResolution,minZoom:minZoom,zoomFactor:zoomFactor};};/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */_ol_View_.createRotationConstraint_=function(options){var enableRotation=options.enableRotation!==undefined?options.enableRotation:true;if(enableRotation){var constrainRotation=options.constrainRotation;if(constrainRotation===undefined||constrainRotation===true){return _ol_RotationConstraint_.createSnapToZero();}else if(constrainRotation===false){return _ol_RotationConstraint_.none;}else if(typeof constrainRotation==='number'){return _ol_RotationConstraint_.createSnapToN(constrainRotation);}else{return _ol_RotationConstraint_.none;}}else{return _ol_RotationConstraint_.disable;}};/**
 * Determine if an animation involves no view change.
 * @param {ol.ViewAnimation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */_ol_View_.isNoopAnimation=function(animation){if(animation.sourceCenter&&animation.targetCenter){if(!_ol_coordinate_.equals(animation.sourceCenter,animation.targetCenter)){return false;}}if(animation.sourceResolution!==animation.targetResolution){return false;}if(animation.sourceRotation!==animation.targetRotation){return false;}return true;};/**
 * Constants for event names.
 * @enum {string}
 */var _ol_pointer_EventType_={POINTERMOVE:'pointermove',POINTERDOWN:'pointerdown',POINTERUP:'pointerup',POINTEROVER:'pointerover',POINTEROUT:'pointerout',POINTERENTER:'pointerenter',POINTERLEAVE:'pointerleave',POINTERCANCEL:'pointercancel'};/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @param {!Object.<string, function(Event)>} mapping Event
 *     mapping.
 * @constructor
 */var _ol_pointer_EventSource_=function(dispatcher,mapping){/**
   * @type {ol.pointer.PointerEventHandler}
   */this.dispatcher=dispatcher;/**
   * @private
   * @const
   * @type {!Object.<string, function(Event)>}
   */this.mapping_=mapping;};/**
 * List of events supported by this source.
 * @return {Array.<string>} Event names
 */_ol_pointer_EventSource_.prototype.getEvents=function(){return Object.keys(this.mapping_);};/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */_ol_pointer_EventSource_.prototype.getHandlerForEvent=function(eventType){return this.mapping_[eventType];};// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */var _ol_pointer_MouseSource_=function(dispatcher){var mapping={'mousedown':this.mousedown,'mousemove':this.mousemove,'mouseup':this.mouseup,'mouseover':this.mouseover,'mouseout':this.mouseout};_ol_pointer_EventSource_.call(this,dispatcher,mapping);/**
   * @const
   * @type {!Object.<string, Event|Object>}
   */this.pointerMap=dispatcher.pointerMap;/**
   * @const
   * @type {Array.<ol.Pixel>}
   */this.lastTouches=[];};_ol_.inherits(_ol_pointer_MouseSource_,_ol_pointer_EventSource_);/**
 * @const
 * @type {number}
 */_ol_pointer_MouseSource_.POINTER_ID=1;/**
 * @const
 * @type {string}
 */_ol_pointer_MouseSource_.POINTER_TYPE='mouse';/**
 * Radius around touchend that swallows mouse events.
 *
 * @const
 * @type {number}
 */_ol_pointer_MouseSource_.DEDUP_DIST=25;/**
 * Detect if a mouse event was simulated from a touch by
 * checking if previously there was a touch event at the
 * same position.
 *
 * FIXME - Known problem with the native Android browser on
 * Samsung GT-I9100 (Android 4.1.2):
 * In case the page is scrolled, this function does not work
 * correctly when a canvas is used (WebGL or canvas renderer).
 * Mouse listeners on canvas elements (for this browser), create
 * two mouse events: One 'good' and one 'bad' one (on other browsers or
 * when a div is used, there is only one event). For the 'bad' one,
 * clientX/clientY and also pageX/pageY are wrong when the page
 * is scrolled. Because of that, this function can not detect if
 * the events were simulated from a touch event. As result, a
 * pointer event at a wrong position is dispatched, which confuses
 * the map interactions.
 * It is unclear, how one can get the correct position for the event
 * or detect that the positions are invalid.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {boolean} True, if the event was generated by a touch.
 */_ol_pointer_MouseSource_.prototype.isEventSimulatedFromTouch_=function(inEvent){var lts=this.lastTouches;var x=inEvent.clientX,y=inEvent.clientY;for(var i=0,l=lts.length,t;i<l&&(t=lts[i]);i++){// simulated mouse events will be swallowed near a primary touchend
var dx=Math.abs(x-t[0]),dy=Math.abs(y-t[1]);if(dx<=_ol_pointer_MouseSource_.DEDUP_DIST&&dy<=_ol_pointer_MouseSource_.DEDUP_DIST){return true;}}return false;};/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @return {Object} The copied event.
 */_ol_pointer_MouseSource_.prepareEvent=function(inEvent,dispatcher){var e=dispatcher.cloneEvent(inEvent,inEvent);// forward mouse preventDefault
var pd=e.preventDefault;e.preventDefault=function(){inEvent.preventDefault();pd();};e.pointerId=_ol_pointer_MouseSource_.POINTER_ID;e.isPrimary=true;e.pointerType=_ol_pointer_MouseSource_.POINTER_TYPE;return e;};/**
 * Handler for `mousedown`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MouseSource_.prototype.mousedown=function(inEvent){if(!this.isEventSimulatedFromTouch_(inEvent)){// TODO(dfreedman) workaround for some elements not sending mouseup
// http://crbug/149091
if(_ol_pointer_MouseSource_.POINTER_ID.toString()in this.pointerMap){this.cancel(inEvent);}var e=_ol_pointer_MouseSource_.prepareEvent(inEvent,this.dispatcher);this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()]=inEvent;this.dispatcher.down(e,inEvent);}};/**
 * Handler for `mousemove`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MouseSource_.prototype.mousemove=function(inEvent){if(!this.isEventSimulatedFromTouch_(inEvent)){var e=_ol_pointer_MouseSource_.prepareEvent(inEvent,this.dispatcher);this.dispatcher.move(e,inEvent);}};/**
 * Handler for `mouseup`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MouseSource_.prototype.mouseup=function(inEvent){if(!this.isEventSimulatedFromTouch_(inEvent)){var p=this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];if(p&&p.button===inEvent.button){var e=_ol_pointer_MouseSource_.prepareEvent(inEvent,this.dispatcher);this.dispatcher.up(e,inEvent);this.cleanupMouse();}}};/**
 * Handler for `mouseover`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MouseSource_.prototype.mouseover=function(inEvent){if(!this.isEventSimulatedFromTouch_(inEvent)){var e=_ol_pointer_MouseSource_.prepareEvent(inEvent,this.dispatcher);this.dispatcher.enterOver(e,inEvent);}};/**
 * Handler for `mouseout`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MouseSource_.prototype.mouseout=function(inEvent){if(!this.isEventSimulatedFromTouch_(inEvent)){var e=_ol_pointer_MouseSource_.prepareEvent(inEvent,this.dispatcher);this.dispatcher.leaveOut(e,inEvent);}};/**
 * Dispatches a `pointercancel` event.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MouseSource_.prototype.cancel=function(inEvent){var e=_ol_pointer_MouseSource_.prepareEvent(inEvent,this.dispatcher);this.dispatcher.cancel(e,inEvent);this.cleanupMouse();};/**
 * Remove the mouse from the list of active pointers.
 */_ol_pointer_MouseSource_.prototype.cleanupMouse=function(){delete this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];};// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */var _ol_pointer_MsSource_=function(dispatcher){var mapping={'MSPointerDown':this.msPointerDown,'MSPointerMove':this.msPointerMove,'MSPointerUp':this.msPointerUp,'MSPointerOut':this.msPointerOut,'MSPointerOver':this.msPointerOver,'MSPointerCancel':this.msPointerCancel,'MSGotPointerCapture':this.msGotPointerCapture,'MSLostPointerCapture':this.msLostPointerCapture};_ol_pointer_EventSource_.call(this,dispatcher,mapping);/**
   * @const
   * @type {!Object.<string, Event|Object>}
   */this.pointerMap=dispatcher.pointerMap;/**
   * @const
   * @type {Array.<string>}
   */this.POINTER_TYPES=['','unavailable','touch','pen','mouse'];};_ol_.inherits(_ol_pointer_MsSource_,_ol_pointer_EventSource_);/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {Object} The copied event.
 */_ol_pointer_MsSource_.prototype.prepareEvent_=function(inEvent){var e=inEvent;if(typeof inEvent.pointerType==='number'){e=this.dispatcher.cloneEvent(inEvent,inEvent);e.pointerType=this.POINTER_TYPES[inEvent.pointerType];}return e;};/**
 * Remove this pointer from the list of active pointers.
 * @param {number} pointerId Pointer identifier.
 */_ol_pointer_MsSource_.prototype.cleanup=function(pointerId){delete this.pointerMap[pointerId.toString()];};/**
 * Handler for `msPointerDown`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msPointerDown=function(inEvent){this.pointerMap[inEvent.pointerId.toString()]=inEvent;var e=this.prepareEvent_(inEvent);this.dispatcher.down(e,inEvent);};/**
 * Handler for `msPointerMove`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msPointerMove=function(inEvent){var e=this.prepareEvent_(inEvent);this.dispatcher.move(e,inEvent);};/**
 * Handler for `msPointerUp`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msPointerUp=function(inEvent){var e=this.prepareEvent_(inEvent);this.dispatcher.up(e,inEvent);this.cleanup(inEvent.pointerId);};/**
 * Handler for `msPointerOut`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msPointerOut=function(inEvent){var e=this.prepareEvent_(inEvent);this.dispatcher.leaveOut(e,inEvent);};/**
 * Handler for `msPointerOver`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msPointerOver=function(inEvent){var e=this.prepareEvent_(inEvent);this.dispatcher.enterOver(e,inEvent);};/**
 * Handler for `msPointerCancel`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msPointerCancel=function(inEvent){var e=this.prepareEvent_(inEvent);this.dispatcher.cancel(e,inEvent);this.cleanup(inEvent.pointerId);};/**
 * Handler for `msLostPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msLostPointerCapture=function(inEvent){var e=this.dispatcher.makeEvent('lostpointercapture',inEvent,inEvent);this.dispatcher.dispatchEvent(e);};/**
 * Handler for `msGotPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_MsSource_.prototype.msGotPointerCapture=function(inEvent){var e=this.dispatcher.makeEvent('gotpointercapture',inEvent,inEvent);this.dispatcher.dispatchEvent(e);};// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */var _ol_pointer_NativeSource_=function(dispatcher){var mapping={'pointerdown':this.pointerDown,'pointermove':this.pointerMove,'pointerup':this.pointerUp,'pointerout':this.pointerOut,'pointerover':this.pointerOver,'pointercancel':this.pointerCancel,'gotpointercapture':this.gotPointerCapture,'lostpointercapture':this.lostPointerCapture};_ol_pointer_EventSource_.call(this,dispatcher,mapping);};_ol_.inherits(_ol_pointer_NativeSource_,_ol_pointer_EventSource_);/**
 * Handler for `pointerdown`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.pointerDown=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};/**
 * Handler for `pointermove`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.pointerMove=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};/**
 * Handler for `pointerup`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.pointerUp=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};/**
 * Handler for `pointerout`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.pointerOut=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};/**
 * Handler for `pointerover`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.pointerOver=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};/**
 * Handler for `pointercancel`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.pointerCancel=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};/**
 * Handler for `lostpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.lostPointerCapture=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};/**
 * Handler for `gotpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_NativeSource_.prototype.gotPointerCapture=function(inEvent){this.dispatcher.fireNativeEvent(inEvent);};// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/**
 * A class for pointer events.
 *
 * This class is used as an abstraction for mouse events,
 * touch events and even native pointer events.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @param {string} type The type of the event to create.
 * @param {Event} originalEvent The event.
 * @param {Object.<string, ?>=} opt_eventDict An optional dictionary of
 *    initial event properties.
 */var _ol_pointer_PointerEvent_=function(type,originalEvent,opt_eventDict){_ol_events_Event_.call(this,type);/**
   * @const
   * @type {Event}
   */this.originalEvent=originalEvent;var eventDict=opt_eventDict?opt_eventDict:{};/**
   * @type {number}
   */this.buttons=this.getButtons_(eventDict);/**
   * @type {number}
   */this.pressure=this.getPressure_(eventDict,this.buttons);// MouseEvent related properties
/**
   * @type {boolean}
   */this.bubbles='bubbles'in eventDict?eventDict['bubbles']:false;/**
   * @type {boolean}
   */this.cancelable='cancelable'in eventDict?eventDict['cancelable']:false;/**
   * @type {Object}
   */this.view='view'in eventDict?eventDict['view']:null;/**
   * @type {number}
   */this.detail='detail'in eventDict?eventDict['detail']:null;/**
   * @type {number}
   */this.screenX='screenX'in eventDict?eventDict['screenX']:0;/**
   * @type {number}
   */this.screenY='screenY'in eventDict?eventDict['screenY']:0;/**
   * @type {number}
   */this.clientX='clientX'in eventDict?eventDict['clientX']:0;/**
   * @type {number}
   */this.clientY='clientY'in eventDict?eventDict['clientY']:0;/**
   * @type {boolean}
   */this.ctrlKey='ctrlKey'in eventDict?eventDict['ctrlKey']:false;/**
   * @type {boolean}
   */this.altKey='altKey'in eventDict?eventDict['altKey']:false;/**
   * @type {boolean}
   */this.shiftKey='shiftKey'in eventDict?eventDict['shiftKey']:false;/**
   * @type {boolean}
   */this.metaKey='metaKey'in eventDict?eventDict['metaKey']:false;/**
   * @type {number}
   */this.button='button'in eventDict?eventDict['button']:0;/**
   * @type {Node}
   */this.relatedTarget='relatedTarget'in eventDict?eventDict['relatedTarget']:null;// PointerEvent related properties
/**
   * @const
   * @type {number}
   */this.pointerId='pointerId'in eventDict?eventDict['pointerId']:0;/**
   * @type {number}
   */this.width='width'in eventDict?eventDict['width']:0;/**
   * @type {number}
   */this.height='height'in eventDict?eventDict['height']:0;/**
   * @type {number}
   */this.tiltX='tiltX'in eventDict?eventDict['tiltX']:0;/**
   * @type {number}
   */this.tiltY='tiltY'in eventDict?eventDict['tiltY']:0;/**
   * @type {string}
   */this.pointerType='pointerType'in eventDict?eventDict['pointerType']:'';/**
   * @type {number}
   */this.hwTimestamp='hwTimestamp'in eventDict?eventDict['hwTimestamp']:0;/**
   * @type {boolean}
   */this.isPrimary='isPrimary'in eventDict?eventDict['isPrimary']:false;// keep the semantics of preventDefault
if(originalEvent.preventDefault){this.preventDefault=function(){originalEvent.preventDefault();};}};_ol_.inherits(_ol_pointer_PointerEvent_,_ol_events_Event_);/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @return {number} Button indicator.
 */_ol_pointer_PointerEvent_.prototype.getButtons_=function(eventDict){// According to the w3c spec,
// http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
// MouseEvent.button == 0 can mean either no mouse button depressed, or the
// left mouse button depressed.
//
// As of now, the only way to distinguish between the two states of
// MouseEvent.button is by using the deprecated MouseEvent.which property, as
// this maps mouse buttons to positive integers > 0, and uses 0 to mean that
// no mouse button is held.
//
// MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
// but initMouseEvent does not expose an argument with which to set
// MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
// MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
// of app developers.
//
// The only way to propagate the correct state of MouseEvent.which and
// MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
// is to call initMouseEvent with a buttonArg value of -1.
//
// This is fixed with DOM Level 4's use of buttons
var buttons;if(eventDict.buttons||_ol_pointer_PointerEvent_.HAS_BUTTONS){buttons=eventDict.buttons;}else{switch(eventDict.which){case 1:buttons=1;break;case 2:buttons=4;break;case 3:buttons=2;break;default:buttons=0;}}return buttons;};/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @param {number} buttons Button indicator.
 * @return {number} The pressure.
 */_ol_pointer_PointerEvent_.prototype.getPressure_=function(eventDict,buttons){// Spec requires that pointers without pressure specified use 0.5 for down
// state and 0 for up state.
var pressure=0;if(eventDict.pressure){pressure=eventDict.pressure;}else{pressure=buttons?0.5:0;}return pressure;};/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */_ol_pointer_PointerEvent_.HAS_BUTTONS=false;/**
 * Checks if the `buttons` property is supported.
 */(function(){try{var ev=new MouseEvent('click',{buttons:1});_ol_pointer_PointerEvent_.HAS_BUTTONS=ev.buttons===1;}catch(e){// pass
}})();// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/**
 * @constructor
 * @param {ol.pointer.PointerEventHandler} dispatcher The event handler.
 * @param {ol.pointer.MouseSource} mouseSource Mouse source.
 * @extends {ol.pointer.EventSource}
 */var _ol_pointer_TouchSource_=function(dispatcher,mouseSource){var mapping={'touchstart':this.touchstart,'touchmove':this.touchmove,'touchend':this.touchend,'touchcancel':this.touchcancel};_ol_pointer_EventSource_.call(this,dispatcher,mapping);/**
   * @const
   * @type {!Object.<string, Event|Object>}
   */this.pointerMap=dispatcher.pointerMap;/**
   * @const
   * @type {ol.pointer.MouseSource}
   */this.mouseSource=mouseSource;/**
   * @private
   * @type {number|undefined}
   */this.firstTouchId_=undefined;/**
   * @private
   * @type {number}
   */this.clickCount_=0;/**
   * @private
   * @type {number|undefined}
   */this.resetId_=undefined;};_ol_.inherits(_ol_pointer_TouchSource_,_ol_pointer_EventSource_);/**
 * Mouse event timeout: This should be long enough to
 * ignore compat mouse events made by touch.
 * @const
 * @type {number}
 */_ol_pointer_TouchSource_.DEDUP_TIMEOUT=2500;/**
 * @const
 * @type {number}
 */_ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT=200;/**
 * @const
 * @type {string}
 */_ol_pointer_TouchSource_.POINTER_TYPE='touch';/**
 * @private
 * @param {Touch} inTouch The in touch.
 * @return {boolean} True, if this is the primary touch.
 */_ol_pointer_TouchSource_.prototype.isPrimaryTouch_=function(inTouch){return this.firstTouchId_===inTouch.identifier;};/**
 * Set primary touch if there are no pointers, or the only pointer is the mouse.
 * @param {Touch} inTouch The in touch.
 * @private
 */_ol_pointer_TouchSource_.prototype.setPrimaryTouch_=function(inTouch){var count=Object.keys(this.pointerMap).length;if(count===0||count===1&&_ol_pointer_MouseSource_.POINTER_ID.toString()in this.pointerMap){this.firstTouchId_=inTouch.identifier;this.cancelResetClickCount_();}};/**
 * @private
 * @param {Object} inPointer The in pointer object.
 */_ol_pointer_TouchSource_.prototype.removePrimaryPointer_=function(inPointer){if(inPointer.isPrimary){this.firstTouchId_=undefined;this.resetClickCount_();}};/**
 * @private
 */_ol_pointer_TouchSource_.prototype.resetClickCount_=function(){this.resetId_=setTimeout(this.resetClickCountHandler_.bind(this),_ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT);};/**
 * @private
 */_ol_pointer_TouchSource_.prototype.resetClickCountHandler_=function(){this.clickCount_=0;this.resetId_=undefined;};/**
 * @private
 */_ol_pointer_TouchSource_.prototype.cancelResetClickCount_=function(){if(this.resetId_!==undefined){clearTimeout(this.resetId_);}};/**
 * @private
 * @param {Event} browserEvent Browser event
 * @param {Touch} inTouch Touch event
 * @return {Object} A pointer object.
 */_ol_pointer_TouchSource_.prototype.touchToPointer_=function(browserEvent,inTouch){var e=this.dispatcher.cloneEvent(browserEvent,inTouch);// Spec specifies that pointerId 1 is reserved for Mouse.
// Touch identifiers can start at 0.
// Add 2 to the touch identifier for compatibility.
e.pointerId=inTouch.identifier+2;// TODO: check if this is necessary?
//e.target = findTarget(e);
e.bubbles=true;e.cancelable=true;e.detail=this.clickCount_;e.button=0;e.buttons=1;e.width=inTouch.webkitRadiusX||inTouch.radiusX||0;e.height=inTouch.webkitRadiusY||inTouch.radiusY||0;e.pressure=inTouch.webkitForce||inTouch.force||0.5;e.isPrimary=this.isPrimaryTouch_(inTouch);e.pointerType=_ol_pointer_TouchSource_.POINTER_TYPE;// make sure that the properties that are different for
// each `Touch` object are not copied from the BrowserEvent object
e.clientX=inTouch.clientX;e.clientY=inTouch.clientY;e.screenX=inTouch.screenX;e.screenY=inTouch.screenY;return e;};/**
 * @private
 * @param {Event} inEvent Touch event
 * @param {function(Event, Object)} inFunction In function.
 */_ol_pointer_TouchSource_.prototype.processTouches_=function(inEvent,inFunction){var touches=Array.prototype.slice.call(inEvent.changedTouches);var count=touches.length;function preventDefault(){inEvent.preventDefault();}var i,pointer;for(i=0;i<count;++i){pointer=this.touchToPointer_(inEvent,touches[i]);// forward touch preventDefaults
pointer.preventDefault=preventDefault;inFunction.call(this,inEvent,pointer);}};/**
 * @private
 * @param {TouchList} touchList The touch list.
 * @param {number} searchId Search identifier.
 * @return {boolean} True, if the `Touch` with the given id is in the list.
 */_ol_pointer_TouchSource_.prototype.findTouch_=function(touchList,searchId){var l=touchList.length;var touch;for(var i=0;i<l;i++){touch=touchList[i];if(touch.identifier===searchId){return true;}}return false;};/**
 * In some instances, a touchstart can happen without a touchend. This
 * leaves the pointermap in a broken state.
 * Therefore, on every touchstart, we remove the touches that did not fire a
 * touchend event.
 * To keep state globally consistent, we fire a pointercancel for
 * this "abandoned" touch
 *
 * @private
 * @param {Event} inEvent The in event.
 */_ol_pointer_TouchSource_.prototype.vacuumTouches_=function(inEvent){var touchList=inEvent.touches;// pointerMap.getCount() should be < touchList.length here,
// as the touchstart has not been processed yet.
var keys=Object.keys(this.pointerMap);var count=keys.length;if(count>=touchList.length){var d=[];var i,key,value;for(i=0;i<count;++i){key=keys[i];value=this.pointerMap[key];// Never remove pointerId == 1, which is mouse.
// Touch identifiers are 2 smaller than their pointerId, which is the
// index in pointermap.
if(key!=_ol_pointer_MouseSource_.POINTER_ID&&!this.findTouch_(touchList,key-2)){d.push(value.out);}}for(i=0;i<d.length;++i){this.cancelOut_(inEvent,d[i]);}}};/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_TouchSource_.prototype.touchstart=function(inEvent){this.vacuumTouches_(inEvent);this.setPrimaryTouch_(inEvent.changedTouches[0]);this.dedupSynthMouse_(inEvent);this.clickCount_++;this.processTouches_(inEvent,this.overDown_);};/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer object.
 */_ol_pointer_TouchSource_.prototype.overDown_=function(browserEvent,inPointer){this.pointerMap[inPointer.pointerId]={target:inPointer.target,out:inPointer,outTarget:inPointer.target};this.dispatcher.over(inPointer,browserEvent);this.dispatcher.enter(inPointer,browserEvent);this.dispatcher.down(inPointer,browserEvent);};/**
 * Handler for `touchmove`.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_TouchSource_.prototype.touchmove=function(inEvent){inEvent.preventDefault();this.processTouches_(inEvent,this.moveOverOut_);};/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */_ol_pointer_TouchSource_.prototype.moveOverOut_=function(browserEvent,inPointer){var event=inPointer;var pointer=this.pointerMap[event.pointerId];// a finger drifted off the screen, ignore it
if(!pointer){return;}var outEvent=pointer.out;var outTarget=pointer.outTarget;this.dispatcher.move(event,browserEvent);if(outEvent&&outTarget!==event.target){outEvent.relatedTarget=event.target;event.relatedTarget=outTarget;// recover from retargeting by shadow
outEvent.target=outTarget;if(event.target){this.dispatcher.leaveOut(outEvent,browserEvent);this.dispatcher.enterOver(event,browserEvent);}else{// clean up case when finger leaves the screen
event.target=outTarget;event.relatedTarget=null;this.cancelOut_(browserEvent,event);}}pointer.out=event;pointer.outTarget=event.target;};/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The event.
 */_ol_pointer_TouchSource_.prototype.touchend=function(inEvent){this.dedupSynthMouse_(inEvent);this.processTouches_(inEvent,this.upOut_);};/**
 * @private
 * @param {Event} browserEvent An event.
 * @param {Object} inPointer The inPointer object.
 */_ol_pointer_TouchSource_.prototype.upOut_=function(browserEvent,inPointer){this.dispatcher.up(inPointer,browserEvent);this.dispatcher.out(inPointer,browserEvent);this.dispatcher.leave(inPointer,browserEvent);this.cleanUpPointer_(inPointer);};/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The in event.
 */_ol_pointer_TouchSource_.prototype.touchcancel=function(inEvent){this.processTouches_(inEvent,this.cancelOut_);};/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */_ol_pointer_TouchSource_.prototype.cancelOut_=function(browserEvent,inPointer){this.dispatcher.cancel(inPointer,browserEvent);this.dispatcher.out(inPointer,browserEvent);this.dispatcher.leave(inPointer,browserEvent);this.cleanUpPointer_(inPointer);};/**
 * @private
 * @param {Object} inPointer The inPointer object.
 */_ol_pointer_TouchSource_.prototype.cleanUpPointer_=function(inPointer){delete this.pointerMap[inPointer.pointerId];this.removePrimaryPointer_(inPointer);};/**
 * Prevent synth mouse events from creating pointer events.
 *
 * @private
 * @param {Event} inEvent The in event.
 */_ol_pointer_TouchSource_.prototype.dedupSynthMouse_=function(inEvent){var lts=this.mouseSource.lastTouches;var t=inEvent.changedTouches[0];// only the primary finger will synth mouse events
if(this.isPrimaryTouch_(t)){// remember x/y of last touch
var lt=[t.clientX,t.clientY];lts.push(lt);setTimeout(function(){// remove touch after timeout
_ol_array_.remove(lts,lt);},_ol_pointer_TouchSource_.DEDUP_TIMEOUT);}};// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/**
 * @constructor
 * @extends {ol.events.EventTarget}
 * @param {Element|HTMLDocument} element Viewport element.
 */var _ol_pointer_PointerEventHandler_=function(element){_ol_events_EventTarget_.call(this);/**
   * @const
   * @private
   * @type {Element|HTMLDocument}
   */this.element_=element;/**
   * @const
   * @type {!Object.<string, Event|Object>}
   */this.pointerMap={};/**
   * @type {Object.<string, function(Event)>}
   * @private
   */this.eventMap_={};/**
   * @type {Array.<ol.pointer.EventSource>}
   * @private
   */this.eventSourceList_=[];this.registerSources();};_ol_.inherits(_ol_pointer_PointerEventHandler_,_ol_events_EventTarget_);/**
 * Set up the event sources (mouse, touch and native pointers)
 * that generate pointer events.
 */_ol_pointer_PointerEventHandler_.prototype.registerSources=function(){if(_ol_has_.POINTER){this.registerSource('native',new _ol_pointer_NativeSource_(this));}else if(_ol_has_.MSPOINTER){this.registerSource('ms',new _ol_pointer_MsSource_(this));}else{var mouseSource=new _ol_pointer_MouseSource_(this);this.registerSource('mouse',mouseSource);if(_ol_has_.TOUCH){this.registerSource('touch',new _ol_pointer_TouchSource_(this,mouseSource));}}// register events on the viewport element
this.register_();};/**
 * Add a new event source that will generate pointer events.
 *
 * @param {string} name A name for the event source
 * @param {ol.pointer.EventSource} source The source event.
 */_ol_pointer_PointerEventHandler_.prototype.registerSource=function(name,source){var s=source;var newEvents=s.getEvents();if(newEvents){newEvents.forEach(function(e){var handler=s.getHandlerForEvent(e);if(handler){this.eventMap_[e]=handler.bind(s);}},this);this.eventSourceList_.push(s);}};/**
 * Set up the events for all registered event sources.
 * @private
 */_ol_pointer_PointerEventHandler_.prototype.register_=function(){var l=this.eventSourceList_.length;var eventSource;for(var i=0;i<l;i++){eventSource=this.eventSourceList_[i];this.addEvents_(eventSource.getEvents());}};/**
 * Remove all registered events.
 * @private
 */_ol_pointer_PointerEventHandler_.prototype.unregister_=function(){var l=this.eventSourceList_.length;var eventSource;for(var i=0;i<l;i++){eventSource=this.eventSourceList_[i];this.removeEvents_(eventSource.getEvents());}};/**
 * Calls the right handler for a new event.
 * @private
 * @param {Event} inEvent Browser event.
 */_ol_pointer_PointerEventHandler_.prototype.eventHandler_=function(inEvent){var type=inEvent.type;var handler=this.eventMap_[type];if(handler){handler(inEvent);}};/**
 * Setup listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */_ol_pointer_PointerEventHandler_.prototype.addEvents_=function(events){events.forEach(function(eventName){_ol_events_.listen(this.element_,eventName,this.eventHandler_,this);},this);};/**
 * Unregister listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */_ol_pointer_PointerEventHandler_.prototype.removeEvents_=function(events){events.forEach(function(e){_ol_events_.unlisten(this.element_,e,this.eventHandler_,this);},this);};/**
 * Returns a snapshot of inEvent, with writable properties.
 *
 * @param {Event} event Browser event.
 * @param {Event|Touch} inEvent An event that contains
 *    properties to copy.
 * @return {Object} An object containing shallow copies of
 *    `inEvent`'s properties.
 */_ol_pointer_PointerEventHandler_.prototype.cloneEvent=function(event,inEvent){var eventCopy={},p;for(var i=0,ii=_ol_pointer_PointerEventHandler_.CLONE_PROPS.length;i<ii;i++){p=_ol_pointer_PointerEventHandler_.CLONE_PROPS[i][0];eventCopy[p]=event[p]||inEvent[p]||_ol_pointer_PointerEventHandler_.CLONE_PROPS[i][1];}return eventCopy;};// EVENTS
/**
 * Triggers a 'pointerdown' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.down=function(data,event){this.fireEvent(_ol_pointer_EventType_.POINTERDOWN,data,event);};/**
 * Triggers a 'pointermove' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.move=function(data,event){this.fireEvent(_ol_pointer_EventType_.POINTERMOVE,data,event);};/**
 * Triggers a 'pointerup' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.up=function(data,event){this.fireEvent(_ol_pointer_EventType_.POINTERUP,data,event);};/**
 * Triggers a 'pointerenter' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.enter=function(data,event){data.bubbles=false;this.fireEvent(_ol_pointer_EventType_.POINTERENTER,data,event);};/**
 * Triggers a 'pointerleave' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.leave=function(data,event){data.bubbles=false;this.fireEvent(_ol_pointer_EventType_.POINTERLEAVE,data,event);};/**
 * Triggers a 'pointerover' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.over=function(data,event){data.bubbles=true;this.fireEvent(_ol_pointer_EventType_.POINTEROVER,data,event);};/**
 * Triggers a 'pointerout' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.out=function(data,event){data.bubbles=true;this.fireEvent(_ol_pointer_EventType_.POINTEROUT,data,event);};/**
 * Triggers a 'pointercancel' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.cancel=function(data,event){this.fireEvent(_ol_pointer_EventType_.POINTERCANCEL,data,event);};/**
 * Triggers a combination of 'pointerout' and 'pointerleave' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.leaveOut=function(data,event){this.out(data,event);if(!this.contains_(data.target,data.relatedTarget)){this.leave(data,event);}};/**
 * Triggers a combination of 'pointerover' and 'pointerevents' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.enterOver=function(data,event){this.over(data,event);if(!this.contains_(data.target,data.relatedTarget)){this.enter(data,event);}};/**
 * @private
 * @param {Element} container The container element.
 * @param {Element} contained The contained element.
 * @return {boolean} Returns true if the container element
 *   contains the other element.
 */_ol_pointer_PointerEventHandler_.prototype.contains_=function(container,contained){if(!container||!contained){return false;}return container.contains(contained);};// EVENT CREATION AND TRACKING
/**
 * Creates a new Event of type `inType`, based on the information in
 * `data`.
 *
 * @param {string} inType A string representing the type of event to create.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} A PointerEvent of type `inType`.
 */_ol_pointer_PointerEventHandler_.prototype.makeEvent=function(inType,data,event){return new _ol_pointer_PointerEvent_(inType,event,data);};/**
 * Make and dispatch an event in one call.
 * @param {string} inType A string representing the type of event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */_ol_pointer_PointerEventHandler_.prototype.fireEvent=function(inType,data,event){var e=this.makeEvent(inType,data,event);this.dispatchEvent(e);};/**
 * Creates a pointer event from a native pointer event
 * and dispatches this event.
 * @param {Event} event A platform event with a target.
 */_ol_pointer_PointerEventHandler_.prototype.fireNativeEvent=function(event){var e=this.makeEvent(event.type,event,event);this.dispatchEvent(e);};/**
 * Wrap a native mouse event into a pointer event.
 * This proxy method is required for the legacy IE support.
 * @param {string} eventType The pointer event type.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} The wrapped event.
 */_ol_pointer_PointerEventHandler_.prototype.wrapMouseEvent=function(eventType,event){var pointerEvent=this.makeEvent(eventType,_ol_pointer_MouseSource_.prepareEvent(event,this),event);return pointerEvent;};/**
 * @inheritDoc
 */_ol_pointer_PointerEventHandler_.prototype.disposeInternal=function(){this.unregister_();_ol_events_EventTarget_.prototype.disposeInternal.call(this);};/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array.<Array>}
 */_ol_pointer_PointerEventHandler_.CLONE_PROPS=[// MouseEvent
['bubbles',false],['cancelable',false],['view',null],['detail',null],['screenX',0],['screenY',0],['clientX',0],['clientY',0],['ctrlKey',false],['altKey',false],['shiftKey',false],['metaKey',false],['button',0],['relatedTarget',null],// DOM Level 3
['buttons',0],// PointerEvent
['pointerId',0],['width',0],['height',0],['pressure',0],['tiltX',0],['tiltY',0],['pointerType',''],['hwTimestamp',0],['isPrimary',false],// event instance
['type',''],['target',null],['currentTarget',null],['which',0]];/**
 * @param {ol.Map} map The map with the viewport to listen to events on.
 * @param {number|undefined} moveTolerance The minimal distance the pointer must travel to trigger a move.
 * @constructor
 * @extends {ol.events.EventTarget}
 */var _ol_MapBrowserEventHandler_=function(map,moveTolerance){_ol_events_EventTarget_.call(this);/**
   * This is the element that we will listen to the real events on.
   * @type {ol.Map}
   * @private
   */this.map_=map;/**
   * @type {number}
   * @private
   */this.clickTimeoutId_=0;/**
   * @type {boolean}
   * @private
   */this.dragging_=false;/**
   * @type {!Array.<ol.EventsKey>}
   * @private
   */this.dragListenerKeys_=[];/**
   * @type {number}
   * @private
   */this.moveTolerance_=moveTolerance?moveTolerance*_ol_has_.DEVICE_PIXEL_RATIO:_ol_has_.DEVICE_PIXEL_RATIO;/**
   * The most recent "down" type event (or null if none have occurred).
   * Set on pointerdown.
   * @type {ol.pointer.PointerEvent}
   * @private
   */this.down_=null;var element=this.map_.getViewport();/**
   * @type {number}
   * @private
   */this.activePointers_=0;/**
   * @type {!Object.<number, boolean>}
   * @private
   */this.trackedTouches_={};/**
   * Event handler which generates pointer events for
   * the viewport element.
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */this.pointerEventHandler_=new _ol_pointer_PointerEventHandler_(element);/**
   * Event handler which generates pointer events for
   * the document (used when dragging).
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */this.documentPointerEventHandler_=null;/**
   * @type {?ol.EventsKey}
   * @private
   */this.pointerdownListenerKey_=_ol_events_.listen(this.pointerEventHandler_,_ol_pointer_EventType_.POINTERDOWN,this.handlePointerDown_,this);/**
   * @type {?ol.EventsKey}
   * @private
   */this.relayedListenerKey_=_ol_events_.listen(this.pointerEventHandler_,_ol_pointer_EventType_.POINTERMOVE,this.relayEvent_,this);};_ol_.inherits(_ol_MapBrowserEventHandler_,_ol_events_EventTarget_);/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.emulateClick_=function(pointerEvent){var newEvent=new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.CLICK,this.map_,pointerEvent);this.dispatchEvent(newEvent);if(this.clickTimeoutId_!==0){// double-click
clearTimeout(this.clickTimeoutId_);this.clickTimeoutId_=0;newEvent=new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.DBLCLICK,this.map_,pointerEvent);this.dispatchEvent(newEvent);}else{// click
this.clickTimeoutId_=setTimeout(function(){this.clickTimeoutId_=0;var newEvent=new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.SINGLECLICK,this.map_,pointerEvent);this.dispatchEvent(newEvent);}.bind(this),250);}};/**
 * Keeps track on how many pointers are currently active.
 *
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.updateActivePointers_=function(pointerEvent){var event=pointerEvent;if(event.type==_ol_MapBrowserEventType_.POINTERUP||event.type==_ol_MapBrowserEventType_.POINTERCANCEL){delete this.trackedTouches_[event.pointerId];}else if(event.type==_ol_MapBrowserEventType_.POINTERDOWN){this.trackedTouches_[event.pointerId]=true;}this.activePointers_=Object.keys(this.trackedTouches_).length;};/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.handlePointerUp_=function(pointerEvent){this.updateActivePointers_(pointerEvent);var newEvent=new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.POINTERUP,this.map_,pointerEvent);this.dispatchEvent(newEvent);// We emulate click events on left mouse button click, touch contact, and pen
// contact. isMouseActionButton returns true in these cases (evt.button is set
// to 0).
// See http://www.w3.org/TR/pointerevents/#button-states
if(!this.dragging_&&this.isMouseActionButton_(pointerEvent)){this.emulateClick_(this.down_);}if(this.activePointers_===0){this.dragListenerKeys_.forEach(_ol_events_.unlistenByKey);this.dragListenerKeys_.length=0;this.dragging_=false;this.down_=null;this.documentPointerEventHandler_.dispose();this.documentPointerEventHandler_=null;}};/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} If the left mouse button was pressed.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.isMouseActionButton_=function(pointerEvent){return pointerEvent.button===0;};/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.handlePointerDown_=function(pointerEvent){this.updateActivePointers_(pointerEvent);var newEvent=new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.POINTERDOWN,this.map_,pointerEvent);this.dispatchEvent(newEvent);this.down_=pointerEvent;if(this.dragListenerKeys_.length===0){/* Set up a pointer event handler on the `document`,
     * which is required when the pointer is moved outside
     * the viewport when dragging.
     */this.documentPointerEventHandler_=new _ol_pointer_PointerEventHandler_(document);this.dragListenerKeys_.push(_ol_events_.listen(this.documentPointerEventHandler_,_ol_MapBrowserEventType_.POINTERMOVE,this.handlePointerMove_,this),_ol_events_.listen(this.documentPointerEventHandler_,_ol_MapBrowserEventType_.POINTERUP,this.handlePointerUp_,this),/* Note that the listener for `pointercancel is set up on
       * `pointerEventHandler_` and not `documentPointerEventHandler_` like
       * the `pointerup` and `pointermove` listeners.
       *
       * The reason for this is the following: `TouchSource.vacuumTouches_()`
       * issues `pointercancel` events, when there was no `touchend` for a
       * `touchstart`. Now, let's say a first `touchstart` is registered on
       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
       * But `documentPointerEventHandler_` doesn't know about the first
       * `touchstart`. If there is no `touchend` for the `touchstart`, we can
       * only receive a `touchcancel` from `pointerEventHandler_`, because it is
       * only registered there.
       */_ol_events_.listen(this.pointerEventHandler_,_ol_MapBrowserEventType_.POINTERCANCEL,this.handlePointerUp_,this));}};/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.handlePointerMove_=function(pointerEvent){// Between pointerdown and pointerup, pointermove events are triggered.
// To avoid a 'false' touchmove event to be dispatched, we test if the pointer
// moved a significant distance.
if(this.isMoving_(pointerEvent)){this.dragging_=true;var newEvent=new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.POINTERDRAG,this.map_,pointerEvent,this.dragging_);this.dispatchEvent(newEvent);}// Some native android browser triggers mousemove events during small period
// of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
// https://code.google.com/p/android/issues/detail?id=19827
// ex: Galaxy Tab P3110 + Android 4.1.1
pointerEvent.preventDefault();};/**
 * Wrap and relay a pointer event.  Note that this requires that the type
 * string for the MapBrowserPointerEvent matches the PointerEvent type.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.relayEvent_=function(pointerEvent){var dragging=!!(this.down_&&this.isMoving_(pointerEvent));this.dispatchEvent(new _ol_MapBrowserPointerEvent_(pointerEvent.type,this.map_,pointerEvent,dragging));};/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} Is moving.
 * @private
 */_ol_MapBrowserEventHandler_.prototype.isMoving_=function(pointerEvent){return Math.abs(pointerEvent.clientX-this.down_.clientX)>this.moveTolerance_||Math.abs(pointerEvent.clientY-this.down_.clientY)>this.moveTolerance_;};/**
 * @inheritDoc
 */_ol_MapBrowserEventHandler_.prototype.disposeInternal=function(){if(this.relayedListenerKey_){_ol_events_.unlistenByKey(this.relayedListenerKey_);this.relayedListenerKey_=null;}if(this.pointerdownListenerKey_){_ol_events_.unlistenByKey(this.pointerdownListenerKey_);this.pointerdownListenerKey_=null;}this.dragListenerKeys_.forEach(_ol_events_.unlistenByKey);this.dragListenerKeys_.length=0;if(this.documentPointerEventHandler_){this.documentPointerEventHandler_.dispose();this.documentPointerEventHandler_=null;}if(this.pointerEventHandler_){this.pointerEventHandler_.dispose();this.pointerEventHandler_=null;}_ol_events_EventTarget_.prototype.disposeInternal.call(this);};/**
 * @enum {string}
 */var _ol_MapProperty_={LAYERGROUP:'layergroup',SIZE:'size',TARGET:'target',VIEW:'view'};/**
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * @see http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * @see http://hg.python.org/cpython/file/2.7/Lib/heapq.py
 *
 * @constructor
 * @param {function(T): number} priorityFunction Priority function.
 * @param {function(T): string} keyFunction Key function.
 * @struct
 * @template T
 */var _ol_structs_PriorityQueue_=function(priorityFunction,keyFunction){/**
   * @type {function(T): number}
   * @private
   */this.priorityFunction_=priorityFunction;/**
   * @type {function(T): string}
   * @private
   */this.keyFunction_=keyFunction;/**
   * @type {Array.<T>}
   * @private
   */this.elements_=[];/**
   * @type {Array.<number>}
   * @private
   */this.priorities_=[];/**
   * @type {Object.<string, boolean>}
   * @private
   */this.queuedElements_={};};/**
 * @const
 * @type {number}
 */_ol_structs_PriorityQueue_.DROP=Infinity;/**
 * FIXME empty description for jsdoc
 */_ol_structs_PriorityQueue_.prototype.clear=function(){this.elements_.length=0;this.priorities_.length=0;_ol_obj_.clear(this.queuedElements_);};/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */_ol_structs_PriorityQueue_.prototype.dequeue=function(){var elements=this.elements_;var priorities=this.priorities_;var element=elements[0];if(elements.length==1){elements.length=0;priorities.length=0;}else{elements[0]=elements.pop();priorities[0]=priorities.pop();this.siftUp_(0);}var elementKey=this.keyFunction_(element);delete this.queuedElements_[elementKey];return element;};/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */_ol_structs_PriorityQueue_.prototype.enqueue=function(element){_ol_asserts_.assert(!(this.keyFunction_(element)in this.queuedElements_),31);// Tried to enqueue an `element` that was already added to the queue
var priority=this.priorityFunction_(element);if(priority!=_ol_structs_PriorityQueue_.DROP){this.elements_.push(element);this.priorities_.push(priority);this.queuedElements_[this.keyFunction_(element)]=true;this.siftDown_(0,this.elements_.length-1);return true;}return false;};/**
 * @return {number} Count.
 */_ol_structs_PriorityQueue_.prototype.getCount=function(){return this.elements_.length;};/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */_ol_structs_PriorityQueue_.prototype.getLeftChildIndex_=function(index){return index*2+1;};/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */_ol_structs_PriorityQueue_.prototype.getRightChildIndex_=function(index){return index*2+2;};/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */_ol_structs_PriorityQueue_.prototype.getParentIndex_=function(index){return index-1>>1;};/**
 * Make this a heap. O(N).
 * @private
 */_ol_structs_PriorityQueue_.prototype.heapify_=function(){var i;for(i=(this.elements_.length>>1)-1;i>=0;i--){this.siftUp_(i);}};/**
 * @return {boolean} Is empty.
 */_ol_structs_PriorityQueue_.prototype.isEmpty=function(){return this.elements_.length===0;};/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */_ol_structs_PriorityQueue_.prototype.isKeyQueued=function(key){return key in this.queuedElements_;};/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */_ol_structs_PriorityQueue_.prototype.isQueued=function(element){return this.isKeyQueued(this.keyFunction_(element));};/**
 * @param {number} index The index of the node to move down.
 * @private
 */_ol_structs_PriorityQueue_.prototype.siftUp_=function(index){var elements=this.elements_;var priorities=this.priorities_;var count=elements.length;var element=elements[index];var priority=priorities[index];var startIndex=index;while(index<count>>1){var lIndex=this.getLeftChildIndex_(index);var rIndex=this.getRightChildIndex_(index);var smallerChildIndex=rIndex<count&&priorities[rIndex]<priorities[lIndex]?rIndex:lIndex;elements[index]=elements[smallerChildIndex];priorities[index]=priorities[smallerChildIndex];index=smallerChildIndex;}elements[index]=element;priorities[index]=priority;this.siftDown_(startIndex,index);};/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */_ol_structs_PriorityQueue_.prototype.siftDown_=function(startIndex,index){var elements=this.elements_;var priorities=this.priorities_;var element=elements[index];var priority=priorities[index];while(index>startIndex){var parentIndex=this.getParentIndex_(index);if(priorities[parentIndex]>priority){elements[index]=elements[parentIndex];priorities[index]=priorities[parentIndex];index=parentIndex;}else{break;}}elements[index]=element;priorities[index]=priority;};/**
 * FIXME empty description for jsdoc
 */_ol_structs_PriorityQueue_.prototype.reprioritize=function(){var priorityFunction=this.priorityFunction_;var elements=this.elements_;var priorities=this.priorities_;var index=0;var n=elements.length;var element,i,priority;for(i=0;i<n;++i){element=elements[i];priority=priorityFunction(element);if(priority==_ol_structs_PriorityQueue_.DROP){delete this.queuedElements_[this.keyFunction_(element)];}else{priorities[index]=priority;elements[index++]=element;}}elements.length=index;priorities.length=index;this.heapify_();};/**
 * @constructor
 * @extends {ol.structs.PriorityQueue.<Array>}
 * @param {ol.TilePriorityFunction} tilePriorityFunction
 *     Tile priority function.
 * @param {function(): ?} tileChangeCallback
 *     Function called on each tile change event.
 * @struct
 */var _ol_TileQueue_=function(tilePriorityFunction,tileChangeCallback){_ol_structs_PriorityQueue_.call(this,/**
       * @param {Array} element Element.
       * @return {number} Priority.
       */function(element){return tilePriorityFunction.apply(null,element);},/**
       * @param {Array} element Element.
       * @return {string} Key.
       */function(element){return(/** @type {ol.Tile} */element[0].getKey());});/**
   * @private
   * @type {function(): ?}
   */this.tileChangeCallback_=tileChangeCallback;/**
   * @private
   * @type {number}
   */this.tilesLoading_=0;/**
   * @private
   * @type {!Object.<string,boolean>}
   */this.tilesLoadingKeys_={};};_ol_.inherits(_ol_TileQueue_,_ol_structs_PriorityQueue_);/**
 * @inheritDoc
 */_ol_TileQueue_.prototype.enqueue=function(element){var added=_ol_structs_PriorityQueue_.prototype.enqueue.call(this,element);if(added){var tile=element[0];_ol_events_.listen(tile,_ol_events_EventType_.CHANGE,this.handleTileChange,this);}return added;};/**
 * @return {number} Number of tiles loading.
 */_ol_TileQueue_.prototype.getTilesLoading=function(){return this.tilesLoading_;};/**
 * @param {ol.events.Event} event Event.
 * @protected
 */_ol_TileQueue_.prototype.handleTileChange=function(event){var tile=/** @type {ol.Tile} */event.target;var state=tile.getState();if(state===_ol_TileState_.LOADED||state===_ol_TileState_.ERROR||state===_ol_TileState_.EMPTY||state===_ol_TileState_.ABORT){_ol_events_.unlisten(tile,_ol_events_EventType_.CHANGE,this.handleTileChange,this);var tileKey=tile.getKey();if(tileKey in this.tilesLoadingKeys_){delete this.tilesLoadingKeys_[tileKey];--this.tilesLoading_;}this.tileChangeCallback_();}};/**
 * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
 * @param {number} maxNewLoads Maximum number of new tiles to load.
 */_ol_TileQueue_.prototype.loadMoreTiles=function(maxTotalLoading,maxNewLoads){var newLoads=0;var abortedTiles=false;var state,tile,tileKey;while(this.tilesLoading_<maxTotalLoading&&newLoads<maxNewLoads&&this.getCount()>0){tile=/** @type {ol.Tile} */this.dequeue()[0];tileKey=tile.getKey();state=tile.getState();if(state===_ol_TileState_.ABORT){abortedTiles=true;}else if(state===_ol_TileState_.IDLE&&!(tileKey in this.tilesLoadingKeys_)){this.tilesLoadingKeys_[tileKey]=true;++this.tilesLoading_;++newLoads;tile.load();}}if(newLoads===0&&abortedTiles){// Do not stop the render loop when all wanted tiles were aborted due to
// a small, saturated tile cache.
this.tileChangeCallback_();}};// FIXME handle date line wrap
/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.AttributionOptions=} opt_options Attribution options.
 * @api
 */var _ol_control_Attribution_=function(opt_options){var options=opt_options?opt_options:{};/**
   * @private
   * @type {Element}
   */this.ulElement_=document.createElement('UL');/**
   * @private
   * @type {Element}
   */this.logoLi_=document.createElement('LI');this.ulElement_.appendChild(this.logoLi_);this.logoLi_.style.display='none';/**
   * @private
   * @type {boolean}
   */this.collapsed_=options.collapsed!==undefined?options.collapsed:true;/**
   * @private
   * @type {boolean}
   */this.collapsible_=options.collapsible!==undefined?options.collapsible:true;if(!this.collapsible_){this.collapsed_=false;}var className=options.className!==undefined?options.className:'ol-attribution';var tipLabel=options.tipLabel!==undefined?options.tipLabel:'Attributions';var collapseLabel=options.collapseLabel!==undefined?options.collapseLabel:'\u00BB';if(typeof collapseLabel==='string'){/**
     * @private
     * @type {Node}
     */this.collapseLabel_=document.createElement('span');this.collapseLabel_.textContent=collapseLabel;}else{this.collapseLabel_=collapseLabel;}var label=options.label!==undefined?options.label:'i';if(typeof label==='string'){/**
     * @private
     * @type {Node}
     */this.label_=document.createElement('span');this.label_.textContent=label;}else{this.label_=label;}var activeLabel=this.collapsible_&&!this.collapsed_?this.collapseLabel_:this.label_;var button=document.createElement('button');button.setAttribute('type','button');button.title=tipLabel;button.appendChild(activeLabel);_ol_events_.listen(button,_ol_events_EventType_.CLICK,this.handleClick_,this);var cssClasses=className+' '+_ol_css_.CLASS_UNSELECTABLE+' '+_ol_css_.CLASS_CONTROL+(this.collapsed_&&this.collapsible_?' ol-collapsed':'')+(this.collapsible_?'':' ol-uncollapsible');var element=document.createElement('div');element.className=cssClasses;element.appendChild(this.ulElement_);element.appendChild(button);var render=options.render?options.render:_ol_control_Attribution_.render;_ol_control_Control_.call(this,{element:element,render:render,target:options.target});/**
   * @private
   * @type {boolean}
   */this.renderedVisible_=true;/**
   * @private
   * @type {Object.<string, Element>}
   */this.attributionElements_={};/**
   * @private
   * @type {Object.<string, boolean>}
   */this.attributionElementRenderedVisible_={};/**
   * @private
   * @type {Object.<string, Element>}
   */this.logoElements_={};};_ol_.inherits(_ol_control_Attribution_,_ol_control_Control_);/**
 * @param {?olx.FrameState} frameState Frame state.
 * @return {Array.<Object.<string, ol.Attribution>>} Attributions.
 */_ol_control_Attribution_.prototype.getSourceAttributions=function(frameState){var i,ii,j,jj,tileRanges,source,sourceAttribution,sourceAttributionKey,sourceAttributions,sourceKey;var intersectsTileRange;var layerStatesArray=frameState.layerStatesArray;/** @type {Object.<string, ol.Attribution>} */var attributions=_ol_obj_.assign({},frameState.attributions);/** @type {Object.<string, ol.Attribution>} */var hiddenAttributions={};var uniqueAttributions={};var projection=/** @type {!ol.proj.Projection} */frameState.viewState.projection;for(i=0,ii=layerStatesArray.length;i<ii;i++){source=layerStatesArray[i].layer.getSource();if(!source){continue;}sourceKey=_ol_.getUid(source).toString();sourceAttributions=source.getAttributions();if(!sourceAttributions){continue;}for(j=0,jj=sourceAttributions.length;j<jj;j++){sourceAttribution=sourceAttributions[j];sourceAttributionKey=_ol_.getUid(sourceAttribution).toString();if(sourceAttributionKey in attributions){continue;}tileRanges=frameState.usedTiles[sourceKey];if(tileRanges){var tileGrid=/** @type {ol.source.Tile} */source.getTileGridForProjection(projection);intersectsTileRange=sourceAttribution.intersectsAnyTileRange(tileRanges,tileGrid,projection);}else{intersectsTileRange=false;}if(intersectsTileRange){if(sourceAttributionKey in hiddenAttributions){delete hiddenAttributions[sourceAttributionKey];}var html=sourceAttribution.getHTML();if(!(html in uniqueAttributions)){uniqueAttributions[html]=true;attributions[sourceAttributionKey]=sourceAttribution;}}else{hiddenAttributions[sourceAttributionKey]=sourceAttribution;}}}return[attributions,hiddenAttributions];};/**
 * Update the attribution element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Attribution}
 * @api
 */_ol_control_Attribution_.render=function(mapEvent){this.updateElement_(mapEvent.frameState);};/**
 * @private
 * @param {?olx.FrameState} frameState Frame state.
 */_ol_control_Attribution_.prototype.updateElement_=function(frameState){if(!frameState){if(this.renderedVisible_){this.element.style.display='none';this.renderedVisible_=false;}return;}var attributions=this.getSourceAttributions(frameState);/** @type {Object.<string, ol.Attribution>} */var visibleAttributions=attributions[0];/** @type {Object.<string, ol.Attribution>} */var hiddenAttributions=attributions[1];var attributionElement,attributionKey;for(attributionKey in this.attributionElements_){if(attributionKey in visibleAttributions){if(!this.attributionElementRenderedVisible_[attributionKey]){this.attributionElements_[attributionKey].style.display='';this.attributionElementRenderedVisible_[attributionKey]=true;}delete visibleAttributions[attributionKey];}else if(attributionKey in hiddenAttributions){if(this.attributionElementRenderedVisible_[attributionKey]){this.attributionElements_[attributionKey].style.display='none';delete this.attributionElementRenderedVisible_[attributionKey];}delete hiddenAttributions[attributionKey];}else{_ol_dom_.removeNode(this.attributionElements_[attributionKey]);delete this.attributionElements_[attributionKey];delete this.attributionElementRenderedVisible_[attributionKey];}}for(attributionKey in visibleAttributions){attributionElement=document.createElement('LI');attributionElement.innerHTML=visibleAttributions[attributionKey].getHTML();this.ulElement_.appendChild(attributionElement);this.attributionElements_[attributionKey]=attributionElement;this.attributionElementRenderedVisible_[attributionKey]=true;}for(attributionKey in hiddenAttributions){attributionElement=document.createElement('LI');attributionElement.innerHTML=hiddenAttributions[attributionKey].getHTML();attributionElement.style.display='none';this.ulElement_.appendChild(attributionElement);this.attributionElements_[attributionKey]=attributionElement;}var renderVisible=!_ol_obj_.isEmpty(this.attributionElementRenderedVisible_)||!_ol_obj_.isEmpty(frameState.logos);if(this.renderedVisible_!=renderVisible){this.element.style.display=renderVisible?'':'none';this.renderedVisible_=renderVisible;}if(renderVisible&&_ol_obj_.isEmpty(this.attributionElementRenderedVisible_)){this.element.classList.add('ol-logo-only');}else{this.element.classList.remove('ol-logo-only');}this.insertLogos_(frameState);};/**
 * @param {?olx.FrameState} frameState Frame state.
 * @private
 */_ol_control_Attribution_.prototype.insertLogos_=function(frameState){var logo;var logos=frameState.logos;var logoElements=this.logoElements_;for(logo in logoElements){if(!(logo in logos)){_ol_dom_.removeNode(logoElements[logo]);delete logoElements[logo];}}var image,logoElement,logoKey;for(logoKey in logos){var logoValue=logos[logoKey];if(logoValue instanceof HTMLElement){this.logoLi_.appendChild(logoValue);logoElements[logoKey]=logoValue;}if(!(logoKey in logoElements)){image=new Image();image.src=logoKey;if(logoValue===''){logoElement=image;}else{logoElement=document.createElement('a');logoElement.href=logoValue;logoElement.appendChild(image);}this.logoLi_.appendChild(logoElement);logoElements[logoKey]=logoElement;}}this.logoLi_.style.display=!_ol_obj_.isEmpty(logos)?'':'none';};/**
 * @param {Event} event The event to handle
 * @private
 */_ol_control_Attribution_.prototype.handleClick_=function(event){event.preventDefault();this.handleToggle_();};/**
 * @private
 */_ol_control_Attribution_.prototype.handleToggle_=function(){this.element.classList.toggle('ol-collapsed');if(this.collapsed_){_ol_dom_.replaceNode(this.collapseLabel_,this.label_);}else{_ol_dom_.replaceNode(this.label_,this.collapseLabel_);}this.collapsed_=!this.collapsed_;};/**
 * Return `true` if the attribution is collapsible, `false` otherwise.
 * @return {boolean} True if the widget is collapsible.
 * @api
 */_ol_control_Attribution_.prototype.getCollapsible=function(){return this.collapsible_;};/**
 * Set whether the attribution should be collapsible.
 * @param {boolean} collapsible True if the widget is collapsible.
 * @api
 */_ol_control_Attribution_.prototype.setCollapsible=function(collapsible){if(this.collapsible_===collapsible){return;}this.collapsible_=collapsible;this.element.classList.toggle('ol-uncollapsible');if(!collapsible&&this.collapsed_){this.handleToggle_();}};/**
 * Collapse or expand the attribution according to the passed parameter. Will
 * not do anything if the attribution isn't collapsible or if the current
 * collapsed state is already the one requested.
 * @param {boolean} collapsed True if the widget is collapsed.
 * @api
 */_ol_control_Attribution_.prototype.setCollapsed=function(collapsed){if(!this.collapsible_||this.collapsed_===collapsed){return;}this.handleToggle_();};/**
 * Return `true` when the attribution is currently collapsed or `false`
 * otherwise.
 * @return {boolean} True if the widget is collapsed.
 * @api
 */_ol_control_Attribution_.prototype.getCollapsed=function(){return this.collapsed_;};/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.RotateOptions=} opt_options Rotate options.
 * @api
 */var _ol_control_Rotate_=function(opt_options){var options=opt_options?opt_options:{};var className=options.className!==undefined?options.className:'ol-rotate';var label=options.label!==undefined?options.label:'\u21E7';/**
   * @type {Element}
   * @private
   */this.label_=null;if(typeof label==='string'){this.label_=document.createElement('span');this.label_.className='ol-compass';this.label_.textContent=label;}else{this.label_=label;this.label_.classList.add('ol-compass');}var tipLabel=options.tipLabel?options.tipLabel:'Reset rotation';var button=document.createElement('button');button.className=className+'-reset';button.setAttribute('type','button');button.title=tipLabel;button.appendChild(this.label_);_ol_events_.listen(button,_ol_events_EventType_.CLICK,_ol_control_Rotate_.prototype.handleClick_,this);var cssClasses=className+' '+_ol_css_.CLASS_UNSELECTABLE+' '+_ol_css_.CLASS_CONTROL;var element=document.createElement('div');element.className=cssClasses;element.appendChild(button);var render=options.render?options.render:_ol_control_Rotate_.render;this.callResetNorth_=options.resetNorth?options.resetNorth:undefined;_ol_control_Control_.call(this,{element:element,render:render,target:options.target});/**
   * @type {number}
   * @private
   */this.duration_=options.duration!==undefined?options.duration:250;/**
   * @type {boolean}
   * @private
   */this.autoHide_=options.autoHide!==undefined?options.autoHide:true;/**
   * @private
   * @type {number|undefined}
   */this.rotation_=undefined;if(this.autoHide_){this.element.classList.add(_ol_css_.CLASS_HIDDEN);}};_ol_.inherits(_ol_control_Rotate_,_ol_control_Control_);/**
 * @param {Event} event The event to handle
 * @private
 */_ol_control_Rotate_.prototype.handleClick_=function(event){event.preventDefault();if(this.callResetNorth_!==undefined){this.callResetNorth_();}else{this.resetNorth_();}};/**
 * @private
 */_ol_control_Rotate_.prototype.resetNorth_=function(){var map=this.getMap();var view=map.getView();if(!view){// the map does not have a view, so we can't act
// upon it
return;}if(view.getRotation()!==undefined){if(this.duration_>0){view.animate({rotation:0,duration:this.duration_,easing:_ol_easing_.easeOut});}else{view.setRotation(0);}}};/**
 * Update the rotate control element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Rotate}
 * @api
 */_ol_control_Rotate_.render=function(mapEvent){var frameState=mapEvent.frameState;if(!frameState){return;}var rotation=frameState.viewState.rotation;if(rotation!=this.rotation_){var transform='rotate('+rotation+'rad)';if(this.autoHide_){var contains=this.element.classList.contains(_ol_css_.CLASS_HIDDEN);if(!contains&&rotation===0){this.element.classList.add(_ol_css_.CLASS_HIDDEN);}else if(contains&&rotation!==0){this.element.classList.remove(_ol_css_.CLASS_HIDDEN);}}this.label_.style.msTransform=transform;this.label_.style.webkitTransform=transform;this.label_.style.transform=transform;}this.rotation_=rotation;};/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomOptions=} opt_options Zoom options.
 * @api
 */var _ol_control_Zoom_=function(opt_options){var options=opt_options?opt_options:{};var className=options.className!==undefined?options.className:'ol-zoom';var delta=options.delta!==undefined?options.delta:1;var zoomInLabel=options.zoomInLabel!==undefined?options.zoomInLabel:'+';var zoomOutLabel=options.zoomOutLabel!==undefined?options.zoomOutLabel:'\u2212';var zoomInTipLabel=options.zoomInTipLabel!==undefined?options.zoomInTipLabel:'Zoom in';var zoomOutTipLabel=options.zoomOutTipLabel!==undefined?options.zoomOutTipLabel:'Zoom out';var inElement=document.createElement('button');inElement.className=className+'-in';inElement.setAttribute('type','button');inElement.title=zoomInTipLabel;inElement.appendChild(typeof zoomInLabel==='string'?document.createTextNode(zoomInLabel):zoomInLabel);_ol_events_.listen(inElement,_ol_events_EventType_.CLICK,_ol_control_Zoom_.prototype.handleClick_.bind(this,delta));var outElement=document.createElement('button');outElement.className=className+'-out';outElement.setAttribute('type','button');outElement.title=zoomOutTipLabel;outElement.appendChild(typeof zoomOutLabel==='string'?document.createTextNode(zoomOutLabel):zoomOutLabel);_ol_events_.listen(outElement,_ol_events_EventType_.CLICK,_ol_control_Zoom_.prototype.handleClick_.bind(this,-delta));var cssClasses=className+' '+_ol_css_.CLASS_UNSELECTABLE+' '+_ol_css_.CLASS_CONTROL;var element=document.createElement('div');element.className=cssClasses;element.appendChild(inElement);element.appendChild(outElement);_ol_control_Control_.call(this,{element:element,target:options.target});/**
   * @type {number}
   * @private
   */this.duration_=options.duration!==undefined?options.duration:250;};_ol_.inherits(_ol_control_Zoom_,_ol_control_Control_);/**
 * @param {number} delta Zoom delta.
 * @param {Event} event The event to handle
 * @private
 */_ol_control_Zoom_.prototype.handleClick_=function(delta,event){event.preventDefault();this.zoomByDelta_(delta);};/**
 * @param {number} delta Zoom delta.
 * @private
 */_ol_control_Zoom_.prototype.zoomByDelta_=function(delta){var map=this.getMap();var view=map.getView();if(!view){// the map does not have a view, so we can't act
// upon it
return;}var currentResolution=view.getResolution();if(currentResolution){var newResolution=view.constrainResolution(currentResolution,delta);if(this.duration_>0){if(view.getAnimating()){view.cancelAnimations();}view.animate({resolution:newResolution,duration:this.duration_,easing:_ol_easing_.easeOut});}else{view.setResolution(newResolution);}}};var _ol_control_={};/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link ol.control.Zoom}
 * * {@link ol.control.Rotate}
 * * {@link ol.control.Attribution}
 *
 * @param {olx.control.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */_ol_control_.defaults=function(opt_options){var options=opt_options?opt_options:{};var controls=new _ol_Collection_();var zoomControl=options.zoom!==undefined?options.zoom:true;if(zoomControl){controls.push(new _ol_control_Zoom_(options.zoomOptions));}var rotateControl=options.rotate!==undefined?options.rotate:true;if(rotateControl){controls.push(new _ol_control_Rotate_(options.rotateOptions));}var attributionControl=options.attribution!==undefined?options.attribution:true;if(attributionControl){controls.push(new _ol_control_Attribution_(options.attributionOptions));}return controls;};/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @constructor
 * @param {number} decay Rate of decay (must be negative).
 * @param {number} minVelocity Minimum velocity (pixels/millisecond).
 * @param {number} delay Delay to consider to calculate the kinetic
 *     initial values (milliseconds).
 * @struct
 * @api
 */var _ol_Kinetic_=function(decay,minVelocity,delay){/**
   * @private
   * @type {number}
   */this.decay_=decay;/**
   * @private
   * @type {number}
   */this.minVelocity_=minVelocity;/**
   * @private
   * @type {number}
   */this.delay_=delay;/**
   * @private
   * @type {Array.<number>}
   */this.points_=[];/**
   * @private
   * @type {number}
   */this.angle_=0;/**
   * @private
   * @type {number}
   */this.initialVelocity_=0;};/**
 * FIXME empty description for jsdoc
 */_ol_Kinetic_.prototype.begin=function(){this.points_.length=0;this.angle_=0;this.initialVelocity_=0;};/**
 * @param {number} x X.
 * @param {number} y Y.
 */_ol_Kinetic_.prototype.update=function(x,y){this.points_.push(x,y,Date.now());};/**
 * @return {boolean} Whether we should do kinetic animation.
 */_ol_Kinetic_.prototype.end=function(){if(this.points_.length<6){// at least 2 points are required (i.e. there must be at least 6 elements
// in the array)
return false;}var delay=Date.now()-this.delay_;var lastIndex=this.points_.length-3;if(this.points_[lastIndex+2]<delay){// the last tracked point is too old, which means that the user stopped
// panning before releasing the map
return false;}// get the first point which still falls into the delay time
var firstIndex=lastIndex-3;while(firstIndex>0&&this.points_[firstIndex+2]>delay){firstIndex-=3;}var duration=this.points_[lastIndex+2]-this.points_[firstIndex+2];// we don't want a duration of 0 (divide by zero)
// we also make sure the user panned for a duration of at least one frame
// (1/60s) to compute sane displacement values
if(duration<1000/60){return false;}var dx=this.points_[lastIndex]-this.points_[firstIndex];var dy=this.points_[lastIndex+1]-this.points_[firstIndex+1];this.angle_=Math.atan2(dy,dx);this.initialVelocity_=Math.sqrt(dx*dx+dy*dy)/duration;return this.initialVelocity_>this.minVelocity_;};/**
 * @return {number} Total distance travelled (pixels).
 */_ol_Kinetic_.prototype.getDistance=function(){return(this.minVelocity_-this.initialVelocity_)/this.decay_;};/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */_ol_Kinetic_.prototype.getAngle=function(){return this.angle_;};/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.DoubleClickZoomOptions=} opt_options Options.
 * @api
 */var _ol_interaction_DoubleClickZoom_=function(opt_options){var options=opt_options?opt_options:{};/**
   * @private
   * @type {number}
   */this.delta_=options.delta?options.delta:1;_ol_interaction_Interaction_.call(this,{handleEvent:_ol_interaction_DoubleClickZoom_.handleEvent});/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:250;};_ol_.inherits(_ol_interaction_DoubleClickZoom_,_ol_interaction_Interaction_);/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.DoubleClickZoom}
 * @api
 */_ol_interaction_DoubleClickZoom_.handleEvent=function(mapBrowserEvent){var stopEvent=false;var browserEvent=mapBrowserEvent.originalEvent;if(mapBrowserEvent.type==_ol_MapBrowserEventType_.DBLCLICK){var map=mapBrowserEvent.map;var anchor=mapBrowserEvent.coordinate;var delta=browserEvent.shiftKey?-this.delta_:this.delta_;var view=map.getView();_ol_interaction_Interaction_.zoomByDelta(view,delta,anchor,this.duration_);mapBrowserEvent.preventDefault();stopEvent=true;}return!stopEvent;};/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragPanOptions=} opt_options Options.
 * @api
 */var _ol_interaction_DragPan_=function(opt_options){_ol_interaction_Pointer_.call(this,{handleDownEvent:_ol_interaction_DragPan_.handleDownEvent_,handleDragEvent:_ol_interaction_DragPan_.handleDragEvent_,handleUpEvent:_ol_interaction_DragPan_.handleUpEvent_});var options=opt_options?opt_options:{};/**
   * @private
   * @type {ol.Kinetic|undefined}
   */this.kinetic_=options.kinetic;/**
   * @type {ol.Pixel}
   */this.lastCentroid=null;/**
   * @type {number}
   */this.lastPointersCount_;/**
   * @private
   * @type {ol.EventsConditionType}
   */this.condition_=options.condition?options.condition:_ol_events_condition_.noModifierKeys;/**
   * @private
   * @type {boolean}
   */this.noKinetic_=false;};_ol_.inherits(_ol_interaction_DragPan_,_ol_interaction_Pointer_);/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragPan}
 * @private
 */_ol_interaction_DragPan_.handleDragEvent_=function(mapBrowserEvent){var targetPointers=this.targetPointers;var centroid=_ol_interaction_Pointer_.centroid(targetPointers);if(targetPointers.length==this.lastPointersCount_){if(this.kinetic_){this.kinetic_.update(centroid[0],centroid[1]);}if(this.lastCentroid){var deltaX=this.lastCentroid[0]-centroid[0];var deltaY=centroid[1]-this.lastCentroid[1];var map=mapBrowserEvent.map;var view=map.getView();var viewState=view.getState();var center=[deltaX,deltaY];_ol_coordinate_.scale(center,viewState.resolution);_ol_coordinate_.rotate(center,viewState.rotation);_ol_coordinate_.add(center,viewState.center);center=view.constrainCenter(center);view.setCenter(center);}}else if(this.kinetic_){// reset so we don't overestimate the kinetic energy after
// after one finger down, tiny drag, second finger down
this.kinetic_.begin();}this.lastCentroid=centroid;this.lastPointersCount_=targetPointers.length;};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */_ol_interaction_DragPan_.handleUpEvent_=function(mapBrowserEvent){var map=mapBrowserEvent.map;var view=map.getView();if(this.targetPointers.length===0){if(!this.noKinetic_&&this.kinetic_&&this.kinetic_.end()){var distance=this.kinetic_.getDistance();var angle=this.kinetic_.getAngle();var center=/** @type {!ol.Coordinate} */view.getCenter();var centerpx=map.getPixelFromCoordinate(center);var dest=map.getCoordinateFromPixel([centerpx[0]-distance*Math.cos(angle),centerpx[1]-distance*Math.sin(angle)]);view.animate({center:view.constrainCenter(dest),duration:500,easing:_ol_easing_.easeOut});}view.setHint(_ol_ViewHint_.INTERACTING,-1);return false;}else{if(this.kinetic_){// reset so we don't overestimate the kinetic energy after
// after one finger up, tiny drag, second finger up
this.kinetic_.begin();}this.lastCentroid=null;return true;}};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */_ol_interaction_DragPan_.handleDownEvent_=function(mapBrowserEvent){if(this.targetPointers.length>0&&this.condition_(mapBrowserEvent)){var map=mapBrowserEvent.map;var view=map.getView();this.lastCentroid=null;if(!this.handlingDownUpSequence){view.setHint(_ol_ViewHint_.INTERACTING,1);}// stop any current animation
if(view.getHints()[_ol_ViewHint_.ANIMATING]){view.setCenter(mapBrowserEvent.frameState.viewState.center);}if(this.kinetic_){this.kinetic_.begin();}// No kinetic as soon as more than one pointer on the screen is
// detected. This is to prevent nasty pans after pinch.
this.noKinetic_=this.targetPointers.length>1;return true;}else{return false;}};/**
 * @inheritDoc
 */_ol_interaction_DragPan_.prototype.shouldStopEvent=_ol_functions_.FALSE;/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragRotateOptions=} opt_options Options.
 * @api
 */var _ol_interaction_DragRotate_=function(opt_options){var options=opt_options?opt_options:{};_ol_interaction_Pointer_.call(this,{handleDownEvent:_ol_interaction_DragRotate_.handleDownEvent_,handleDragEvent:_ol_interaction_DragRotate_.handleDragEvent_,handleUpEvent:_ol_interaction_DragRotate_.handleUpEvent_});/**
   * @private
   * @type {ol.EventsConditionType}
   */this.condition_=options.condition?options.condition:_ol_events_condition_.altShiftKeysOnly;/**
   * @private
   * @type {number|undefined}
   */this.lastAngle_=undefined;/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:250;};_ol_.inherits(_ol_interaction_DragRotate_,_ol_interaction_Pointer_);/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragRotate}
 * @private
 */_ol_interaction_DragRotate_.handleDragEvent_=function(mapBrowserEvent){if(!_ol_events_condition_.mouseOnly(mapBrowserEvent)){return;}var map=mapBrowserEvent.map;var view=map.getView();if(view.getConstraints().rotation===_ol_RotationConstraint_.disable){return;}var size=map.getSize();var offset=mapBrowserEvent.pixel;var theta=Math.atan2(size[1]/2-offset[1],offset[0]-size[0]/2);if(this.lastAngle_!==undefined){var delta=theta-this.lastAngle_;var rotation=view.getRotation();_ol_interaction_Interaction_.rotateWithoutConstraints(view,rotation-delta);}this.lastAngle_=theta;};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */_ol_interaction_DragRotate_.handleUpEvent_=function(mapBrowserEvent){if(!_ol_events_condition_.mouseOnly(mapBrowserEvent)){return true;}var map=mapBrowserEvent.map;var view=map.getView();view.setHint(_ol_ViewHint_.INTERACTING,-1);var rotation=view.getRotation();_ol_interaction_Interaction_.rotate(view,rotation,undefined,this.duration_);return false;};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */_ol_interaction_DragRotate_.handleDownEvent_=function(mapBrowserEvent){if(!_ol_events_condition_.mouseOnly(mapBrowserEvent)){return false;}if(_ol_events_condition_.mouseActionButton(mapBrowserEvent)&&this.condition_(mapBrowserEvent)){var map=mapBrowserEvent.map;map.getView().setHint(_ol_ViewHint_.INTERACTING,1);this.lastAngle_=undefined;return true;}else{return false;}};/**
 * @inheritDoc
 */_ol_interaction_DragRotate_.prototype.shouldStopEvent=_ol_functions_.FALSE;// FIXME add rotation
/**
 * @constructor
 * @extends {ol.Disposable}
 * @param {string} className CSS class name.
 */var _ol_render_Box_=function(className){/**
   * @type {ol.geom.Polygon}
   * @private
   */this.geometry_=null;/**
   * @type {HTMLDivElement}
   * @private
   */this.element_=/** @type {HTMLDivElement} */document.createElement('div');this.element_.style.position='absolute';this.element_.className='ol-box '+className;/**
   * @private
   * @type {ol.Map}
   */this.map_=null;/**
   * @private
   * @type {ol.Pixel}
   */this.startPixel_=null;/**
   * @private
   * @type {ol.Pixel}
   */this.endPixel_=null;};_ol_.inherits(_ol_render_Box_,_ol_Disposable_);/**
 * @inheritDoc
 */_ol_render_Box_.prototype.disposeInternal=function(){this.setMap(null);};/**
 * @private
 */_ol_render_Box_.prototype.render_=function(){var startPixel=this.startPixel_;var endPixel=this.endPixel_;var px='px';var style=this.element_.style;style.left=Math.min(startPixel[0],endPixel[0])+px;style.top=Math.min(startPixel[1],endPixel[1])+px;style.width=Math.abs(endPixel[0]-startPixel[0])+px;style.height=Math.abs(endPixel[1]-startPixel[1])+px;};/**
 * @param {ol.Map} map Map.
 */_ol_render_Box_.prototype.setMap=function(map){if(this.map_){this.map_.getOverlayContainer().removeChild(this.element_);var style=this.element_.style;style.left=style.top=style.width=style.height='inherit';}this.map_=map;if(this.map_){this.map_.getOverlayContainer().appendChild(this.element_);}};/**
 * @param {ol.Pixel} startPixel Start pixel.
 * @param {ol.Pixel} endPixel End pixel.
 */_ol_render_Box_.prototype.setPixels=function(startPixel,endPixel){this.startPixel_=startPixel;this.endPixel_=endPixel;this.createOrUpdateGeometry();this.render_();};/**
 * Creates or updates the cached geometry.
 */_ol_render_Box_.prototype.createOrUpdateGeometry=function(){var startPixel=this.startPixel_;var endPixel=this.endPixel_;var pixels=[startPixel,[startPixel[0],endPixel[1]],endPixel,[endPixel[0],startPixel[1]]];var coordinates=pixels.map(this.map_.getCoordinateFromPixel,this.map_);// close the polygon
coordinates[4]=coordinates[0].slice();if(!this.geometry_){this.geometry_=new _ol_geom_Polygon_([coordinates]);}else{this.geometry_.setCoordinates([coordinates]);}};/**
 * @return {ol.geom.Polygon} Geometry.
 */_ol_render_Box_.prototype.getGeometry=function(){return this.geometry_;};// FIXME draw drag box
/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link ol.interaction.DragZoom} and
 * {@link ol.interaction.DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires ol.interaction.DragBox.Event
 * @param {olx.interaction.DragBoxOptions=} opt_options Options.
 * @api
 */var _ol_interaction_DragBox_=function(opt_options){_ol_interaction_Pointer_.call(this,{handleDownEvent:_ol_interaction_DragBox_.handleDownEvent_,handleDragEvent:_ol_interaction_DragBox_.handleDragEvent_,handleUpEvent:_ol_interaction_DragBox_.handleUpEvent_});var options=opt_options?opt_options:{};/**
   * @type {ol.render.Box}
   * @private
   */this.box_=new _ol_render_Box_(options.className||'ol-dragbox');/**
   * @type {number}
   * @private
   */this.minArea_=options.minArea!==undefined?options.minArea:64;/**
   * @type {ol.Pixel}
   * @private
   */this.startPixel_=null;/**
   * @private
   * @type {ol.EventsConditionType}
   */this.condition_=options.condition?options.condition:_ol_events_condition_.always;/**
   * @private
   * @type {ol.DragBoxEndConditionType}
   */this.boxEndCondition_=options.boxEndCondition?options.boxEndCondition:_ol_interaction_DragBox_.defaultBoxEndCondition;};_ol_.inherits(_ol_interaction_DragBox_,_ol_interaction_Pointer_);/**
 * The default condition for determining whether the boxend event
 * should fire.
 * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent
 *     leading to the box end.
 * @param {ol.Pixel} startPixel The starting pixel of the box.
 * @param {ol.Pixel} endPixel The end pixel of the box.
 * @return {boolean} Whether or not the boxend condition should be fired.
 * @this {ol.interaction.DragBox}
 */_ol_interaction_DragBox_.defaultBoxEndCondition=function(mapBrowserEvent,startPixel,endPixel){var width=endPixel[0]-startPixel[0];var height=endPixel[1]-startPixel[1];return width*width+height*height>=this.minArea_;};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragBox}
 * @private
 */_ol_interaction_DragBox_.handleDragEvent_=function(mapBrowserEvent){if(!_ol_events_condition_.mouseOnly(mapBrowserEvent)){return;}this.box_.setPixels(this.startPixel_,mapBrowserEvent.pixel);this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXDRAG,mapBrowserEvent.coordinate,mapBrowserEvent));};/**
 * Returns geometry of last drawn box.
 * @return {ol.geom.Polygon} Geometry.
 * @api
 */_ol_interaction_DragBox_.prototype.getGeometry=function(){return this.box_.getGeometry();};/**
 * To be overridden by child classes.
 * FIXME: use constructor option instead of relying on overriding.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @protected
 */_ol_interaction_DragBox_.prototype.onBoxEnd=_ol_.nullFunction;/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */_ol_interaction_DragBox_.handleUpEvent_=function(mapBrowserEvent){if(!_ol_events_condition_.mouseOnly(mapBrowserEvent)){return true;}this.box_.setMap(null);if(this.boxEndCondition_(mapBrowserEvent,this.startPixel_,mapBrowserEvent.pixel)){this.onBoxEnd(mapBrowserEvent);this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXEND,mapBrowserEvent.coordinate,mapBrowserEvent));}return false;};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */_ol_interaction_DragBox_.handleDownEvent_=function(mapBrowserEvent){if(!_ol_events_condition_.mouseOnly(mapBrowserEvent)){return false;}if(_ol_events_condition_.mouseActionButton(mapBrowserEvent)&&this.condition_(mapBrowserEvent)){this.startPixel_=mapBrowserEvent.pixel;this.box_.setMap(mapBrowserEvent.map);this.box_.setPixels(this.startPixel_,this.startPixel_);this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXSTART,mapBrowserEvent.coordinate,mapBrowserEvent));return true;}else{return false;}};/**
 * @enum {string}
 * @private
 */_ol_interaction_DragBox_.EventType_={/**
   * Triggered upon drag box start.
   * @event ol.interaction.DragBox.Event#boxstart
   * @api
   */BOXSTART:'boxstart',/**
   * Triggered on drag when box is active.
   * @event ol.interaction.DragBox.Event#boxdrag
   * @api
   */BOXDRAG:'boxdrag',/**
   * Triggered upon drag box end.
   * @event ol.interaction.DragBox.Event#boxend
   * @api
   */BOXEND:'boxend'};/**
 * @classdesc
 * Events emitted by {@link ol.interaction.DragBox} instances are instances of
 * this type.
 *
 * @param {string} type The event type.
 * @param {ol.Coordinate} coordinate The event coordinate.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.
 * @extends {ol.events.Event}
 * @constructor
 * @implements {oli.DragBoxEvent}
 */_ol_interaction_DragBox_.Event=function(type,coordinate,mapBrowserEvent){_ol_events_Event_.call(this,type);/**
   * The coordinate of the drag event.
   * @const
   * @type {ol.Coordinate}
   * @api
   */this.coordinate=coordinate;/**
   * @const
   * @type {ol.MapBrowserEvent}
   * @api
   */this.mapBrowserEvent=mapBrowserEvent;};_ol_.inherits(_ol_interaction_DragBox_.Event,_ol_events_Event_);/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api
 */var _ol_interaction_DragZoom_=function(opt_options){var options=opt_options?opt_options:{};var condition=options.condition?options.condition:_ol_events_condition_.shiftKeyOnly;/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:200;/**
   * @private
   * @type {boolean}
   */this.out_=options.out!==undefined?options.out:false;_ol_interaction_DragBox_.call(this,{condition:condition,className:options.className||'ol-dragzoom'});};_ol_.inherits(_ol_interaction_DragZoom_,_ol_interaction_DragBox_);/**
 * @inheritDoc
 */_ol_interaction_DragZoom_.prototype.onBoxEnd=function(){var map=this.getMap();var view=/** @type {!ol.View} */map.getView();var size=/** @type {!ol.Size} */map.getSize();var extent=this.getGeometry().getExtent();if(this.out_){var mapExtent=view.calculateExtent(size);var boxPixelExtent=_ol_extent_.createOrUpdateFromCoordinates([map.getPixelFromCoordinate(_ol_extent_.getBottomLeft(extent)),map.getPixelFromCoordinate(_ol_extent_.getTopRight(extent))]);var factor=view.getResolutionForExtent(boxPixelExtent,size);_ol_extent_.scaleFromCenter(mapExtent,1/factor);extent=mapExtent;}var resolution=view.constrainResolution(view.getResolutionForExtent(extent,size));var center=_ol_extent_.getCenter(extent);center=view.constrainCenter(center);view.animate({resolution:resolution,center:center,duration:this.duration_,easing:_ol_easing_.easeOut});};/**
 * @enum {number}
 * @const
 */var _ol_events_KeyCode_={LEFT:37,UP:38,RIGHT:39,DOWN:40};/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardZoom}.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.KeyboardPanOptions=} opt_options Options.
 * @api
 */var _ol_interaction_KeyboardPan_=function(opt_options){_ol_interaction_Interaction_.call(this,{handleEvent:_ol_interaction_KeyboardPan_.handleEvent});var options=opt_options||{};/**
   * @private
   * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.
   * @return {boolean} Combined condition result.
   */this.defaultCondition_=function(mapBrowserEvent){return _ol_events_condition_.noModifierKeys(mapBrowserEvent)&&_ol_events_condition_.targetNotEditable(mapBrowserEvent);};/**
   * @private
   * @type {ol.EventsConditionType}
   */this.condition_=options.condition!==undefined?options.condition:this.defaultCondition_;/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:100;/**
   * @private
   * @type {number}
   */this.pixelDelta_=options.pixelDelta!==undefined?options.pixelDelta:128;};_ol_.inherits(_ol_interaction_KeyboardPan_,_ol_interaction_Interaction_);/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardPan}
 * @api
 */_ol_interaction_KeyboardPan_.handleEvent=function(mapBrowserEvent){var stopEvent=false;if(mapBrowserEvent.type==_ol_events_EventType_.KEYDOWN){var keyEvent=mapBrowserEvent.originalEvent;var keyCode=keyEvent.keyCode;if(this.condition_(mapBrowserEvent)&&(keyCode==_ol_events_KeyCode_.DOWN||keyCode==_ol_events_KeyCode_.LEFT||keyCode==_ol_events_KeyCode_.RIGHT||keyCode==_ol_events_KeyCode_.UP)){var map=mapBrowserEvent.map;var view=map.getView();var mapUnitsDelta=view.getResolution()*this.pixelDelta_;var deltaX=0,deltaY=0;if(keyCode==_ol_events_KeyCode_.DOWN){deltaY=-mapUnitsDelta;}else if(keyCode==_ol_events_KeyCode_.LEFT){deltaX=-mapUnitsDelta;}else if(keyCode==_ol_events_KeyCode_.RIGHT){deltaX=mapUnitsDelta;}else{deltaY=mapUnitsDelta;}var delta=[deltaX,deltaY];_ol_coordinate_.rotate(delta,view.getRotation());_ol_interaction_Interaction_.pan(view,delta,this.duration_);mapBrowserEvent.preventDefault();stopEvent=true;}}return!stopEvent;};/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardPan}.
 *
 * @constructor
 * @param {olx.interaction.KeyboardZoomOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */var _ol_interaction_KeyboardZoom_=function(opt_options){_ol_interaction_Interaction_.call(this,{handleEvent:_ol_interaction_KeyboardZoom_.handleEvent});var options=opt_options?opt_options:{};/**
   * @private
   * @type {ol.EventsConditionType}
   */this.condition_=options.condition?options.condition:_ol_events_condition_.targetNotEditable;/**
   * @private
   * @type {number}
   */this.delta_=options.delta?options.delta:1;/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:100;};_ol_.inherits(_ol_interaction_KeyboardZoom_,_ol_interaction_Interaction_);/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardZoom}
 * @api
 */_ol_interaction_KeyboardZoom_.handleEvent=function(mapBrowserEvent){var stopEvent=false;if(mapBrowserEvent.type==_ol_events_EventType_.KEYDOWN||mapBrowserEvent.type==_ol_events_EventType_.KEYPRESS){var keyEvent=mapBrowserEvent.originalEvent;var charCode=keyEvent.charCode;if(this.condition_(mapBrowserEvent)&&(charCode=='+'.charCodeAt(0)||charCode=='-'.charCodeAt(0))){var map=mapBrowserEvent.map;var delta=charCode=='+'.charCodeAt(0)?this.delta_:-this.delta_;var view=map.getView();_ol_interaction_Interaction_.zoomByDelta(view,delta,undefined,this.duration_);mapBrowserEvent.preventDefault();stopEvent=true;}}return!stopEvent;};/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.MouseWheelZoomOptions=} opt_options Options.
 * @api
 */var _ol_interaction_MouseWheelZoom_=function(opt_options){_ol_interaction_Interaction_.call(this,{handleEvent:_ol_interaction_MouseWheelZoom_.handleEvent});var options=opt_options||{};/**
   * @private
   * @type {number}
   */this.delta_=0;/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:250;/**
   * @private
   * @type {number}
   */this.timeout_=options.timeout!==undefined?options.timeout:80;/**
   * @private
   * @type {boolean}
   */this.useAnchor_=options.useAnchor!==undefined?options.useAnchor:true;/**
   * @private
   * @type {boolean}
   */this.constrainResolution_=options.constrainResolution||false;/**
   * @private
   * @type {?ol.Coordinate}
   */this.lastAnchor_=null;/**
   * @private
   * @type {number|undefined}
   */this.startTime_=undefined;/**
   * @private
   * @type {number|undefined}
   */this.timeoutId_=undefined;/**
   * @private
   * @type {ol.interaction.MouseWheelZoom.Mode_|undefined}
   */this.mode_=undefined;/**
   * Trackpad events separated by this delay will be considered separate
   * interactions.
   * @type {number}
   */this.trackpadEventGap_=400;/**
   * @type {number|undefined}
   */this.trackpadTimeoutId_=undefined;/**
   * The number of delta values per zoom level
   * @private
   * @type {number}
   */this.trackpadDeltaPerZoom_=300;/**
   * The zoom factor by which scroll zooming is allowed to exceed the limits.
   * @private
   * @type {number}
   */this.trackpadZoomBuffer_=1.5;};_ol_.inherits(_ol_interaction_MouseWheelZoom_,_ol_interaction_Interaction_);/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * mousewheel-event) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} Allow event propagation.
 * @this {ol.interaction.MouseWheelZoom}
 * @api
 */_ol_interaction_MouseWheelZoom_.handleEvent=function(mapBrowserEvent){var type=mapBrowserEvent.type;if(type!==_ol_events_EventType_.WHEEL&&type!==_ol_events_EventType_.MOUSEWHEEL){return true;}mapBrowserEvent.preventDefault();var map=mapBrowserEvent.map;var wheelEvent=/** @type {WheelEvent} */mapBrowserEvent.originalEvent;if(this.useAnchor_){this.lastAnchor_=mapBrowserEvent.coordinate;}// Delta normalisation inspired by
// https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
var delta;if(mapBrowserEvent.type==_ol_events_EventType_.WHEEL){delta=wheelEvent.deltaY;if(_ol_has_.FIREFOX&&wheelEvent.deltaMode===WheelEvent.DOM_DELTA_PIXEL){delta/=_ol_has_.DEVICE_PIXEL_RATIO;}if(wheelEvent.deltaMode===WheelEvent.DOM_DELTA_LINE){delta*=40;}}else if(mapBrowserEvent.type==_ol_events_EventType_.MOUSEWHEEL){delta=-wheelEvent.wheelDeltaY;if(_ol_has_.SAFARI){delta/=3;}}if(delta===0){return false;}var now=Date.now();if(this.startTime_===undefined){this.startTime_=now;}if(!this.mode_||now-this.startTime_>this.trackpadEventGap_){this.mode_=Math.abs(delta)<4?_ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD:_ol_interaction_MouseWheelZoom_.Mode_.WHEEL;}if(this.mode_===_ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD){var view=map.getView();if(this.trackpadTimeoutId_){clearTimeout(this.trackpadTimeoutId_);}else{view.setHint(_ol_ViewHint_.INTERACTING,1);}this.trackpadTimeoutId_=setTimeout(this.decrementInteractingHint_.bind(this),this.trackpadEventGap_);var resolution=view.getResolution()*Math.pow(2,delta/this.trackpadDeltaPerZoom_);var minResolution=view.getMinResolution();var maxResolution=view.getMaxResolution();var rebound=0;if(resolution<minResolution){resolution=Math.max(resolution,minResolution/this.trackpadZoomBuffer_);rebound=1;}else if(resolution>maxResolution){resolution=Math.min(resolution,maxResolution*this.trackpadZoomBuffer_);rebound=-1;}if(this.lastAnchor_){var center=view.calculateCenterZoom(resolution,this.lastAnchor_);view.setCenter(view.constrainCenter(center));}view.setResolution(resolution);if(rebound===0&&this.constrainResolution_){view.animate({resolution:view.constrainResolution(resolution,delta>0?-1:1),easing:_ol_easing_.easeOut,anchor:this.lastAnchor_,duration:this.duration_});}if(rebound>0){view.animate({resolution:minResolution,easing:_ol_easing_.easeOut,anchor:this.lastAnchor_,duration:500});}else if(rebound<0){view.animate({resolution:maxResolution,easing:_ol_easing_.easeOut,anchor:this.lastAnchor_,duration:500});}this.startTime_=now;return false;}this.delta_+=delta;var timeLeft=Math.max(this.timeout_-(now-this.startTime_),0);clearTimeout(this.timeoutId_);this.timeoutId_=setTimeout(this.handleWheelZoom_.bind(this,map),timeLeft);return false;};/**
 * @private
 */_ol_interaction_MouseWheelZoom_.prototype.decrementInteractingHint_=function(){this.trackpadTimeoutId_=undefined;var view=this.getMap().getView();view.setHint(_ol_ViewHint_.INTERACTING,-1);};/**
 * @private
 * @param {ol.Map} map Map.
 */_ol_interaction_MouseWheelZoom_.prototype.handleWheelZoom_=function(map){var view=map.getView();if(view.getAnimating()){view.cancelAnimations();}var maxDelta=_ol_.MOUSEWHEELZOOM_MAXDELTA;var delta=_ol_math_.clamp(this.delta_,-maxDelta,maxDelta);_ol_interaction_Interaction_.zoomByDelta(view,-delta,this.lastAnchor_,this.duration_);this.mode_=undefined;this.delta_=0;this.lastAnchor_=null;this.startTime_=undefined;this.timeoutId_=undefined;};/**
 * Enable or disable using the mouse's location as an anchor when zooming
 * @param {boolean} useAnchor true to zoom to the mouse's location, false
 * to zoom to the center of the map
 * @api
 */_ol_interaction_MouseWheelZoom_.prototype.setMouseAnchor=function(useAnchor){this.useAnchor_=useAnchor;if(!useAnchor){this.lastAnchor_=null;}};/**
 * @enum {string}
 * @private
 */_ol_interaction_MouseWheelZoom_.Mode_={TRACKPAD:'trackpad',WHEEL:'wheel'};/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchRotateOptions=} opt_options Options.
 * @api
 */var _ol_interaction_PinchRotate_=function(opt_options){_ol_interaction_Pointer_.call(this,{handleDownEvent:_ol_interaction_PinchRotate_.handleDownEvent_,handleDragEvent:_ol_interaction_PinchRotate_.handleDragEvent_,handleUpEvent:_ol_interaction_PinchRotate_.handleUpEvent_});var options=opt_options||{};/**
   * @private
   * @type {ol.Coordinate}
   */this.anchor_=null;/**
   * @private
   * @type {number|undefined}
   */this.lastAngle_=undefined;/**
   * @private
   * @type {boolean}
   */this.rotating_=false;/**
   * @private
   * @type {number}
   */this.rotationDelta_=0.0;/**
   * @private
   * @type {number}
   */this.threshold_=options.threshold!==undefined?options.threshold:0.3;/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:250;};_ol_.inherits(_ol_interaction_PinchRotate_,_ol_interaction_Pointer_);/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchRotate}
 * @private
 */_ol_interaction_PinchRotate_.handleDragEvent_=function(mapBrowserEvent){var rotationDelta=0.0;var touch0=this.targetPointers[0];var touch1=this.targetPointers[1];// angle between touches
var angle=Math.atan2(touch1.clientY-touch0.clientY,touch1.clientX-touch0.clientX);if(this.lastAngle_!==undefined){var delta=angle-this.lastAngle_;this.rotationDelta_+=delta;if(!this.rotating_&&Math.abs(this.rotationDelta_)>this.threshold_){this.rotating_=true;}rotationDelta=delta;}this.lastAngle_=angle;var map=mapBrowserEvent.map;var view=map.getView();if(view.getConstraints().rotation===_ol_RotationConstraint_.disable){return;}// rotate anchor point.
// FIXME: should be the intersection point between the lines:
//     touch0,touch1 and previousTouch0,previousTouch1
var viewportPosition=map.getViewport().getBoundingClientRect();var centroid=_ol_interaction_Pointer_.centroid(this.targetPointers);centroid[0]-=viewportPosition.left;centroid[1]-=viewportPosition.top;this.anchor_=map.getCoordinateFromPixel(centroid);// rotate
if(this.rotating_){var rotation=view.getRotation();map.render();_ol_interaction_Interaction_.rotateWithoutConstraints(view,rotation+rotationDelta,this.anchor_);}};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */_ol_interaction_PinchRotate_.handleUpEvent_=function(mapBrowserEvent){if(this.targetPointers.length<2){var map=mapBrowserEvent.map;var view=map.getView();view.setHint(_ol_ViewHint_.INTERACTING,-1);if(this.rotating_){var rotation=view.getRotation();_ol_interaction_Interaction_.rotate(view,rotation,this.anchor_,this.duration_);}return false;}else{return true;}};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */_ol_interaction_PinchRotate_.handleDownEvent_=function(mapBrowserEvent){if(this.targetPointers.length>=2){var map=mapBrowserEvent.map;this.anchor_=null;this.lastAngle_=undefined;this.rotating_=false;this.rotationDelta_=0.0;if(!this.handlingDownUpSequence){map.getView().setHint(_ol_ViewHint_.INTERACTING,1);}return true;}else{return false;}};/**
 * @inheritDoc
 */_ol_interaction_PinchRotate_.prototype.shouldStopEvent=_ol_functions_.FALSE;/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchZoomOptions=} opt_options Options.
 * @api
 */var _ol_interaction_PinchZoom_=function(opt_options){_ol_interaction_Pointer_.call(this,{handleDownEvent:_ol_interaction_PinchZoom_.handleDownEvent_,handleDragEvent:_ol_interaction_PinchZoom_.handleDragEvent_,handleUpEvent:_ol_interaction_PinchZoom_.handleUpEvent_});var options=opt_options?opt_options:{};/**
   * @private
   * @type {boolean}
   */this.constrainResolution_=options.constrainResolution||false;/**
   * @private
   * @type {ol.Coordinate}
   */this.anchor_=null;/**
   * @private
   * @type {number}
   */this.duration_=options.duration!==undefined?options.duration:400;/**
   * @private
   * @type {number|undefined}
   */this.lastDistance_=undefined;/**
   * @private
   * @type {number}
   */this.lastScaleDelta_=1;};_ol_.inherits(_ol_interaction_PinchZoom_,_ol_interaction_Pointer_);/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchZoom}
 * @private
 */_ol_interaction_PinchZoom_.handleDragEvent_=function(mapBrowserEvent){var scaleDelta=1.0;var touch0=this.targetPointers[0];var touch1=this.targetPointers[1];var dx=touch0.clientX-touch1.clientX;var dy=touch0.clientY-touch1.clientY;// distance between touches
var distance=Math.sqrt(dx*dx+dy*dy);if(this.lastDistance_!==undefined){scaleDelta=this.lastDistance_/distance;}this.lastDistance_=distance;var map=mapBrowserEvent.map;var view=map.getView();var resolution=view.getResolution();var maxResolution=view.getMaxResolution();var minResolution=view.getMinResolution();var newResolution=resolution*scaleDelta;if(newResolution>maxResolution){scaleDelta=maxResolution/resolution;newResolution=maxResolution;}else if(newResolution<minResolution){scaleDelta=minResolution/resolution;newResolution=minResolution;}if(scaleDelta!=1.0){this.lastScaleDelta_=scaleDelta;}// scale anchor point.
var viewportPosition=map.getViewport().getBoundingClientRect();var centroid=_ol_interaction_Pointer_.centroid(this.targetPointers);centroid[0]-=viewportPosition.left;centroid[1]-=viewportPosition.top;this.anchor_=map.getCoordinateFromPixel(centroid);// scale, bypass the resolution constraint
map.render();_ol_interaction_Interaction_.zoomWithoutConstraints(view,newResolution,this.anchor_);};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */_ol_interaction_PinchZoom_.handleUpEvent_=function(mapBrowserEvent){if(this.targetPointers.length<2){var map=mapBrowserEvent.map;var view=map.getView();view.setHint(_ol_ViewHint_.INTERACTING,-1);var resolution=view.getResolution();if(this.constrainResolution_||resolution<view.getMinResolution()||resolution>view.getMaxResolution()){// Zoom to final resolution, with an animation, and provide a
// direction not to zoom out/in if user was pinching in/out.
// Direction is > 0 if pinching out, and < 0 if pinching in.
var direction=this.lastScaleDelta_-1;_ol_interaction_Interaction_.zoom(view,resolution,this.anchor_,this.duration_,direction);}return false;}else{return true;}};/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */_ol_interaction_PinchZoom_.handleDownEvent_=function(mapBrowserEvent){if(this.targetPointers.length>=2){var map=mapBrowserEvent.map;this.anchor_=null;this.lastDistance_=undefined;this.lastScaleDelta_=1;if(!this.handlingDownUpSequence){map.getView().setHint(_ol_ViewHint_.INTERACTING,1);}return true;}else{return false;}};/**
 * @inheritDoc
 */_ol_interaction_PinchZoom_.prototype.shouldStopEvent=_ol_functions_.FALSE;var _ol_interaction_={};/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link ol.interaction.Interaction} instances and insert them into a
 * {@link ol.Collection} in the order you want before creating your
 * {@link ol.Map} instance. The default set of interactions, in sequence, is:
 * * {@link ol.interaction.DragRotate}
 * * {@link ol.interaction.DoubleClickZoom}
 * * {@link ol.interaction.DragPan}
 * * {@link ol.interaction.PinchRotate}
 * * {@link ol.interaction.PinchZoom}
 * * {@link ol.interaction.KeyboardPan}
 * * {@link ol.interaction.KeyboardZoom}
 * * {@link ol.interaction.MouseWheelZoom}
 * * {@link ol.interaction.DragZoom}
 *
 * @param {olx.interaction.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.interaction.Interaction>} A collection of
 * interactions to be used with the ol.Map constructor's interactions option.
 * @api
 */_ol_interaction_.defaults=function(opt_options){var options=opt_options?opt_options:{};var interactions=new _ol_Collection_();var kinetic=new _ol_Kinetic_(-0.005,0.05,100);var altShiftDragRotate=options.altShiftDragRotate!==undefined?options.altShiftDragRotate:true;if(altShiftDragRotate){interactions.push(new _ol_interaction_DragRotate_());}var doubleClickZoom=options.doubleClickZoom!==undefined?options.doubleClickZoom:true;if(doubleClickZoom){interactions.push(new _ol_interaction_DoubleClickZoom_({delta:options.zoomDelta,duration:options.zoomDuration}));}var dragPan=options.dragPan!==undefined?options.dragPan:true;if(dragPan){interactions.push(new _ol_interaction_DragPan_({kinetic:kinetic}));}var pinchRotate=options.pinchRotate!==undefined?options.pinchRotate:true;if(pinchRotate){interactions.push(new _ol_interaction_PinchRotate_());}var pinchZoom=options.pinchZoom!==undefined?options.pinchZoom:true;if(pinchZoom){interactions.push(new _ol_interaction_PinchZoom_({constrainResolution:options.constrainResolution,duration:options.zoomDuration}));}var keyboard=options.keyboard!==undefined?options.keyboard:true;if(keyboard){interactions.push(new _ol_interaction_KeyboardPan_());interactions.push(new _ol_interaction_KeyboardZoom_({delta:options.zoomDelta,duration:options.zoomDuration}));}var mouseWheelZoom=options.mouseWheelZoom!==undefined?options.mouseWheelZoom:true;if(mouseWheelZoom){interactions.push(new _ol_interaction_MouseWheelZoom_({constrainResolution:options.constrainResolution,duration:options.zoomDuration}));}var shiftDragZoom=options.shiftDragZoom!==undefined?options.shiftDragZoom:true;if(shiftDragZoom){interactions.push(new _ol_interaction_DragZoom_({duration:options.zoomDuration}));}return interactions;};/**
 * @classdesc
 * A {@link ol.Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @constructor
 * @extends {ol.layer.Base}
 * @param {olx.layer.GroupOptions=} opt_options Layer options.
 * @api
 */var _ol_layer_Group_=function(opt_options){var options=opt_options||{};var baseOptions=/** @type {olx.layer.GroupOptions} */_ol_obj_.assign({},options);delete baseOptions.layers;var layers=options.layers;_ol_layer_Base_.call(this,baseOptions);/**
   * @private
   * @type {Array.<ol.EventsKey>}
   */this.layersListenerKeys_=[];/**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */this.listenerKeys_={};_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_layer_Group_.Property_.LAYERS),this.handleLayersChanged_,this);if(layers){if(Array.isArray(layers)){layers=new _ol_Collection_(layers.slice(),{unique:true});}else{_ol_asserts_.assert(layers instanceof _ol_Collection_,43);// Expected `layers` to be an array or an `ol.Collection`
layers=layers;}}else{layers=new _ol_Collection_(undefined,{unique:true});}this.setLayers(layers);};_ol_.inherits(_ol_layer_Group_,_ol_layer_Base_);/**
 * @inheritDoc
 */_ol_layer_Group_.prototype.createRenderer=function(mapRenderer){};/**
 * @private
 */_ol_layer_Group_.prototype.handleLayerChange_=function(){this.changed();};/**
 * @param {ol.events.Event} event Event.
 * @private
 */_ol_layer_Group_.prototype.handleLayersChanged_=function(event){this.layersListenerKeys_.forEach(_ol_events_.unlistenByKey);this.layersListenerKeys_.length=0;var layers=this.getLayers();this.layersListenerKeys_.push(_ol_events_.listen(layers,_ol_CollectionEventType_.ADD,this.handleLayersAdd_,this),_ol_events_.listen(layers,_ol_CollectionEventType_.REMOVE,this.handleLayersRemove_,this));for(var id in this.listenerKeys_){this.listenerKeys_[id].forEach(_ol_events_.unlistenByKey);}_ol_obj_.clear(this.listenerKeys_);var layersArray=layers.getArray();var i,ii,layer;for(i=0,ii=layersArray.length;i<ii;i++){layer=layersArray[i];this.listenerKeys_[_ol_.getUid(layer).toString()]=[_ol_events_.listen(layer,_ol_ObjectEventType_.PROPERTYCHANGE,this.handleLayerChange_,this),_ol_events_.listen(layer,_ol_events_EventType_.CHANGE,this.handleLayerChange_,this)];}this.changed();};/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */_ol_layer_Group_.prototype.handleLayersAdd_=function(collectionEvent){var layer=/** @type {ol.layer.Base} */collectionEvent.element;var key=_ol_.getUid(layer).toString();this.listenerKeys_[key]=[_ol_events_.listen(layer,_ol_ObjectEventType_.PROPERTYCHANGE,this.handleLayerChange_,this),_ol_events_.listen(layer,_ol_events_EventType_.CHANGE,this.handleLayerChange_,this)];this.changed();};/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */_ol_layer_Group_.prototype.handleLayersRemove_=function(collectionEvent){var layer=/** @type {ol.layer.Base} */collectionEvent.element;var key=_ol_.getUid(layer).toString();this.listenerKeys_[key].forEach(_ol_events_.unlistenByKey);delete this.listenerKeys_[key];this.changed();};/**
 * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @return {!ol.Collection.<ol.layer.Base>} Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */_ol_layer_Group_.prototype.getLayers=function(){return(/** @type {!ol.Collection.<ol.layer.Base>} */this.get(_ol_layer_Group_.Property_.LAYERS));};/**
 * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @param {!ol.Collection.<ol.layer.Base>} layers Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */_ol_layer_Group_.prototype.setLayers=function(layers){this.set(_ol_layer_Group_.Property_.LAYERS,layers);};/**
 * @inheritDoc
 */_ol_layer_Group_.prototype.getLayersArray=function(opt_array){var array=opt_array!==undefined?opt_array:[];this.getLayers().forEach(function(layer){layer.getLayersArray(array);});return array;};/**
 * @inheritDoc
 */_ol_layer_Group_.prototype.getLayerStatesArray=function(opt_states){var states=opt_states!==undefined?opt_states:[];var pos=states.length;this.getLayers().forEach(function(layer){layer.getLayerStatesArray(states);});var ownLayerState=this.getLayerState();var i,ii,layerState;for(i=pos,ii=states.length;i<ii;i++){layerState=states[i];layerState.opacity*=ownLayerState.opacity;layerState.visible=layerState.visible&&ownLayerState.visible;layerState.maxResolution=Math.min(layerState.maxResolution,ownLayerState.maxResolution);layerState.minResolution=Math.max(layerState.minResolution,ownLayerState.minResolution);if(ownLayerState.extent!==undefined){if(layerState.extent!==undefined){layerState.extent=_ol_extent_.getIntersection(layerState.extent,ownLayerState.extent);}else{layerState.extent=ownLayerState.extent;}}}return states;};/**
 * @inheritDoc
 */_ol_layer_Group_.prototype.getSourceState=function(){return _ol_source_State_.READY;};/**
 * @enum {string}
 * @private
 */_ol_layer_Group_.Property_={LAYERS:'layers'};/**
 * @constructor
 * @abstract
 * @extends {ol.Disposable}
 * @param {Element} container Container.
 * @param {ol.Map} map Map.
 * @struct
 */var _ol_renderer_Map_=function(container,map){_ol_Disposable_.call(this);/**
   * @private
   * @type {ol.Map}
   */this.map_=map;/**
   * @private
   * @type {Object.<string, ol.renderer.Layer>}
   */this.layerRenderers_={};/**
   * @private
   * @type {Object.<string, ol.EventsKey>}
   */this.layerRendererListeners_={};};_ol_.inherits(_ol_renderer_Map_,_ol_Disposable_);/**
 * @param {olx.FrameState} frameState FrameState.
 * @protected
 */_ol_renderer_Map_.prototype.calculateMatrices2D=function(frameState){var viewState=frameState.viewState;var coordinateToPixelTransform=frameState.coordinateToPixelTransform;var pixelToCoordinateTransform=frameState.pixelToCoordinateTransform;_ol_transform_.compose(coordinateToPixelTransform,frameState.size[0]/2,frameState.size[1]/2,1/viewState.resolution,-1/viewState.resolution,-viewState.rotation,-viewState.center[0],-viewState.center[1]);_ol_transform_.invert(_ol_transform_.setFromArray(pixelToCoordinateTransform,coordinateToPixelTransform));};/**
 * @inheritDoc
 */_ol_renderer_Map_.prototype.disposeInternal=function(){for(var id in this.layerRenderers_){this.layerRenderers_[id].dispose();}};/**
 * @param {ol.Map} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */_ol_renderer_Map_.expireIconCache_=function(map,frameState){var cache=_ol_style_.iconImageCache;cache.expire();};/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */_ol_renderer_Map_.prototype.forEachFeatureAtCoordinate=function(coordinate,frameState,hitTolerance,callback,thisArg,layerFilter,thisArg2){var result;var viewState=frameState.viewState;var viewResolution=viewState.resolution;/**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @param {ol.layer.Layer} layer Layer.
   * @return {?} Callback result.
   */function forEachFeatureAtCoordinate(feature,layer){var key=_ol_.getUid(feature).toString();var managed=frameState.layerStates[_ol_.getUid(layer)].managed;if(!(key in frameState.skippedFeatureUids&&!managed)){return callback.call(thisArg,feature,managed?layer:null);}}var projection=viewState.projection;var translatedCoordinate=coordinate;if(projection.canWrapX()){var projectionExtent=projection.getExtent();var worldWidth=_ol_extent_.getWidth(projectionExtent);var x=coordinate[0];if(x<projectionExtent[0]||x>projectionExtent[2]){var worldsAway=Math.ceil((projectionExtent[0]-x)/worldWidth);translatedCoordinate=[x+worldWidth*worldsAway,coordinate[1]];}}var layerStates=frameState.layerStatesArray;var numLayers=layerStates.length;var i;for(i=numLayers-1;i>=0;--i){var layerState=layerStates[i];var layer=layerState.layer;if(_ol_layer_Layer_.visibleAtResolution(layerState,viewResolution)&&layerFilter.call(thisArg2,layer)){var layerRenderer=this.getLayerRenderer(layer);if(layer.getSource()){result=layerRenderer.forEachFeatureAtCoordinate(layer.getSource().getWrapX()?translatedCoordinate:coordinate,frameState,hitTolerance,forEachFeatureAtCoordinate,thisArg);}if(result){return result;}}}return undefined;};/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */_ol_renderer_Map_.prototype.forEachLayerAtPixel=function(pixel,frameState,callback,thisArg,layerFilter,thisArg2){};/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
 * @return {boolean} Is there a feature at the given coordinate?
 * @template U
 */_ol_renderer_Map_.prototype.hasFeatureAtCoordinate=function(coordinate,frameState,hitTolerance,layerFilter,thisArg){var hasFeature=this.forEachFeatureAtCoordinate(coordinate,frameState,hitTolerance,_ol_functions_.TRUE,this,layerFilter,thisArg);return hasFeature!==undefined;};/**
 * @param {ol.layer.Layer} layer Layer.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */_ol_renderer_Map_.prototype.getLayerRenderer=function(layer){var layerKey=_ol_.getUid(layer).toString();if(layerKey in this.layerRenderers_){return this.layerRenderers_[layerKey];}else{var layerRenderer=layer.createRenderer(this);this.layerRenderers_[layerKey]=layerRenderer;this.layerRendererListeners_[layerKey]=_ol_events_.listen(layerRenderer,_ol_events_EventType_.CHANGE,this.handleLayerRendererChange_,this);return layerRenderer;}};/**
 * @param {string} layerKey Layer key.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */_ol_renderer_Map_.prototype.getLayerRendererByKey=function(layerKey){return this.layerRenderers_[layerKey];};/**
 * @protected
 * @return {Object.<string, ol.renderer.Layer>} Layer renderers.
 */_ol_renderer_Map_.prototype.getLayerRenderers=function(){return this.layerRenderers_;};/**
 * @return {ol.Map} Map.
 */_ol_renderer_Map_.prototype.getMap=function(){return this.map_;};/**
 * @abstract
 * @return {string} Type
 */_ol_renderer_Map_.prototype.getType=function(){};/**
 * Handle changes in a layer renderer.
 * @private
 */_ol_renderer_Map_.prototype.handleLayerRendererChange_=function(){this.map_.render();};/**
 * @param {string} layerKey Layer key.
 * @return {ol.renderer.Layer} Layer renderer.
 * @private
 */_ol_renderer_Map_.prototype.removeLayerRendererByKey_=function(layerKey){var layerRenderer=this.layerRenderers_[layerKey];delete this.layerRenderers_[layerKey];_ol_events_.unlistenByKey(this.layerRendererListeners_[layerKey]);delete this.layerRendererListeners_[layerKey];return layerRenderer;};/**
 * Render.
 * @param {?olx.FrameState} frameState Frame state.
 */_ol_renderer_Map_.prototype.renderFrame=_ol_.nullFunction;/**
 * @param {ol.Map} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */_ol_renderer_Map_.prototype.removeUnusedLayerRenderers_=function(map,frameState){var layerKey;for(layerKey in this.layerRenderers_){if(!frameState||!(layerKey in frameState.layerStates)){this.removeLayerRendererByKey_(layerKey).dispose();}}};/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 */_ol_renderer_Map_.prototype.scheduleExpireIconCache=function(frameState){frameState.postRenderFunctions.push(/** @type {ol.PostRenderFunction} */_ol_renderer_Map_.expireIconCache_);};/**
 * @param {!olx.FrameState} frameState Frame state.
 * @protected
 */_ol_renderer_Map_.prototype.scheduleRemoveUnusedLayerRenderers=function(frameState){var layerKey;for(layerKey in this.layerRenderers_){if(!(layerKey in frameState.layerStates)){frameState.postRenderFunctions.push(/** @type {ol.PostRenderFunction} */this.removeUnusedLayerRenderers_.bind(this));return;}}};/**
 * @param {ol.LayerState} state1 First layer state.
 * @param {ol.LayerState} state2 Second layer state.
 * @return {number} The zIndex difference.
 */_ol_renderer_Map_.sortByZIndex=function(state1,state2){return state1.zIndex-state2.zIndex;};// FIXME offset panning
/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.Map} map Map.
 */var _ol_renderer_canvas_Map_=function(container,map){_ol_renderer_Map_.call(this,container,map);/**
   * @private
   * @type {CanvasRenderingContext2D}
   */this.context_=_ol_dom_.createCanvasContext2D();/**
   * @private
   * @type {HTMLCanvasElement}
   */this.canvas_=this.context_.canvas;this.canvas_.style.width='100%';this.canvas_.style.height='100%';this.canvas_.style.display='block';this.canvas_.className=_ol_css_.CLASS_UNSELECTABLE;container.insertBefore(this.canvas_,container.childNodes[0]||null);/**
   * @private
   * @type {boolean}
   */this.renderedVisible_=true;/**
   * @private
   * @type {ol.Transform}
   */this.transform_=_ol_transform_.create();};_ol_.inherits(_ol_renderer_canvas_Map_,_ol_renderer_Map_);/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */_ol_renderer_canvas_Map_.prototype.dispatchComposeEvent_=function(type,frameState){var map=this.getMap();var context=this.context_;if(map.hasListener(type)){var extent=frameState.extent;var pixelRatio=frameState.pixelRatio;var viewState=frameState.viewState;var rotation=viewState.rotation;var transform=this.getTransform(frameState);var vectorContext=new _ol_render_canvas_Immediate_(context,pixelRatio,extent,transform,rotation);var composeEvent=new _ol_render_Event_(type,vectorContext,frameState,context,null);map.dispatchEvent(composeEvent);}};/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 * @return {!ol.Transform} Transform.
 */_ol_renderer_canvas_Map_.prototype.getTransform=function(frameState){var viewState=frameState.viewState;var dx1=this.canvas_.width/2;var dy1=this.canvas_.height/2;var sx=frameState.pixelRatio/viewState.resolution;var sy=-sx;var angle=-viewState.rotation;var dx2=-viewState.center[0];var dy2=-viewState.center[1];return _ol_transform_.compose(this.transform_,dx1,dy1,sx,sy,angle,dx2,dy2);};/**
 * @inheritDoc
 */_ol_renderer_canvas_Map_.prototype.getType=function(){return _ol_renderer_Type_.CANVAS;};/**
 * @inheritDoc
 */_ol_renderer_canvas_Map_.prototype.renderFrame=function(frameState){if(!frameState){if(this.renderedVisible_){this.canvas_.style.display='none';this.renderedVisible_=false;}return;}var context=this.context_;var pixelRatio=frameState.pixelRatio;var width=Math.round(frameState.size[0]*pixelRatio);var height=Math.round(frameState.size[1]*pixelRatio);if(this.canvas_.width!=width||this.canvas_.height!=height){this.canvas_.width=width;this.canvas_.height=height;}else{context.clearRect(0,0,width,height);}var rotation=frameState.viewState.rotation;this.calculateMatrices2D(frameState);this.dispatchComposeEvent_(_ol_render_EventType_.PRECOMPOSE,frameState);var layerStatesArray=frameState.layerStatesArray;_ol_array_.stableSort(layerStatesArray,_ol_renderer_Map_.sortByZIndex);if(rotation){context.save();_ol_render_canvas_.rotateAtOffset(context,rotation,width/2,height/2);}var viewResolution=frameState.viewState.resolution;var i,ii,layer,layerRenderer,layerState;for(i=0,ii=layerStatesArray.length;i<ii;++i){layerState=layerStatesArray[i];layer=layerState.layer;layerRenderer=/** @type {ol.renderer.canvas.Layer} */this.getLayerRenderer(layer);if(!_ol_layer_Layer_.visibleAtResolution(layerState,viewResolution)||layerState.sourceState!=_ol_source_State_.READY){continue;}if(layerRenderer.prepareFrame(frameState,layerState)){layerRenderer.composeFrame(frameState,layerState,context);}}if(rotation){context.restore();}this.dispatchComposeEvent_(_ol_render_EventType_.POSTCOMPOSE,frameState);if(!this.renderedVisible_){this.canvas_.style.display='';this.renderedVisible_=true;}this.scheduleRemoveUnusedLayerRenderers(frameState);this.scheduleExpireIconCache(frameState);};/**
 * @inheritDoc
 */_ol_renderer_canvas_Map_.prototype.forEachLayerAtPixel=function(pixel,frameState,callback,thisArg,layerFilter,thisArg2){var result;var viewState=frameState.viewState;var viewResolution=viewState.resolution;var layerStates=frameState.layerStatesArray;var numLayers=layerStates.length;var coordinate=_ol_transform_.apply(frameState.pixelToCoordinateTransform,pixel.slice());var i;for(i=numLayers-1;i>=0;--i){var layerState=layerStates[i];var layer=layerState.layer;if(_ol_layer_Layer_.visibleAtResolution(layerState,viewResolution)&&layerFilter.call(thisArg2,layer)){var layerRenderer=/** @type {ol.renderer.canvas.Layer} */this.getLayerRenderer(layer);result=layerRenderer.forEachLayerAtCoordinate(coordinate,frameState,callback,thisArg);if(result){return result;}}}return undefined;};/**
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 * @constructor
 * @struct
 * @template T
 */var _ol_structs_LRUCache_=function(){/**
   * @private
   * @type {number}
   */this.count_=0;/**
   * @private
   * @type {!Object.<string, ol.LRUCacheEntry>}
   */this.entries_={};/**
   * @private
   * @type {?ol.LRUCacheEntry}
   */this.oldest_=null;/**
   * @private
   * @type {?ol.LRUCacheEntry}
   */this.newest_=null;};/**
 * FIXME empty description for jsdoc
 */_ol_structs_LRUCache_.prototype.clear=function(){this.count_=0;this.entries_={};this.oldest_=null;this.newest_=null;};/**
 * @param {string} key Key.
 * @return {boolean} Contains key.
 */_ol_structs_LRUCache_.prototype.containsKey=function(key){return this.entries_.hasOwnProperty(key);};/**
 * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function
 *     to call for every entry from the oldest to the newer. This function takes
 *     3 arguments (the entry value, the entry key and the LRUCache object).
 *     The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 */_ol_structs_LRUCache_.prototype.forEach=function(f,opt_this){var entry=this.oldest_;while(entry){f.call(opt_this,entry.value_,entry.key_,this);entry=entry.newer;}};/**
 * @param {string} key Key.
 * @return {T} Value.
 */_ol_structs_LRUCache_.prototype.get=function(key){var entry=this.entries_[key];_ol_asserts_.assert(entry!==undefined,15);// Tried to get a value for a key that does not exist in the cache
if(entry===this.newest_){return entry.value_;}else if(entry===this.oldest_){this.oldest_=/** @type {ol.LRUCacheEntry} */this.oldest_.newer;this.oldest_.older=null;}else{entry.newer.older=entry.older;entry.older.newer=entry.newer;}entry.newer=null;entry.older=this.newest_;this.newest_.newer=entry;this.newest_=entry;return entry.value_;};/**
 * @return {number} Count.
 */_ol_structs_LRUCache_.prototype.getCount=function(){return this.count_;};/**
 * @return {Array.<string>} Keys.
 */_ol_structs_LRUCache_.prototype.getKeys=function(){var keys=new Array(this.count_);var i=0;var entry;for(entry=this.newest_;entry;entry=entry.older){keys[i++]=entry.key_;}return keys;};/**
 * @return {Array.<T>} Values.
 */_ol_structs_LRUCache_.prototype.getValues=function(){var values=new Array(this.count_);var i=0;var entry;for(entry=this.newest_;entry;entry=entry.older){values[i++]=entry.value_;}return values;};/**
 * @return {T} Last value.
 */_ol_structs_LRUCache_.prototype.peekLast=function(){return this.oldest_.value_;};/**
 * @return {string} Last key.
 */_ol_structs_LRUCache_.prototype.peekLastKey=function(){return this.oldest_.key_;};/**
 * @return {T} value Value.
 */_ol_structs_LRUCache_.prototype.pop=function(){var entry=this.oldest_;delete this.entries_[entry.key_];if(entry.newer){entry.newer.older=null;}this.oldest_=/** @type {ol.LRUCacheEntry} */entry.newer;if(!this.oldest_){this.newest_=null;}--this.count_;return entry.value_;};/**
 * @param {string} key Key.
 * @param {T} value Value.
 */_ol_structs_LRUCache_.prototype.replace=function(key,value){this.get(key);// update `newest_`
this.entries_[key].value_=value;};/**
 * @param {string} key Key.
 * @param {T} value Value.
 */_ol_structs_LRUCache_.prototype.set=function(key,value){_ol_asserts_.assert(!(key in this.entries_),16);// Tried to set a value for a key that is used already
var entry=/** @type {ol.LRUCacheEntry} */{key_:key,newer:null,older:this.newest_,value_:value};if(!this.newest_){this.oldest_=entry;}else{this.newest_.newer=entry;}this.newest_=entry;this.entries_[key]=entry;++this.count_;};// FIXME check against gl.getParameter(webgl.MAX_TEXTURE_SIZE)
var _ol_renderer_webgl_Map_;// FIXME recheck layer/map projection compatibility when projection changes
// FIXME layer renderers should skip when they can't reproject
// FIXME add tilt and height?
/**
 * @const
 * @type {string}
 */_ol_.OL_URL='https://openlayers.org/';/**
 * @const
 * @type {string}
 */_ol_.OL_LOGO_URL='data:image/png;base64,'+'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBI'+'WXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAA'+'AhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszW'+'WMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvY'+'asvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvX'+'H1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1Vk'+'bMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW'+'2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLP'+'VcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqT'+'acrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaar'+'ldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+Hi'+'zeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDn'+'BAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSF'+'hYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJ'+'REFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxC'+'Brb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe'+'0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8'+'a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7a'+'hgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCn'+'B3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDg'+'q82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC';/**
 * @type {Array.<ol.renderer.Type>}
 * @const
 */_ol_.DEFAULT_RENDERER_TYPES=[_ol_renderer_Type_.CANVAS,_ol_renderer_Type_.WEBGL];/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     var map = new ol.Map({
 *       view: new ol.View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new ol.layer.Tile({
 *           source: new ol.source.OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link ol.layer.Tile} to display
 * {@link ol.source.OSM} OSM data and render it to a DOM element with the
 * id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link ol.Overlay} for the difference). The map itself is placed in
 * a further element within the viewport.
 *
 * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
 * provided by the library. This is what is accessed by `getLayerGroup` and
 * `setLayerGroup`. Layers entered in the options are added to this group, and
 * `addLayer` and `removeLayer` change the layer collection in the group.
 * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
 * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
 * entered in the options or added with `addLayer` can be groups, which can
 * contain further groups, and so on.
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */var _ol_Map_=function(options){_ol_Object_.call(this);var optionsInternal=_ol_Map_.createOptionsInternal(options);/**
   * @type {boolean}
   * @private
   */this.loadTilesWhileAnimating_=options.loadTilesWhileAnimating!==undefined?options.loadTilesWhileAnimating:false;/**
   * @type {boolean}
   * @private
   */this.loadTilesWhileInteracting_=options.loadTilesWhileInteracting!==undefined?options.loadTilesWhileInteracting:false;/**
   * @private
   * @type {number}
   */this.pixelRatio_=options.pixelRatio!==undefined?options.pixelRatio:_ol_has_.DEVICE_PIXEL_RATIO;/**
   * @private
   * @type {Object.<string, string>}
   */this.logos_=optionsInternal.logos;/**
   * @private
   * @type {number|undefined}
   */this.animationDelayKey_;/**
   * @private
   */this.animationDelay_=function(){this.animationDelayKey_=undefined;this.renderFrame_.call(this,Date.now());}.bind(this);/**
   * @private
   * @type {ol.Transform}
   */this.coordinateToPixelTransform_=_ol_transform_.create();/**
   * @private
   * @type {ol.Transform}
   */this.pixelToCoordinateTransform_=_ol_transform_.create();/**
   * @private
   * @type {number}
   */this.frameIndex_=0;/**
   * @private
   * @type {?olx.FrameState}
   */this.frameState_=null;/**
   * The extent at the previous 'moveend' event.
   * @private
   * @type {ol.Extent}
   */this.previousExtent_=null;/**
   * @private
   * @type {?ol.EventsKey}
   */this.viewPropertyListenerKey_=null;/**
   * @private
   * @type {?ol.EventsKey}
   */this.viewChangeListenerKey_=null;/**
   * @private
   * @type {Array.<ol.EventsKey>}
   */this.layerGroupPropertyListenerKeys_=null;/**
   * @private
   * @type {Element}
   */this.viewport_=document.createElement('DIV');this.viewport_.className='ol-viewport'+(_ol_has_.TOUCH?' ol-touch':'');this.viewport_.style.position='relative';this.viewport_.style.overflow='hidden';this.viewport_.style.width='100%';this.viewport_.style.height='100%';// prevent page zoom on IE >= 10 browsers
this.viewport_.style.msTouchAction='none';this.viewport_.style.touchAction='none';/**
   * @private
   * @type {!Element}
   */this.overlayContainer_=document.createElement('DIV');this.overlayContainer_.className='ol-overlaycontainer';this.viewport_.appendChild(this.overlayContainer_);/**
   * @private
   * @type {!Element}
   */this.overlayContainerStopEvent_=document.createElement('DIV');this.overlayContainerStopEvent_.className='ol-overlaycontainer-stopevent';var overlayEvents=[_ol_events_EventType_.CLICK,_ol_events_EventType_.DBLCLICK,_ol_events_EventType_.MOUSEDOWN,_ol_events_EventType_.TOUCHSTART,_ol_events_EventType_.MSPOINTERDOWN,_ol_MapBrowserEventType_.POINTERDOWN,_ol_events_EventType_.MOUSEWHEEL,_ol_events_EventType_.WHEEL];for(var i=0,ii=overlayEvents.length;i<ii;++i){_ol_events_.listen(this.overlayContainerStopEvent_,overlayEvents[i],_ol_events_Event_.stopPropagation);}this.viewport_.appendChild(this.overlayContainerStopEvent_);/**
   * @private
   * @type {ol.MapBrowserEventHandler}
   */this.mapBrowserEventHandler_=new _ol_MapBrowserEventHandler_(this,options.moveTolerance);for(var key in _ol_MapBrowserEventType_){_ol_events_.listen(this.mapBrowserEventHandler_,_ol_MapBrowserEventType_[key],this.handleMapBrowserEvent,this);}/**
   * @private
   * @type {Element|Document}
   */this.keyboardEventTarget_=optionsInternal.keyboardEventTarget;/**
   * @private
   * @type {Array.<ol.EventsKey>}
   */this.keyHandlerKeys_=null;_ol_events_.listen(this.viewport_,_ol_events_EventType_.WHEEL,this.handleBrowserEvent,this);_ol_events_.listen(this.viewport_,_ol_events_EventType_.MOUSEWHEEL,this.handleBrowserEvent,this);/**
   * @type {ol.Collection.<ol.control.Control>}
   * @private
   */this.controls_=optionsInternal.controls;/**
   * @type {ol.Collection.<ol.interaction.Interaction>}
   * @private
   */this.interactions_=optionsInternal.interactions;/**
   * @type {ol.Collection.<ol.Overlay>}
   * @private
   */this.overlays_=optionsInternal.overlays;/**
   * A lookup of overlays by id.
   * @private
   * @type {Object.<string, ol.Overlay>}
   */this.overlayIdIndex_={};/**
   * @type {ol.renderer.Map}
   * @private
   */this.renderer_=new/** @type {Function} */optionsInternal.rendererConstructor(this.viewport_,this);/**
   * @type {function(Event)|undefined}
   * @private
   */this.handleResize_;/**
   * @private
   * @type {ol.Coordinate}
   */this.focus_=null;/**
   * @private
   * @type {Array.<ol.PostRenderFunction>}
   */this.postRenderFunctions_=[];/**
   * @private
   * @type {ol.TileQueue}
   */this.tileQueue_=new _ol_TileQueue_(this.getTilePriority.bind(this),this.handleTileChange_.bind(this));/**
   * Uids of features to skip at rendering time.
   * @type {Object.<string, boolean>}
   * @private
   */this.skippedFeatureUids_={};_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_MapProperty_.LAYERGROUP),this.handleLayerGroupChanged_,this);_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_MapProperty_.VIEW),this.handleViewChanged_,this);_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_MapProperty_.SIZE),this.handleSizeChanged_,this);_ol_events_.listen(this,_ol_Object_.getChangeEventType(_ol_MapProperty_.TARGET),this.handleTargetChanged_,this);// setProperties will trigger the rendering of the map if the map
// is "defined" already.
this.setProperties(optionsInternal.values);this.controls_.forEach(/**
       * @param {ol.control.Control} control Control.
       * @this {ol.Map}
       */function(control){control.setMap(this);},this);_ol_events_.listen(this.controls_,_ol_CollectionEventType_.ADD,/**
       * @param {ol.Collection.Event} event Collection event.
       */function(event){event.element.setMap(this);},this);_ol_events_.listen(this.controls_,_ol_CollectionEventType_.REMOVE,/**
       * @param {ol.Collection.Event} event Collection event.
       */function(event){event.element.setMap(null);},this);this.interactions_.forEach(/**
       * @param {ol.interaction.Interaction} interaction Interaction.
       * @this {ol.Map}
       */function(interaction){interaction.setMap(this);},this);_ol_events_.listen(this.interactions_,_ol_CollectionEventType_.ADD,/**
       * @param {ol.Collection.Event} event Collection event.
       */function(event){event.element.setMap(this);},this);_ol_events_.listen(this.interactions_,_ol_CollectionEventType_.REMOVE,/**
       * @param {ol.Collection.Event} event Collection event.
       */function(event){event.element.setMap(null);},this);this.overlays_.forEach(this.addOverlayInternal_,this);_ol_events_.listen(this.overlays_,_ol_CollectionEventType_.ADD,/**
       * @param {ol.Collection.Event} event Collection event.
       */function(event){this.addOverlayInternal_(/** @type {ol.Overlay} */event.element);},this);_ol_events_.listen(this.overlays_,_ol_CollectionEventType_.REMOVE,/**
       * @param {ol.Collection.Event} event Collection event.
       */function(event){var overlay=/** @type {ol.Overlay} */event.element;var id=overlay.getId();if(id!==undefined){delete this.overlayIdIndex_[id.toString()];}event.element.setMap(null);},this);};_ol_.inherits(_ol_Map_,_ol_Object_);/**
 * Add the given control to the map.
 * @param {ol.control.Control} control Control.
 * @api
 */_ol_Map_.prototype.addControl=function(control){this.getControls().push(control);};/**
 * Add the given interaction to the map.
 * @param {ol.interaction.Interaction} interaction Interaction to add.
 * @api
 */_ol_Map_.prototype.addInteraction=function(interaction){this.getInteractions().push(interaction);};/**
 * Adds the given layer to the top of this map. If you want to add a layer
 * elsewhere in the stack, use `getLayers()` and the methods available on
 * {@link ol.Collection}.
 * @param {ol.layer.Base} layer Layer.
 * @api
 */_ol_Map_.prototype.addLayer=function(layer){var layers=this.getLayerGroup().getLayers();layers.push(layer);};/**
 * Add the given overlay to the map.
 * @param {ol.Overlay} overlay Overlay.
 * @api
 */_ol_Map_.prototype.addOverlay=function(overlay){this.getOverlays().push(overlay);};/**
 * This deals with map's overlay collection changes.
 * @param {ol.Overlay} overlay Overlay.
 * @private
 */_ol_Map_.prototype.addOverlayInternal_=function(overlay){var id=overlay.getId();if(id!==undefined){this.overlayIdIndex_[id.toString()]=overlay;}overlay.setMap(this);};/**
 *
 * @inheritDoc
 */_ol_Map_.prototype.disposeInternal=function(){this.mapBrowserEventHandler_.dispose();this.renderer_.dispose();_ol_events_.unlisten(this.viewport_,_ol_events_EventType_.WHEEL,this.handleBrowserEvent,this);_ol_events_.unlisten(this.viewport_,_ol_events_EventType_.MOUSEWHEEL,this.handleBrowserEvent,this);if(this.handleResize_!==undefined){window.removeEventListener(_ol_events_EventType_.RESIZE,this.handleResize_,false);this.handleResize_=undefined;}if(this.animationDelayKey_){cancelAnimationFrame(this.animationDelayKey_);this.animationDelayKey_=undefined;}this.setTarget(null);_ol_Object_.prototype.disposeInternal.call(this);};/**
 * Detect features that intersect a pixel on the viewport, and execute a
 * callback with each intersecting feature. Layers included in the detection can
 * be configured through the `layerFilter` option in `opt_options`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback. The callback will be
 *     called with two arguments. The first argument is one
 *     {@link ol.Feature feature} or
 *     {@link ol.render.Feature render feature} at the pixel, the second is
 *     the {@link ol.layer.Layer layer} of the feature and will be null for
 *     unmanaged layers. To stop detection, callback functions can return a
 *     truthy value.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T
 * @api
 */_ol_Map_.prototype.forEachFeatureAtPixel=function(pixel,callback,opt_options){if(!this.frameState_){return;}var coordinate=this.getCoordinateFromPixel(pixel);opt_options=opt_options!==undefined?opt_options:{};var hitTolerance=opt_options.hitTolerance!==undefined?opt_options.hitTolerance*this.frameState_.pixelRatio:0;var layerFilter=opt_options.layerFilter!==undefined?opt_options.layerFilter:_ol_functions_.TRUE;return this.renderer_.forEachFeatureAtCoordinate(coordinate,this.frameState_,hitTolerance,callback,null,layerFilter,null);};/**
 * Get all features that intersect a pixel on the viewport.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {Array.<ol.Feature|ol.render.Feature>} The detected features or
 * `null` if none were found.
 * @api
 */_ol_Map_.prototype.getFeaturesAtPixel=function(pixel,opt_options){var features=null;this.forEachFeatureAtPixel(pixel,function(feature){if(!features){features=[];}features.push(feature);},opt_options);return features;};/**
 * Detect layers that have a color value at a pixel on the viewport, and
 * execute a callback with each matching layer. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback
 *     Layer callback. This callback will receive two arguments: first is the
 *     {@link ol.layer.Layer layer}, second argument is an array representing
 *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
 *     that do not currently support this argument. To stop detection, callback
 *     functions can return a truthy value.
 * @param {S=} opt_this Value to use as `this` when executing `callback`.
 * @param {(function(this: U, ol.layer.Layer): boolean)=} opt_layerFilter Layer
 *     filter function. The filter function will receive one argument, the
 *     {@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * @param {U=} opt_this2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T,U
 * @api
 */_ol_Map_.prototype.forEachLayerAtPixel=function(pixel,callback,opt_this,opt_layerFilter,opt_this2){if(!this.frameState_){return;}var thisArg=opt_this!==undefined?opt_this:null;var layerFilter=opt_layerFilter!==undefined?opt_layerFilter:_ol_functions_.TRUE;var thisArg2=opt_this2!==undefined?opt_this2:null;return this.renderer_.forEachLayerAtPixel(pixel,this.frameState_,callback,thisArg,layerFilter,thisArg2);};/**
 * Detect if features intersect a pixel on the viewport. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {boolean} Is there a feature at the given pixel?
 * @template U
 * @api
 */_ol_Map_.prototype.hasFeatureAtPixel=function(pixel,opt_options){if(!this.frameState_){return false;}var coordinate=this.getCoordinateFromPixel(pixel);opt_options=opt_options!==undefined?opt_options:{};var layerFilter=opt_options.layerFilter!==undefined?opt_options.layerFilter:_ol_functions_.TRUE;var hitTolerance=opt_options.hitTolerance!==undefined?opt_options.hitTolerance*this.frameState_.pixelRatio:0;return this.renderer_.hasFeatureAtCoordinate(coordinate,this.frameState_,hitTolerance,layerFilter,null);};/**
 * Returns the coordinate in view projection for a browser event.
 * @param {Event} event Event.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */_ol_Map_.prototype.getEventCoordinate=function(event){return this.getCoordinateFromPixel(this.getEventPixel(event));};/**
 * Returns the map pixel position for a browser event relative to the viewport.
 * @param {Event} event Event.
 * @return {ol.Pixel} Pixel.
 * @api
 */_ol_Map_.prototype.getEventPixel=function(event){var viewportPosition=this.viewport_.getBoundingClientRect();var eventPosition=event.changedTouches?event.changedTouches[0]:event;return[eventPosition.clientX-viewportPosition.left,eventPosition.clientY-viewportPosition.top];};/**
 * Get the target in which this map is rendered.
 * Note that this returns what is entered as an option or in setTarget:
 * if that was an element, it returns an element; if a string, it returns that.
 * @return {Element|string|undefined} The Element or id of the Element that the
 *     map is rendered in.
 * @observable
 * @api
 */_ol_Map_.prototype.getTarget=function(){return(/** @type {Element|string|undefined} */this.get(_ol_MapProperty_.TARGET));};/**
 * Get the DOM element into which this map is rendered. In contrast to
 * `getTarget` this method always return an `Element`, or `null` if the
 * map has no target.
 * @return {Element} The element that the map is rendered in.
 * @api
 */_ol_Map_.prototype.getTargetElement=function(){var target=this.getTarget();if(target!==undefined){return typeof target==='string'?document.getElementById(target):target;}else{return null;}};/**
 * Get the coordinate for a given pixel.  This returns a coordinate in the
 * map view projection.
 * @param {ol.Pixel} pixel Pixel position in the map viewport.
 * @return {ol.Coordinate} The coordinate for the pixel position.
 * @api
 */_ol_Map_.prototype.getCoordinateFromPixel=function(pixel){var frameState=this.frameState_;if(!frameState){return null;}else{return _ol_transform_.apply(frameState.pixelToCoordinateTransform,pixel.slice());}};/**
 * Get the map controls. Modifying this collection changes the controls
 * associated with the map.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */_ol_Map_.prototype.getControls=function(){return this.controls_;};/**
 * Get the map overlays. Modifying this collection changes the overlays
 * associated with the map.
 * @return {ol.Collection.<ol.Overlay>} Overlays.
 * @api
 */_ol_Map_.prototype.getOverlays=function(){return this.overlays_;};/**
 * Get an overlay by its identifier (the value returned by overlay.getId()).
 * Note that the index treats string and numeric identifiers as the same. So
 * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
 * @param {string|number} id Overlay identifier.
 * @return {ol.Overlay} Overlay.
 * @api
 */_ol_Map_.prototype.getOverlayById=function(id){var overlay=this.overlayIdIndex_[id.toString()];return overlay!==undefined?overlay:null;};/**
 * Get the map interactions. Modifying this collection changes the interactions
 * associated with the map.
 *
 * Interactions are used for e.g. pan, zoom and rotate.
 * @return {ol.Collection.<ol.interaction.Interaction>} Interactions.
 * @api
 */_ol_Map_.prototype.getInteractions=function(){return this.interactions_;};/**
 * Get the layergroup associated with this map.
 * @return {ol.layer.Group} A layer group containing the layers in this map.
 * @observable
 * @api
 */_ol_Map_.prototype.getLayerGroup=function(){return(/** @type {ol.layer.Group} */this.get(_ol_MapProperty_.LAYERGROUP));};/**
 * Get the collection of layers associated with this map.
 * @return {!ol.Collection.<ol.layer.Base>} Layers.
 * @api
 */_ol_Map_.prototype.getLayers=function(){var layers=this.getLayerGroup().getLayers();return layers;};/**
 * Get the pixel for a coordinate.  This takes a coordinate in the map view
 * projection and returns the corresponding pixel.
 * @param {ol.Coordinate} coordinate A map coordinate.
 * @return {ol.Pixel} A pixel position in the map viewport.
 * @api
 */_ol_Map_.prototype.getPixelFromCoordinate=function(coordinate){var frameState=this.frameState_;if(!frameState){return null;}else{return _ol_transform_.apply(frameState.coordinateToPixelTransform,coordinate.slice(0,2));}};/**
 * Get the map renderer.
 * @return {ol.renderer.Map} Renderer
 */_ol_Map_.prototype.getRenderer=function(){return this.renderer_;};/**
 * Get the size of this map.
 * @return {ol.Size|undefined} The size in pixels of the map in the DOM.
 * @observable
 * @api
 */_ol_Map_.prototype.getSize=function(){return(/** @type {ol.Size|undefined} */this.get(_ol_MapProperty_.SIZE));};/**
 * Get the view associated with this map. A view manages properties such as
 * center and resolution.
 * @return {ol.View} The view that controls this map.
 * @observable
 * @api
 */_ol_Map_.prototype.getView=function(){return(/** @type {ol.View} */this.get(_ol_MapProperty_.VIEW));};/**
 * Get the element that serves as the map viewport.
 * @return {Element} Viewport.
 * @api
 */_ol_Map_.prototype.getViewport=function(){return this.viewport_;};/**
 * Get the element that serves as the container for overlays.  Elements added to
 * this container will let mousedown and touchstart events through to the map,
 * so clicks and gestures on an overlay will trigger {@link ol.MapBrowserEvent}
 * events.
 * @return {!Element} The map's overlay container.
 */_ol_Map_.prototype.getOverlayContainer=function(){return this.overlayContainer_;};/**
 * Get the element that serves as a container for overlays that don't allow
 * event propagation. Elements added to this container won't let mousedown and
 * touchstart events through to the map, so clicks and gestures on an overlay
 * don't trigger any {@link ol.MapBrowserEvent}.
 * @return {!Element} The map's overlay container that stops events.
 */_ol_Map_.prototype.getOverlayContainerStopEvent=function(){return this.overlayContainerStopEvent_;};/**
 * @param {ol.Tile} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {ol.Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */_ol_Map_.prototype.getTilePriority=function(tile,tileSourceKey,tileCenter,tileResolution){// Filter out tiles at higher zoom levels than the current zoom level, or that
// are outside the visible extent.
var frameState=this.frameState_;if(!frameState||!(tileSourceKey in frameState.wantedTiles)){return _ol_structs_PriorityQueue_.DROP;}if(!frameState.wantedTiles[tileSourceKey][tile.getKey()]){return _ol_structs_PriorityQueue_.DROP;}// Prioritize the highest zoom level tiles closest to the focus.
// Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
// Within a zoom level, tiles are prioritized by the distance in pixels
// between the center of the tile and the focus.  The factor of 65536 means
// that the prioritization should behave as desired for tiles up to
// 65536 * Math.log(2) = 45426 pixels from the focus.
var deltaX=tileCenter[0]-frameState.focus[0];var deltaY=tileCenter[1]-frameState.focus[1];return 65536*Math.log(tileResolution)+Math.sqrt(deltaX*deltaX+deltaY*deltaY)/tileResolution;};/**
 * @param {Event} browserEvent Browser event.
 * @param {string=} opt_type Type.
 */_ol_Map_.prototype.handleBrowserEvent=function(browserEvent,opt_type){var type=opt_type||browserEvent.type;var mapBrowserEvent=new _ol_MapBrowserEvent_(type,this,browserEvent);this.handleMapBrowserEvent(mapBrowserEvent);};/**
 * @param {ol.MapBrowserEvent} mapBrowserEvent The event to handle.
 */_ol_Map_.prototype.handleMapBrowserEvent=function(mapBrowserEvent){if(!this.frameState_){// With no view defined, we cannot translate pixels into geographical
// coordinates so interactions cannot be used.
return;}this.focus_=mapBrowserEvent.coordinate;mapBrowserEvent.frameState=this.frameState_;var interactionsArray=this.getInteractions().getArray();var i;if(this.dispatchEvent(mapBrowserEvent)!==false){for(i=interactionsArray.length-1;i>=0;i--){var interaction=interactionsArray[i];if(!interaction.getActive()){continue;}var cont=interaction.handleEvent(mapBrowserEvent);if(!cont){break;}}}};/**
 * @protected
 */_ol_Map_.prototype.handlePostRender=function(){var frameState=this.frameState_;// Manage the tile queue
// Image loads are expensive and a limited resource, so try to use them
// efficiently:
// * When the view is static we allow a large number of parallel tile loads
//   to complete the frame as quickly as possible.
// * When animating or interacting, image loads can cause janks, so we reduce
//   the maximum number of loads per frame and limit the number of parallel
//   tile loads to remain reactive to view changes and to reduce the chance of
//   loading tiles that will quickly disappear from view.
var tileQueue=this.tileQueue_;if(!tileQueue.isEmpty()){var maxTotalLoading=16;var maxNewLoads=maxTotalLoading;if(frameState){var hints=frameState.viewHints;if(hints[_ol_ViewHint_.ANIMATING]){maxTotalLoading=this.loadTilesWhileAnimating_?8:0;maxNewLoads=2;}if(hints[_ol_ViewHint_.INTERACTING]){maxTotalLoading=this.loadTilesWhileInteracting_?8:0;maxNewLoads=2;}}if(tileQueue.getTilesLoading()<maxTotalLoading){tileQueue.reprioritize();// FIXME only call if view has changed
tileQueue.loadMoreTiles(maxTotalLoading,maxNewLoads);}}var postRenderFunctions=this.postRenderFunctions_;var i,ii;for(i=0,ii=postRenderFunctions.length;i<ii;++i){postRenderFunctions[i](this,frameState);}postRenderFunctions.length=0;};/**
 * @private
 */_ol_Map_.prototype.handleSizeChanged_=function(){this.render();};/**
 * @private
 */_ol_Map_.prototype.handleTargetChanged_=function(){// target may be undefined, null, a string or an Element.
// If it's a string we convert it to an Element before proceeding.
// If it's not now an Element we remove the viewport from the DOM.
// If it's an Element we append the viewport element to it.
var targetElement;if(this.getTarget()){targetElement=this.getTargetElement();}if(this.keyHandlerKeys_){for(var i=0,ii=this.keyHandlerKeys_.length;i<ii;++i){_ol_events_.unlistenByKey(this.keyHandlerKeys_[i]);}this.keyHandlerKeys_=null;}if(!targetElement){_ol_dom_.removeNode(this.viewport_);if(this.handleResize_!==undefined){window.removeEventListener(_ol_events_EventType_.RESIZE,this.handleResize_,false);this.handleResize_=undefined;}}else{targetElement.appendChild(this.viewport_);var keyboardEventTarget=!this.keyboardEventTarget_?targetElement:this.keyboardEventTarget_;this.keyHandlerKeys_=[_ol_events_.listen(keyboardEventTarget,_ol_events_EventType_.KEYDOWN,this.handleBrowserEvent,this),_ol_events_.listen(keyboardEventTarget,_ol_events_EventType_.KEYPRESS,this.handleBrowserEvent,this)];if(!this.handleResize_){this.handleResize_=this.updateSize.bind(this);window.addEventListener(_ol_events_EventType_.RESIZE,this.handleResize_,false);}}this.updateSize();// updateSize calls setSize, so no need to call this.render
// ourselves here.
};/**
 * @private
 */_ol_Map_.prototype.handleTileChange_=function(){this.render();};/**
 * @private
 */_ol_Map_.prototype.handleViewPropertyChanged_=function(){this.render();};/**
 * @private
 */_ol_Map_.prototype.handleViewChanged_=function(){if(this.viewPropertyListenerKey_){_ol_events_.unlistenByKey(this.viewPropertyListenerKey_);this.viewPropertyListenerKey_=null;}if(this.viewChangeListenerKey_){_ol_events_.unlistenByKey(this.viewChangeListenerKey_);this.viewChangeListenerKey_=null;}var view=this.getView();if(view){this.viewport_.setAttribute('data-view',_ol_.getUid(view));this.viewPropertyListenerKey_=_ol_events_.listen(view,_ol_ObjectEventType_.PROPERTYCHANGE,this.handleViewPropertyChanged_,this);this.viewChangeListenerKey_=_ol_events_.listen(view,_ol_events_EventType_.CHANGE,this.handleViewPropertyChanged_,this);}this.render();};/**
 * @private
 */_ol_Map_.prototype.handleLayerGroupChanged_=function(){if(this.layerGroupPropertyListenerKeys_){this.layerGroupPropertyListenerKeys_.forEach(_ol_events_.unlistenByKey);this.layerGroupPropertyListenerKeys_=null;}var layerGroup=this.getLayerGroup();if(layerGroup){this.layerGroupPropertyListenerKeys_=[_ol_events_.listen(layerGroup,_ol_ObjectEventType_.PROPERTYCHANGE,this.render,this),_ol_events_.listen(layerGroup,_ol_events_EventType_.CHANGE,this.render,this)];}this.render();};/**
 * @return {boolean} Is rendered.
 */_ol_Map_.prototype.isRendered=function(){return!!this.frameState_;};/**
 * Requests an immediate render in a synchronous manner.
 * @api
 */_ol_Map_.prototype.renderSync=function(){if(this.animationDelayKey_){cancelAnimationFrame(this.animationDelayKey_);}this.animationDelay_();};/**
 * Request a map rendering (at the next animation frame).
 * @api
 */_ol_Map_.prototype.render=function(){if(this.animationDelayKey_===undefined){this.animationDelayKey_=requestAnimationFrame(this.animationDelay_);}};/**
 * Remove the given control from the map.
 * @param {ol.control.Control} control Control.
 * @return {ol.control.Control|undefined} The removed control (or undefined
 *     if the control was not found).
 * @api
 */_ol_Map_.prototype.removeControl=function(control){return this.getControls().remove(control);};/**
 * Remove the given interaction from the map.
 * @param {ol.interaction.Interaction} interaction Interaction to remove.
 * @return {ol.interaction.Interaction|undefined} The removed interaction (or
 *     undefined if the interaction was not found).
 * @api
 */_ol_Map_.prototype.removeInteraction=function(interaction){return this.getInteractions().remove(interaction);};/**
 * Removes the given layer from the map.
 * @param {ol.layer.Base} layer Layer.
 * @return {ol.layer.Base|undefined} The removed layer (or undefined if the
 *     layer was not found).
 * @api
 */_ol_Map_.prototype.removeLayer=function(layer){var layers=this.getLayerGroup().getLayers();return layers.remove(layer);};/**
 * Remove the given overlay from the map.
 * @param {ol.Overlay} overlay Overlay.
 * @return {ol.Overlay|undefined} The removed overlay (or undefined
 *     if the overlay was not found).
 * @api
 */_ol_Map_.prototype.removeOverlay=function(overlay){return this.getOverlays().remove(overlay);};/**
 * @param {number} time Time.
 * @private
 */_ol_Map_.prototype.renderFrame_=function(time){var i,ii,viewState;var size=this.getSize();var view=this.getView();var extent=_ol_extent_.createEmpty();var previousFrameState=this.frameState_;/** @type {?olx.FrameState} */var frameState=null;if(size!==undefined&&_ol_size_.hasArea(size)&&view&&view.isDef()){var viewHints=view.getHints(this.frameState_?this.frameState_.viewHints:undefined);var layerStatesArray=this.getLayerGroup().getLayerStatesArray();var layerStates={};for(i=0,ii=layerStatesArray.length;i<ii;++i){layerStates[_ol_.getUid(layerStatesArray[i].layer)]=layerStatesArray[i];}viewState=view.getState();frameState=/** @type {olx.FrameState} */{animate:false,attributions:{},coordinateToPixelTransform:this.coordinateToPixelTransform_,extent:extent,focus:!this.focus_?viewState.center:this.focus_,index:this.frameIndex_++,layerStates:layerStates,layerStatesArray:layerStatesArray,logos:_ol_obj_.assign({},this.logos_),pixelRatio:this.pixelRatio_,pixelToCoordinateTransform:this.pixelToCoordinateTransform_,postRenderFunctions:[],size:size,skippedFeatureUids:this.skippedFeatureUids_,tileQueue:this.tileQueue_,time:time,usedTiles:{},viewState:viewState,viewHints:viewHints,wantedTiles:{}};}if(frameState){frameState.extent=_ol_extent_.getForViewAndSize(viewState.center,viewState.resolution,viewState.rotation,frameState.size,extent);}this.frameState_=frameState;this.renderer_.renderFrame(frameState);if(frameState){if(frameState.animate){this.render();}Array.prototype.push.apply(this.postRenderFunctions_,frameState.postRenderFunctions);if(previousFrameState){var moveStart=!this.previousExtent_||!_ol_extent_.isEmpty(this.previousExtent_)&&!_ol_extent_.equals(frameState.extent,this.previousExtent_);if(moveStart){this.dispatchEvent(new _ol_MapEvent_(_ol_MapEventType_.MOVESTART,this,previousFrameState));this.previousExtent_=_ol_extent_.createOrUpdateEmpty(this.previousExtent_);}}var idle=this.previousExtent_&&!frameState.viewHints[_ol_ViewHint_.ANIMATING]&&!frameState.viewHints[_ol_ViewHint_.INTERACTING]&&!_ol_extent_.equals(frameState.extent,this.previousExtent_);if(idle){this.dispatchEvent(new _ol_MapEvent_(_ol_MapEventType_.MOVEEND,this,frameState));_ol_extent_.clone(frameState.extent,this.previousExtent_);}}this.dispatchEvent(new _ol_MapEvent_(_ol_MapEventType_.POSTRENDER,this,frameState));setTimeout(this.handlePostRender.bind(this),0);};/**
 * Sets the layergroup of this map.
 * @param {ol.layer.Group} layerGroup A layer group containing the layers in
 *     this map.
 * @observable
 * @api
 */_ol_Map_.prototype.setLayerGroup=function(layerGroup){this.set(_ol_MapProperty_.LAYERGROUP,layerGroup);};/**
 * Set the size of this map.
 * @param {ol.Size|undefined} size The size in pixels of the map in the DOM.
 * @observable
 * @api
 */_ol_Map_.prototype.setSize=function(size){this.set(_ol_MapProperty_.SIZE,size);};/**
 * Set the target element to render this map into.
 * @param {Element|string|undefined} target The Element or id of the Element
 *     that the map is rendered in.
 * @observable
 * @api
 */_ol_Map_.prototype.setTarget=function(target){this.set(_ol_MapProperty_.TARGET,target);};/**
 * Set the view for this map.
 * @param {ol.View} view The view that controls this map.
 * @observable
 * @api
 */_ol_Map_.prototype.setView=function(view){this.set(_ol_MapProperty_.VIEW,view);};/**
 * @param {ol.Feature} feature Feature.
 */_ol_Map_.prototype.skipFeature=function(feature){var featureUid=_ol_.getUid(feature).toString();this.skippedFeatureUids_[featureUid]=true;this.render();};/**
 * Force a recalculation of the map viewport size.  This should be called when
 * third-party code changes the size of the map viewport.
 * @api
 */_ol_Map_.prototype.updateSize=function(){var targetElement=this.getTargetElement();if(!targetElement){this.setSize(undefined);}else{var computedStyle=getComputedStyle(targetElement);this.setSize([targetElement.offsetWidth-parseFloat(computedStyle['borderLeftWidth'])-parseFloat(computedStyle['paddingLeft'])-parseFloat(computedStyle['paddingRight'])-parseFloat(computedStyle['borderRightWidth']),targetElement.offsetHeight-parseFloat(computedStyle['borderTopWidth'])-parseFloat(computedStyle['paddingTop'])-parseFloat(computedStyle['paddingBottom'])-parseFloat(computedStyle['borderBottomWidth'])]);}};/**
 * @param {ol.Feature} feature Feature.
 */_ol_Map_.prototype.unskipFeature=function(feature){var featureUid=_ol_.getUid(feature).toString();delete this.skippedFeatureUids_[featureUid];this.render();};/**
 * @param {olx.MapOptions} options Map options.
 * @return {ol.MapOptionsInternal} Internal map options.
 */_ol_Map_.createOptionsInternal=function(options){/**
   * @type {Element|Document}
   */var keyboardEventTarget=null;if(options.keyboardEventTarget!==undefined){keyboardEventTarget=typeof options.keyboardEventTarget==='string'?document.getElementById(options.keyboardEventTarget):options.keyboardEventTarget;}/**
   * @type {Object.<string, *>}
   */var values={};var logos={};if(options.logo===undefined||typeof options.logo==='boolean'&&options.logo){logos[_ol_.OL_LOGO_URL]=_ol_.OL_URL;}else{var logo=options.logo;if(typeof logo==='string'){logos[logo]='';}else if(logo instanceof HTMLElement){logos[_ol_.getUid(logo).toString()]=logo;}else if(logo){_ol_asserts_.assert(typeof logo.href=='string',44);// `logo.href` should be a string.
_ol_asserts_.assert(typeof logo.src=='string',45);// `logo.src` should be a string.
logos[logo.src]=logo.href;}}var layerGroup=options.layers instanceof _ol_layer_Group_?options.layers:new _ol_layer_Group_({layers:options.layers});values[_ol_MapProperty_.LAYERGROUP]=layerGroup;values[_ol_MapProperty_.TARGET]=options.target;values[_ol_MapProperty_.VIEW]=options.view!==undefined?options.view:new _ol_View_();/**
   * @type {function(new: ol.renderer.Map, Element, ol.Map)}
   */var rendererConstructor=_ol_renderer_Map_;/**
   * @type {Array.<ol.renderer.Type>}
   */var rendererTypes;if(options.renderer!==undefined){if(Array.isArray(options.renderer)){rendererTypes=options.renderer;}else if(typeof options.renderer==='string'){rendererTypes=[options.renderer];}else{_ol_asserts_.assert(false,46);// Incorrect format for `renderer` option
}if(rendererTypes.indexOf(/** @type {ol.renderer.Type} */'dom')>=0){rendererTypes=rendererTypes.concat(_ol_.DEFAULT_RENDERER_TYPES);}}else{rendererTypes=_ol_.DEFAULT_RENDERER_TYPES;}var i,ii;for(i=0,ii=rendererTypes.length;i<ii;++i){/** @type {ol.renderer.Type} */var rendererType=rendererTypes[i];if(_ol_.ENABLE_CANVAS&&rendererType==_ol_renderer_Type_.CANVAS){if(_ol_has_.CANVAS){rendererConstructor=_ol_renderer_canvas_Map_;break;}}else if(false&&rendererType==_ol_renderer_Type_.WEBGL){if(_ol_has_.WEBGL){rendererConstructor=_ol_renderer_webgl_Map_;break;}}}var controls;if(options.controls!==undefined){if(Array.isArray(options.controls)){controls=new _ol_Collection_(options.controls.slice());}else{_ol_asserts_.assert(options.controls instanceof _ol_Collection_,47);// Expected `controls` to be an array or an `ol.Collection`
controls=options.controls;}}else{controls=_ol_control_.defaults();}var interactions;if(options.interactions!==undefined){if(Array.isArray(options.interactions)){interactions=new _ol_Collection_(options.interactions.slice());}else{_ol_asserts_.assert(options.interactions instanceof _ol_Collection_,48);// Expected `interactions` to be an array or an `ol.Collection`
interactions=options.interactions;}}else{interactions=_ol_interaction_.defaults();}var overlays;if(options.overlays!==undefined){if(Array.isArray(options.overlays)){overlays=new _ol_Collection_(options.overlays.slice());}else{_ol_asserts_.assert(options.overlays instanceof _ol_Collection_,49);// Expected `overlays` to be an array or an `ol.Collection`
overlays=options.overlays;}}else{overlays=new _ol_Collection_();}return{controls:controls,interactions:interactions,keyboardEventTarget:keyboardEventTarget,logos:logos,overlays:overlays,rendererConstructor:rendererConstructor,values:values};};/**
 * @classdesc
 * Base class for tiles.
 *
 * @constructor
 * @abstract
 * @extends {ol.events.EventTarget}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 */var _ol_Tile_=function(tileCoord,state){_ol_events_EventTarget_.call(this);/**
   * @type {ol.TileCoord}
   */this.tileCoord=tileCoord;/**
   * @protected
   * @type {ol.TileState}
   */this.state=state;/**
   * An "interim" tile for this tile. The interim tile may be used while this
   * one is loading, for "smooth" transitions when changing params/dimensions
   * on the source.
   * @type {ol.Tile}
   */this.interimTile=null;/**
   * A key assigned to the tile. This is used by the tile source to determine
   * if this tile can effectively be used, or if a new tile should be created
   * and this one be used as an interim tile for this new tile.
   * @type {string}
   */this.key='';};_ol_.inherits(_ol_Tile_,_ol_events_EventTarget_);/**
 * @protected
 */_ol_Tile_.prototype.changed=function(){this.dispatchEvent(_ol_events_EventType_.CHANGE);};/**
 * @return {string} Key.
 */_ol_Tile_.prototype.getKey=function(){return this.key+'/'+this.tileCoord;};/**
 * Get the interim tile most suitable for rendering using the chain of interim
 * tiles. This corresponds to the  most recent tile that has been loaded, if no
 * such tile exists, the original tile is returned.
 * @return {!ol.Tile} Best tile for rendering.
 */_ol_Tile_.prototype.getInterimTile=function(){if(!this.interimTile){//empty chain
return this;}var tile=this.interimTile;// find the first loaded tile and return it. Since the chain is sorted in
// decreasing order of creation time, there is no need to search the remainder
// of the list (all those tiles correspond to older requests and will be
// cleaned up by refreshInterimChain)
do{if(tile.getState()==_ol_TileState_.LOADED){return tile;}tile=tile.interimTile;}while(tile);// we can not find a better tile
return this;};/**
 * Goes through the chain of interim tiles and discards sections of the chain
 * that are no longer relevant.
 */_ol_Tile_.prototype.refreshInterimChain=function(){if(!this.interimTile){return;}var tile=this.interimTile;var prev=this;do{if(tile.getState()==_ol_TileState_.LOADED){//we have a loaded tile, we can discard the rest of the list
//we would could abort any LOADING tile request
//older than this tile (i.e. any LOADING tile following this entry in the chain)
tile.interimTile=null;break;}else if(tile.getState()==_ol_TileState_.LOADING){//keep this LOADING tile any loaded tiles later in the chain are
//older than this tile, so we're still interested in the request
prev=tile;}else if(tile.getState()==_ol_TileState_.IDLE){//the head of the list is the most current tile, we don't need
//to start any other requests for this chain
prev.interimTile=tile.interimTile;}else{prev=tile;}tile=prev.interimTile;}while(tile);};/**
 * Get the tile coordinate for this tile.
 * @return {ol.TileCoord} The tile coordinate.
 * @api
 */_ol_Tile_.prototype.getTileCoord=function(){return this.tileCoord;};/**
 * @return {ol.TileState} State.
 */_ol_Tile_.prototype.getState=function(){return this.state;};/**
 * @param {ol.TileState} state State.
 */_ol_Tile_.prototype.setState=function(state){this.state=state;this.changed();};/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @abstract
 * @api
 */_ol_Tile_.prototype.load=function(){};/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 */var _ol_ImageTile_=function(tileCoord,state,src,crossOrigin,tileLoadFunction){_ol_Tile_.call(this,tileCoord,state);/**
   * Image URI
   *
   * @private
   * @type {string}
   */this.src_=src;/**
   * @private
   * @type {Image|HTMLCanvasElement}
   */this.image_=new Image();if(crossOrigin!==null){this.image_.crossOrigin=crossOrigin;}/**
   * @private
   * @type {Array.<ol.EventsKey>}
   */this.imageListenerKeys_=null;/**
   * @private
   * @type {ol.TileLoadFunctionType}
   */this.tileLoadFunction_=tileLoadFunction;};_ol_.inherits(_ol_ImageTile_,_ol_Tile_);/**
 * @inheritDoc
 */_ol_ImageTile_.prototype.disposeInternal=function(){if(this.state==_ol_TileState_.LOADING){this.unlistenImage_();this.image_.src=_ol_ImageTile_.blankImage.toDataURL('image/png');}if(this.interimTile){this.interimTile.dispose();}this.state=_ol_TileState_.ABORT;this.changed();_ol_Tile_.prototype.disposeInternal.call(this);};/**
 * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
 * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
 * @api
 */_ol_ImageTile_.prototype.getImage=function(){return this.image_;};/**
 * @inheritDoc
 */_ol_ImageTile_.prototype.getKey=function(){return this.src_;};/**
 * Tracks loading or read errors.
 *
 * @private
 */_ol_ImageTile_.prototype.handleImageError_=function(){this.state=_ol_TileState_.ERROR;this.unlistenImage_();this.image_=_ol_ImageTile_.blankImage;this.changed();};/**
 * Tracks successful image load.
 *
 * @private
 */_ol_ImageTile_.prototype.handleImageLoad_=function(){if(this.image_.naturalWidth&&this.image_.naturalHeight){this.state=_ol_TileState_.LOADED;}else{this.state=_ol_TileState_.EMPTY;}this.unlistenImage_();this.changed();};/**
 * @inheritDoc
 * @api
 */_ol_ImageTile_.prototype.load=function(){if(this.state==_ol_TileState_.IDLE||this.state==_ol_TileState_.ERROR){this.state=_ol_TileState_.LOADING;this.changed();this.imageListenerKeys_=[_ol_events_.listenOnce(this.image_,_ol_events_EventType_.ERROR,this.handleImageError_,this),_ol_events_.listenOnce(this.image_,_ol_events_EventType_.LOAD,this.handleImageLoad_,this)];this.tileLoadFunction_(this,this.src_);}};/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */_ol_ImageTile_.prototype.unlistenImage_=function(){this.imageListenerKeys_.forEach(_ol_events_.unlistenByKey);this.imageListenerKeys_=null;};/**
 * A blank image.
 * @type {HTMLCanvasElement}
 */_ol_ImageTile_.blankImage=function(){var ctx=_ol_dom_.createCanvasContext2D(1,1);ctx.fillStyle='rgba(0,0,0,0)';ctx.fillRect(0,0,1,1);return ctx.canvas;}();/**
 * @constructor
 * @extends {ol.structs.LRUCache.<ol.Tile>}
 * @param {number=} opt_highWaterMark High water mark.
 * @struct
 */var _ol_TileCache_=function(opt_highWaterMark){_ol_structs_LRUCache_.call(this);/**
   * @type {number}
   */this.highWaterMark=opt_highWaterMark!==undefined?opt_highWaterMark:2048;};_ol_.inherits(_ol_TileCache_,_ol_structs_LRUCache_);/**
 * @return {boolean} Can expire cache.
 */_ol_TileCache_.prototype.canExpireCache=function(){return this.getCount()>this.highWaterMark;};/**
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */_ol_TileCache_.prototype.expireCache=function(usedTiles){var tile,zKey;while(this.canExpireCache()){tile=this.peekLast();zKey=tile.tileCoord[0].toString();if(zKey in usedTiles&&usedTiles[zKey].contains(tile.tileCoord)){break;}else{this.pop().dispose();}}};var _ol_reproj_={};/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */_ol_reproj_.calculateSourceResolution=function(sourceProj,targetProj,targetCenter,targetResolution){var sourceCenter=_ol_proj_.transform(targetCenter,targetProj,sourceProj);// calculate the ideal resolution of the source data
var sourceResolution=_ol_proj_.getPointResolution(targetProj,targetResolution,targetCenter);var targetMetersPerUnit=targetProj.getMetersPerUnit();if(targetMetersPerUnit!==undefined){sourceResolution*=targetMetersPerUnit;}var sourceMetersPerUnit=sourceProj.getMetersPerUnit();if(sourceMetersPerUnit!==undefined){sourceResolution/=sourceMetersPerUnit;}// Based on the projection properties, the point resolution at the specified
// coordinates may be slightly different. We need to reverse-compensate this
// in order to achieve optimal results.
var sourceExtent=sourceProj.getExtent();if(!sourceExtent||_ol_extent_.containsCoordinate(sourceExtent,sourceCenter)){var compensationFactor=_ol_proj_.getPointResolution(sourceProj,sourceResolution,sourceCenter)/sourceResolution;if(isFinite(compensationFactor)&&compensationFactor>0){sourceResolution/=compensationFactor;}}return sourceResolution;};/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {ol.Coordinate} New point 1 px farther from the centroid.
 * @private
 */_ol_reproj_.enlargeClipPoint_=function(centroidX,centroidY,x,y){var dX=x-centroidX,dY=y-centroidY;var distance=Math.sqrt(dX*dX+dY*dY);return[Math.round(x+dX/distance),Math.round(y+dY/distance)];};/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {ol.Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {ol.Extent} targetExtent Target extent.
 * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.
 * @param {Array.<{extent: ol.Extent,
 *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources
 *             Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */_ol_reproj_.render=function(width,height,pixelRatio,sourceResolution,sourceExtent,targetResolution,targetExtent,triangulation,sources,gutter,opt_renderEdges){var context=_ol_dom_.createCanvasContext2D(Math.round(pixelRatio*width),Math.round(pixelRatio*height));if(sources.length===0){return context.canvas;}context.scale(pixelRatio,pixelRatio);var sourceDataExtent=_ol_extent_.createEmpty();sources.forEach(function(src,i,arr){_ol_extent_.extend(sourceDataExtent,src.extent);});var canvasWidthInUnits=_ol_extent_.getWidth(sourceDataExtent);var canvasHeightInUnits=_ol_extent_.getHeight(sourceDataExtent);var stitchContext=_ol_dom_.createCanvasContext2D(Math.round(pixelRatio*canvasWidthInUnits/sourceResolution),Math.round(pixelRatio*canvasHeightInUnits/sourceResolution));var stitchScale=pixelRatio/sourceResolution;sources.forEach(function(src,i,arr){var xPos=src.extent[0]-sourceDataExtent[0];var yPos=-(src.extent[3]-sourceDataExtent[3]);var srcWidth=_ol_extent_.getWidth(src.extent);var srcHeight=_ol_extent_.getHeight(src.extent);stitchContext.drawImage(src.image,gutter,gutter,src.image.width-2*gutter,src.image.height-2*gutter,xPos*stitchScale,yPos*stitchScale,srcWidth*stitchScale,srcHeight*stitchScale);});var targetTopLeft=_ol_extent_.getTopLeft(targetExtent);triangulation.getTriangles().forEach(function(triangle,i,arr){/* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */var source=triangle.source,target=triangle.target;var x0=source[0][0],y0=source[0][1],x1=source[1][0],y1=source[1][1],x2=source[2][0],y2=source[2][1];var u0=(target[0][0]-targetTopLeft[0])/targetResolution,v0=-(target[0][1]-targetTopLeft[1])/targetResolution;var u1=(target[1][0]-targetTopLeft[0])/targetResolution,v1=-(target[1][1]-targetTopLeft[1])/targetResolution;var u2=(target[2][0]-targetTopLeft[0])/targetResolution,v2=-(target[2][1]-targetTopLeft[1])/targetResolution;// Shift all the source points to improve numerical stability
// of all the subsequent calculations. The [x0, y0] is used here.
// This is also used to simplify the linear system.
var sourceNumericalShiftX=x0,sourceNumericalShiftY=y0;x0=0;y0=0;x1-=sourceNumericalShiftX;y1-=sourceNumericalShiftY;x2-=sourceNumericalShiftX;y2-=sourceNumericalShiftY;var augmentedMatrix=[[x1,y1,0,0,u1-u0],[x2,y2,0,0,u2-u0],[0,0,x1,y1,v1-v0],[0,0,x2,y2,v2-v0]];var affineCoefs=_ol_math_.solveLinearSystem(augmentedMatrix);if(!affineCoefs){return;}context.save();context.beginPath();var centroidX=(u0+u1+u2)/3,centroidY=(v0+v1+v2)/3;var p0=_ol_reproj_.enlargeClipPoint_(centroidX,centroidY,u0,v0);var p1=_ol_reproj_.enlargeClipPoint_(centroidX,centroidY,u1,v1);var p2=_ol_reproj_.enlargeClipPoint_(centroidX,centroidY,u2,v2);context.moveTo(p1[0],p1[1]);context.lineTo(p0[0],p0[1]);context.lineTo(p2[0],p2[1]);context.clip();context.transform(affineCoefs[0],affineCoefs[2],affineCoefs[1],affineCoefs[3],u0,v0);context.translate(sourceDataExtent[0]-sourceNumericalShiftX,sourceDataExtent[3]-sourceNumericalShiftY);context.scale(sourceResolution/pixelRatio,-sourceResolution/pixelRatio);context.drawImage(stitchContext.canvas,0,0);context.restore();});if(opt_renderEdges){context.save();context.strokeStyle='black';context.lineWidth=1;triangulation.getTriangles().forEach(function(triangle,i,arr){var target=triangle.target;var u0=(target[0][0]-targetTopLeft[0])/targetResolution,v0=-(target[0][1]-targetTopLeft[1])/targetResolution;var u1=(target[1][0]-targetTopLeft[0])/targetResolution,v1=-(target[1][1]-targetTopLeft[1])/targetResolution;var u2=(target[2][0]-targetTopLeft[0])/targetResolution,v2=-(target[2][1]-targetTopLeft[1])/targetResolution;context.beginPath();context.moveTo(u1,v1);context.lineTo(u0,v0);context.lineTo(u2,v2);context.closePath();context.stroke();});context.restore();}return context.canvas;};/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Extent} targetExtent Target extent to triangulate.
 * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.
 * @param {number} errorThreshold Acceptable error (in source units).
 * @constructor
 */var _ol_reproj_Triangulation_=function(sourceProj,targetProj,targetExtent,maxSourceExtent,errorThreshold){/**
   * @type {ol.proj.Projection}
   * @private
   */this.sourceProj_=sourceProj;/**
   * @type {ol.proj.Projection}
   * @private
   */this.targetProj_=targetProj;/** @type {!Object.<string, ol.Coordinate>} */var transformInvCache={};var transformInv=_ol_proj_.getTransform(this.targetProj_,this.sourceProj_);/**
   * @param {ol.Coordinate} c A coordinate.
   * @return {ol.Coordinate} Transformed coordinate.
   * @private
   */this.transformInv_=function(c){var key=c[0]+'/'+c[1];if(!transformInvCache[key]){transformInvCache[key]=transformInv(c);}return transformInvCache[key];};/**
   * @type {ol.Extent}
   * @private
   */this.maxSourceExtent_=maxSourceExtent;/**
   * @type {number}
   * @private
   */this.errorThresholdSquared_=errorThreshold*errorThreshold;/**
   * @type {Array.<ol.ReprojTriangle>}
   * @private
   */this.triangles_=[];/**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */this.wrapsXInSource_=false;/**
   * @type {boolean}
   * @private
   */this.canWrapXInSource_=this.sourceProj_.canWrapX()&&!!maxSourceExtent&&!!this.sourceProj_.getExtent()&&_ol_extent_.getWidth(maxSourceExtent)==_ol_extent_.getWidth(this.sourceProj_.getExtent());/**
   * @type {?number}
   * @private
   */this.sourceWorldWidth_=this.sourceProj_.getExtent()?_ol_extent_.getWidth(this.sourceProj_.getExtent()):null;/**
   * @type {?number}
   * @private
   */this.targetWorldWidth_=this.targetProj_.getExtent()?_ol_extent_.getWidth(this.targetProj_.getExtent()):null;var destinationTopLeft=_ol_extent_.getTopLeft(targetExtent);var destinationTopRight=_ol_extent_.getTopRight(targetExtent);var destinationBottomRight=_ol_extent_.getBottomRight(targetExtent);var destinationBottomLeft=_ol_extent_.getBottomLeft(targetExtent);var sourceTopLeft=this.transformInv_(destinationTopLeft);var sourceTopRight=this.transformInv_(destinationTopRight);var sourceBottomRight=this.transformInv_(destinationBottomRight);var sourceBottomLeft=this.transformInv_(destinationBottomLeft);this.addQuad_(destinationTopLeft,destinationTopRight,destinationBottomRight,destinationBottomLeft,sourceTopLeft,sourceTopRight,sourceBottomRight,sourceBottomLeft,_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION);if(this.wrapsXInSource_){var leftBound=Infinity;this.triangles_.forEach(function(triangle,i,arr){leftBound=Math.min(leftBound,triangle.source[0][0],triangle.source[1][0],triangle.source[2][0]);});// Shift triangles to be as close to `leftBound` as possible
// (if the distance is more than `worldWidth / 2` it can be closer.
this.triangles_.forEach(function(triangle){if(Math.max(triangle.source[0][0],triangle.source[1][0],triangle.source[2][0])-leftBound>this.sourceWorldWidth_/2){var newTriangle=[[triangle.source[0][0],triangle.source[0][1]],[triangle.source[1][0],triangle.source[1][1]],[triangle.source[2][0],triangle.source[2][1]]];if(newTriangle[0][0]-leftBound>this.sourceWorldWidth_/2){newTriangle[0][0]-=this.sourceWorldWidth_;}if(newTriangle[1][0]-leftBound>this.sourceWorldWidth_/2){newTriangle[1][0]-=this.sourceWorldWidth_;}if(newTriangle[2][0]-leftBound>this.sourceWorldWidth_/2){newTriangle[2][0]-=this.sourceWorldWidth_;}// Rarely (if the extent contains both the dateline and prime meridian)
// the shift can in turn break some triangles.
// Detect this here and don't shift in such cases.
var minX=Math.min(newTriangle[0][0],newTriangle[1][0],newTriangle[2][0]);var maxX=Math.max(newTriangle[0][0],newTriangle[1][0],newTriangle[2][0]);if(maxX-minX<this.sourceWorldWidth_/2){triangle.source=newTriangle;}}},this);}transformInvCache={};};/**
 * Adds triangle to the triangulation.
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @private
 */_ol_reproj_Triangulation_.prototype.addTriangle_=function(a,b,c,aSrc,bSrc,cSrc){this.triangles_.push({source:[aSrc,bSrc,cSrc],target:[a,b,c]});};/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} d The target d coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @param {ol.Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */_ol_reproj_Triangulation_.prototype.addQuad_=function(a,b,c,d,aSrc,bSrc,cSrc,dSrc,maxSubdivision){var sourceQuadExtent=_ol_extent_.boundingExtent([aSrc,bSrc,cSrc,dSrc]);var sourceCoverageX=this.sourceWorldWidth_?_ol_extent_.getWidth(sourceQuadExtent)/this.sourceWorldWidth_:null;var sourceWorldWidth=/** @type {number} */this.sourceWorldWidth_;// when the quad is wrapped in the source projection
// it covers most of the projection extent, but not fully
var wrapsX=this.sourceProj_.canWrapX()&&sourceCoverageX>0.5&&sourceCoverageX<1;var needsSubdivision=false;if(maxSubdivision>0){if(this.targetProj_.isGlobal()&&this.targetWorldWidth_){var targetQuadExtent=_ol_extent_.boundingExtent([a,b,c,d]);var targetCoverageX=_ol_extent_.getWidth(targetQuadExtent)/this.targetWorldWidth_;needsSubdivision|=targetCoverageX>_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;}if(!wrapsX&&this.sourceProj_.isGlobal()&&sourceCoverageX){needsSubdivision|=sourceCoverageX>_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;}}if(!needsSubdivision&&this.maxSourceExtent_){if(!_ol_extent_.intersects(sourceQuadExtent,this.maxSourceExtent_)){// whole quad outside source projection extent -> ignore
return;}}if(!needsSubdivision){if(!isFinite(aSrc[0])||!isFinite(aSrc[1])||!isFinite(bSrc[0])||!isFinite(bSrc[1])||!isFinite(cSrc[0])||!isFinite(cSrc[1])||!isFinite(dSrc[0])||!isFinite(dSrc[1])){if(maxSubdivision>0){needsSubdivision=true;}else{return;}}}if(maxSubdivision>0){if(!needsSubdivision){var center=[(a[0]+c[0])/2,(a[1]+c[1])/2];var centerSrc=this.transformInv_(center);var dx;if(wrapsX){var centerSrcEstimX=(_ol_math_.modulo(aSrc[0],sourceWorldWidth)+_ol_math_.modulo(cSrc[0],sourceWorldWidth))/2;dx=centerSrcEstimX-_ol_math_.modulo(centerSrc[0],sourceWorldWidth);}else{dx=(aSrc[0]+cSrc[0])/2-centerSrc[0];}var dy=(aSrc[1]+cSrc[1])/2-centerSrc[1];var centerSrcErrorSquared=dx*dx+dy*dy;needsSubdivision=centerSrcErrorSquared>this.errorThresholdSquared_;}if(needsSubdivision){if(Math.abs(a[0]-c[0])<=Math.abs(a[1]-c[1])){// split horizontally (top & bottom)
var bc=[(b[0]+c[0])/2,(b[1]+c[1])/2];var bcSrc=this.transformInv_(bc);var da=[(d[0]+a[0])/2,(d[1]+a[1])/2];var daSrc=this.transformInv_(da);this.addQuad_(a,b,bc,da,aSrc,bSrc,bcSrc,daSrc,maxSubdivision-1);this.addQuad_(da,bc,c,d,daSrc,bcSrc,cSrc,dSrc,maxSubdivision-1);}else{// split vertically (left & right)
var ab=[(a[0]+b[0])/2,(a[1]+b[1])/2];var abSrc=this.transformInv_(ab);var cd=[(c[0]+d[0])/2,(c[1]+d[1])/2];var cdSrc=this.transformInv_(cd);this.addQuad_(a,ab,cd,d,aSrc,abSrc,cdSrc,dSrc,maxSubdivision-1);this.addQuad_(ab,b,c,cd,abSrc,bSrc,cSrc,cdSrc,maxSubdivision-1);}return;}}if(wrapsX){if(!this.canWrapXInSource_){return;}this.wrapsXInSource_=true;}this.addTriangle_(a,c,d,aSrc,cSrc,dSrc);this.addTriangle_(a,b,c,aSrc,bSrc,cSrc);};/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {ol.Extent} Calculated extent.
 */_ol_reproj_Triangulation_.prototype.calculateSourceExtent=function(){var extent=_ol_extent_.createEmpty();this.triangles_.forEach(function(triangle,i,arr){var src=triangle.source;_ol_extent_.extendCoordinate(extent,src[0]);_ol_extent_.extendCoordinate(extent,src[1]);_ol_extent_.extendCoordinate(extent,src[2]);});return extent;};/**
 * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.
 */_ol_reproj_Triangulation_.prototype.getTriangles=function(){return this.triangles_;};/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link ol.source.TileImage}.
 *
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.tilegrid.TileGrid} sourceTileGrid Source tile grid.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.tilegrid.TileGrid} targetTileGrid Target tile grid.
 * @param {ol.TileCoord} tileCoord Coordinate of the tile.
 * @param {ol.TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} gutter Gutter of the source tiles.
 * @param {ol.ReprojTileFunctionType} getTileFunction
 *     Function returning source tiles (z, x, y, pixelRatio).
 * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 */var _ol_reproj_Tile_=function(sourceProj,sourceTileGrid,targetProj,targetTileGrid,tileCoord,wrappedTileCoord,pixelRatio,gutter,getTileFunction,opt_errorThreshold,opt_renderEdges){_ol_Tile_.call(this,tileCoord,_ol_TileState_.IDLE);/**
   * @private
   * @type {boolean}
   */this.renderEdges_=opt_renderEdges!==undefined?opt_renderEdges:false;/**
   * @private
   * @type {number}
   */this.pixelRatio_=pixelRatio;/**
   * @private
   * @type {number}
   */this.gutter_=gutter;/**
   * @private
   * @type {HTMLCanvasElement}
   */this.canvas_=null;/**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */this.sourceTileGrid_=sourceTileGrid;/**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */this.targetTileGrid_=targetTileGrid;/**
   * @private
   * @type {ol.TileCoord}
   */this.wrappedTileCoord_=wrappedTileCoord?wrappedTileCoord:tileCoord;/**
   * @private
   * @type {!Array.<ol.Tile>}
   */this.sourceTiles_=[];/**
   * @private
   * @type {Array.<ol.EventsKey>}
   */this.sourcesListenerKeys_=null;/**
   * @private
   * @type {number}
   */this.sourceZ_=0;var targetExtent=targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);var maxTargetExtent=this.targetTileGrid_.getExtent();var maxSourceExtent=this.sourceTileGrid_.getExtent();var limitedTargetExtent=maxTargetExtent?_ol_extent_.getIntersection(targetExtent,maxTargetExtent):targetExtent;if(_ol_extent_.getArea(limitedTargetExtent)===0){// Tile is completely outside range -> EMPTY
// TODO: is it actually correct that the source even creates the tile ?
this.state=_ol_TileState_.EMPTY;return;}var sourceProjExtent=sourceProj.getExtent();if(sourceProjExtent){if(!maxSourceExtent){maxSourceExtent=sourceProjExtent;}else{maxSourceExtent=_ol_extent_.getIntersection(maxSourceExtent,sourceProjExtent);}}var targetResolution=targetTileGrid.getResolution(this.wrappedTileCoord_[0]);var targetCenter=_ol_extent_.getCenter(limitedTargetExtent);var sourceResolution=_ol_reproj_.calculateSourceResolution(sourceProj,targetProj,targetCenter,targetResolution);if(!isFinite(sourceResolution)||sourceResolution<=0){// invalid sourceResolution -> EMPTY
// probably edges of the projections when no extent is defined
this.state=_ol_TileState_.EMPTY;return;}var errorThresholdInPixels=opt_errorThreshold!==undefined?opt_errorThreshold:_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;/**
   * @private
   * @type {!ol.reproj.Triangulation}
   */this.triangulation_=new _ol_reproj_Triangulation_(sourceProj,targetProj,limitedTargetExtent,maxSourceExtent,sourceResolution*errorThresholdInPixels);if(this.triangulation_.getTriangles().length===0){// no valid triangles -> EMPTY
this.state=_ol_TileState_.EMPTY;return;}this.sourceZ_=sourceTileGrid.getZForResolution(sourceResolution);var sourceExtent=this.triangulation_.calculateSourceExtent();if(maxSourceExtent){if(sourceProj.canWrapX()){sourceExtent[1]=_ol_math_.clamp(sourceExtent[1],maxSourceExtent[1],maxSourceExtent[3]);sourceExtent[3]=_ol_math_.clamp(sourceExtent[3],maxSourceExtent[1],maxSourceExtent[3]);}else{sourceExtent=_ol_extent_.getIntersection(sourceExtent,maxSourceExtent);}}if(!_ol_extent_.getArea(sourceExtent)){this.state=_ol_TileState_.EMPTY;}else{var sourceRange=sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent,this.sourceZ_);for(var srcX=sourceRange.minX;srcX<=sourceRange.maxX;srcX++){for(var srcY=sourceRange.minY;srcY<=sourceRange.maxY;srcY++){var tile=getTileFunction(this.sourceZ_,srcX,srcY,pixelRatio);if(tile){this.sourceTiles_.push(tile);}}}if(this.sourceTiles_.length===0){this.state=_ol_TileState_.EMPTY;}}};_ol_.inherits(_ol_reproj_Tile_,_ol_Tile_);/**
 * @inheritDoc
 */_ol_reproj_Tile_.prototype.disposeInternal=function(){if(this.state==_ol_TileState_.LOADING){this.unlistenSources_();}_ol_Tile_.prototype.disposeInternal.call(this);};/**
 * Get the HTML Canvas element for this tile.
 * @return {HTMLCanvasElement} Canvas.
 */_ol_reproj_Tile_.prototype.getImage=function(){return this.canvas_;};/**
 * @private
 */_ol_reproj_Tile_.prototype.reproject_=function(){var sources=[];this.sourceTiles_.forEach(function(tile,i,arr){if(tile&&tile.getState()==_ol_TileState_.LOADED){sources.push({extent:this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),image:tile.getImage()});}},this);this.sourceTiles_.length=0;if(sources.length===0){this.state=_ol_TileState_.ERROR;}else{var z=this.wrappedTileCoord_[0];var size=this.targetTileGrid_.getTileSize(z);var width=typeof size==='number'?size:size[0];var height=typeof size==='number'?size:size[1];var targetResolution=this.targetTileGrid_.getResolution(z);var sourceResolution=this.sourceTileGrid_.getResolution(this.sourceZ_);var targetExtent=this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);this.canvas_=_ol_reproj_.render(width,height,this.pixelRatio_,sourceResolution,this.sourceTileGrid_.getExtent(),targetResolution,targetExtent,this.triangulation_,sources,this.gutter_,this.renderEdges_);this.state=_ol_TileState_.LOADED;}this.changed();};/**
 * @inheritDoc
 */_ol_reproj_Tile_.prototype.load=function(){if(this.state==_ol_TileState_.IDLE){this.state=_ol_TileState_.LOADING;this.changed();var leftToLoad=0;this.sourcesListenerKeys_=[];this.sourceTiles_.forEach(function(tile,i,arr){var state=tile.getState();if(state==_ol_TileState_.IDLE||state==_ol_TileState_.LOADING){leftToLoad++;var sourceListenKey;sourceListenKey=_ol_events_.listen(tile,_ol_events_EventType_.CHANGE,function(e){var state=tile.getState();if(state==_ol_TileState_.LOADED||state==_ol_TileState_.ERROR||state==_ol_TileState_.EMPTY){_ol_events_.unlistenByKey(sourceListenKey);leftToLoad--;if(leftToLoad===0){this.unlistenSources_();this.reproject_();}}},this);this.sourcesListenerKeys_.push(sourceListenKey);}},this);this.sourceTiles_.forEach(function(tile,i,arr){var state=tile.getState();if(state==_ol_TileState_.IDLE){tile.load();}});if(leftToLoad===0){setTimeout(this.reproject_.bind(this),0);}}};/**
 * @private
 */_ol_reproj_Tile_.prototype.unlistenSources_=function(){this.sourcesListenerKeys_.forEach(_ol_events_.unlistenByKey);this.sourcesListenerKeys_=null;};var _ol_TileUrlFunction_={};/**
 * @param {string} template Template.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */_ol_TileUrlFunction_.createFromTemplate=function(template,tileGrid){var zRegEx=/\{z\}/g;var xRegEx=/\{x\}/g;var yRegEx=/\{y\}/g;var dashYRegEx=/\{-y\}/g;return(/**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */function(tileCoord,pixelRatio,projection){if(!tileCoord){return undefined;}else{return template.replace(zRegEx,tileCoord[0].toString()).replace(xRegEx,tileCoord[1].toString()).replace(yRegEx,function(){var y=-tileCoord[2]-1;return y.toString();}).replace(dashYRegEx,function(){var z=tileCoord[0];var range=tileGrid.getFullTileRange(z);_ol_asserts_.assert(range,55);// The {-y} placeholder requires a tile grid with extent
var y=range.getHeight()+tileCoord[2];return y.toString();});}});};/**
 * @param {Array.<string>} templates Templates.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */_ol_TileUrlFunction_.createFromTemplates=function(templates,tileGrid){var len=templates.length;var tileUrlFunctions=new Array(len);for(var i=0;i<len;++i){tileUrlFunctions[i]=_ol_TileUrlFunction_.createFromTemplate(templates[i],tileGrid);}return _ol_TileUrlFunction_.createFromTileUrlFunctions(tileUrlFunctions);};/**
 * @param {Array.<ol.TileUrlFunctionType>} tileUrlFunctions Tile URL Functions.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */_ol_TileUrlFunction_.createFromTileUrlFunctions=function(tileUrlFunctions){if(tileUrlFunctions.length===1){return tileUrlFunctions[0];}return(/**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */function(tileCoord,pixelRatio,projection){if(!tileCoord){return undefined;}else{var h=_ol_tilecoord_.hash(tileCoord);var index=_ol_math_.modulo(h,tileUrlFunctions.length);return tileUrlFunctions[index](tileCoord,pixelRatio,projection);}});};/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {string|undefined} Tile URL.
 */_ol_TileUrlFunction_.nullTileUrlFunction=function(tileCoord,pixelRatio,projection){return undefined;};/**
 * @param {string} url URL.
 * @return {Array.<string>} Array of urls.
 */_ol_TileUrlFunction_.expandUrl=function(url){var urls=[];var match=/\{([a-z])-([a-z])\}/.exec(url);if(match){// char range
var startCharCode=match[1].charCodeAt(0);var stopCharCode=match[2].charCodeAt(0);var charCode;for(charCode=startCharCode;charCode<=stopCharCode;++charCode){urls.push(url.replace(match[0],String.fromCharCode(charCode)));}return urls;}match=match=/\{(\d+)-(\d+)\}/.exec(url);if(match){// number range
var stop=parseInt(match[2],10);for(var i=parseInt(match[1],10);i<=stop;i++){urls.push(url.replace(match[0],i.toString()));}return urls;}urls.push(url);return urls;};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @abstract
 * @extends {ol.source.Source}
 * @param {ol.SourceTileOptions} options Tile source options.
 * @api
 */var _ol_source_Tile_=function(options){_ol_source_Source_.call(this,{attributions:options.attributions,extent:options.extent,logo:options.logo,projection:options.projection,state:options.state,wrapX:options.wrapX});/**
   * @private
   * @type {boolean}
   */this.opaque_=options.opaque!==undefined?options.opaque:false;/**
   * @private
   * @type {number}
   */this.tilePixelRatio_=options.tilePixelRatio!==undefined?options.tilePixelRatio:1;/**
   * @protected
   * @type {ol.tilegrid.TileGrid}
   */this.tileGrid=options.tileGrid!==undefined?options.tileGrid:null;/**
   * @protected
   * @type {ol.TileCache}
   */this.tileCache=new _ol_TileCache_(options.cacheSize);/**
   * @protected
   * @type {ol.Size}
   */this.tmpSize=[0,0];/**
   * @private
   * @type {string}
   */this.key_='';};_ol_.inherits(_ol_source_Tile_,_ol_source_Source_);/**
 * @return {boolean} Can expire cache.
 */_ol_source_Tile_.prototype.canExpireCache=function(){return this.tileCache.canExpireCache();};/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */_ol_source_Tile_.prototype.expireCache=function(projection,usedTiles){var tileCache=this.getTileCacheForProjection(projection);if(tileCache){tileCache.expireCache(usedTiles);}};/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {number} z Zoom level.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {function(ol.Tile):(boolean|undefined)} callback Called with each
 *     loaded tile.  If the callback returns `false`, the tile will not be
 *     considered loaded.
 * @return {boolean} The tile range is fully covered with loaded tiles.
 */_ol_source_Tile_.prototype.forEachLoadedTile=function(projection,z,tileRange,callback){var tileCache=this.getTileCacheForProjection(projection);if(!tileCache){return false;}var covered=true;var tile,tileCoordKey,loaded;for(var x=tileRange.minX;x<=tileRange.maxX;++x){for(var y=tileRange.minY;y<=tileRange.maxY;++y){tileCoordKey=this.getKeyZXY(z,x,y);loaded=false;if(tileCache.containsKey(tileCoordKey)){tile=/** @type {!ol.Tile} */tileCache.get(tileCoordKey);loaded=tile.getState()===_ol_TileState_.LOADED;if(loaded){loaded=callback(tile)!==false;}}if(!loaded){covered=false;}}}return covered;};/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {number} Gutter.
 */_ol_source_Tile_.prototype.getGutter=function(projection){return 0;};/**
 * Return the key to be used for all tiles in the source.
 * @return {string} The key for all tiles.
 * @protected
 */_ol_source_Tile_.prototype.getKey=function(){return this.key_;};/**
 * Set the value to be used as the key for all tiles in the source.
 * @param {string} key The key for tiles.
 * @protected
 */_ol_source_Tile_.prototype.setKey=function(key){if(this.key_!==key){this.key_=key;this.changed();}};/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 * @protected
 */_ol_source_Tile_.prototype.getKeyZXY=_ol_tilecoord_.getKeyZXY;/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {boolean} Opaque.
 */_ol_source_Tile_.prototype.getOpaque=function(projection){return this.opaque_;};/**
 * @inheritDoc
 */_ol_source_Tile_.prototype.getResolutions=function(){return this.tileGrid.getResolutions();};/**
 * @abstract
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 */_ol_source_Tile_.prototype.getTile=function(z,x,y,pixelRatio,projection){};/**
 * Return the tile grid of the tile source.
 * @return {ol.tilegrid.TileGrid} Tile grid.
 * @api
 */_ol_source_Tile_.prototype.getTileGrid=function(){return this.tileGrid;};/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Tile grid.
 */_ol_source_Tile_.prototype.getTileGridForProjection=function(projection){if(!this.tileGrid){return _ol_tilegrid_.getForProjection(projection);}else{return this.tileGrid;}};/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCache} Tile cache.
 * @protected
 */_ol_source_Tile_.prototype.getTileCacheForProjection=function(projection){var thisProj=this.getProjection();if(thisProj&&!_ol_proj_.equivalent(thisProj,projection)){return null;}else{return this.tileCache;}};/**
 * Get the tile pixel ratio for this source. Subclasses may override this
 * method, which is meant to return a supported pixel ratio that matches the
 * provided `pixelRatio` as close as possible.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Tile pixel ratio.
 */_ol_source_Tile_.prototype.getTilePixelRatio=function(pixelRatio){return this.tilePixelRatio_;};/**
 * @param {number} z Z.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.Size} Tile size.
 */_ol_source_Tile_.prototype.getTilePixelSize=function(z,pixelRatio,projection){var tileGrid=this.getTileGridForProjection(projection);var tilePixelRatio=this.getTilePixelRatio(pixelRatio);var tileSize=_ol_size_.toSize(tileGrid.getTileSize(z),this.tmpSize);if(tilePixelRatio==1){return tileSize;}else{return _ol_size_.scale(tileSize,tilePixelRatio,this.tmpSize);}};/**
 * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
 * is outside the resolution and extent range of the tile grid, `null` will be
 * returned.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection=} opt_projection Projection.
 * @return {ol.TileCoord} Tile coordinate to be passed to the tileUrlFunction or
 *     null if no tile URL should be created for the passed `tileCoord`.
 */_ol_source_Tile_.prototype.getTileCoordForTileUrlFunction=function(tileCoord,opt_projection){var projection=opt_projection!==undefined?opt_projection:this.getProjection();var tileGrid=this.getTileGridForProjection(projection);if(this.getWrapX()&&projection.isGlobal()){tileCoord=_ol_tilegrid_.wrapX(tileGrid,tileCoord,projection);}return _ol_tilecoord_.withinExtentAndZ(tileCoord,tileGrid)?tileCoord:null;};/**
 * @inheritDoc
 */_ol_source_Tile_.prototype.refresh=function(){this.tileCache.clear();this.changed();};/**
 * Marks a tile coord as being used, without triggering a load.
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {ol.proj.Projection} projection Projection.
 */_ol_source_Tile_.prototype.useTile=_ol_.nullFunction;/**
 * @classdesc
 * Events emitted by {@link ol.source.Tile} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Tile.Event}
 * @param {string} type Type.
 * @param {ol.Tile} tile The tile.
 */_ol_source_Tile_.Event=function(type,tile){_ol_events_Event_.call(this,type);/**
   * The tile related to the event.
   * @type {ol.Tile}
   * @api
   */this.tile=tile;};_ol_.inherits(_ol_source_Tile_.Event,_ol_events_Event_);/**
 * @enum {string}
 */var _ol_source_TileEventType_={/**
   * Triggered when a tile starts loading.
   * @event ol.source.Tile.Event#tileloadstart
   * @api
   */TILELOADSTART:'tileloadstart',/**
   * Triggered when a tile finishes loading.
   * @event ol.source.Tile.Event#tileloadend
   * @api
   */TILELOADEND:'tileloadend',/**
   * Triggered if tile loading results in an error.
   * @event ol.source.Tile.Event#tileloaderror
   * @api
   */TILELOADERROR:'tileloaderror'};/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @constructor
 * @abstract
 * @fires ol.source.Tile.Event
 * @extends {ol.source.Tile}
 * @param {ol.SourceUrlTileOptions} options Image tile options.
 */var _ol_source_UrlTile_=function(options){_ol_source_Tile_.call(this,{attributions:options.attributions,cacheSize:options.cacheSize,extent:options.extent,logo:options.logo,opaque:options.opaque,projection:options.projection,state:options.state,tileGrid:options.tileGrid,tilePixelRatio:options.tilePixelRatio,wrapX:options.wrapX});/**
   * @protected
   * @type {ol.TileLoadFunctionType}
   */this.tileLoadFunction=options.tileLoadFunction;/**
   * @protected
   * @type {ol.TileUrlFunctionType}
   */this.tileUrlFunction=this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):_ol_TileUrlFunction_.nullTileUrlFunction;/**
   * @protected
   * @type {!Array.<string>|null}
   */this.urls=null;if(options.urls){this.setUrls(options.urls);}else if(options.url){this.setUrl(options.url);}if(options.tileUrlFunction){this.setTileUrlFunction(options.tileUrlFunction);}};_ol_.inherits(_ol_source_UrlTile_,_ol_source_Tile_);/**
 * Return the tile load function of the source.
 * @return {ol.TileLoadFunctionType} TileLoadFunction
 * @api
 */_ol_source_UrlTile_.prototype.getTileLoadFunction=function(){return this.tileLoadFunction;};/**
 * Return the tile URL function of the source.
 * @return {ol.TileUrlFunctionType} TileUrlFunction
 * @api
 */_ol_source_UrlTile_.prototype.getTileUrlFunction=function(){return this.tileUrlFunction;};/**
 * Return the URLs used for this source.
 * When a tileUrlFunction is used instead of url or urls,
 * null will be returned.
 * @return {!Array.<string>|null} URLs.
 * @api
 */_ol_source_UrlTile_.prototype.getUrls=function(){return this.urls;};/**
 * Handle tile change events.
 * @param {ol.events.Event} event Event.
 * @protected
 */_ol_source_UrlTile_.prototype.handleTileChange=function(event){var tile=/** @type {ol.Tile} */event.target;switch(tile.getState()){case _ol_TileState_.LOADING:this.dispatchEvent(new _ol_source_Tile_.Event(_ol_source_TileEventType_.TILELOADSTART,tile));break;case _ol_TileState_.LOADED:this.dispatchEvent(new _ol_source_Tile_.Event(_ol_source_TileEventType_.TILELOADEND,tile));break;case _ol_TileState_.ERROR:this.dispatchEvent(new _ol_source_Tile_.Event(_ol_source_TileEventType_.TILELOADERROR,tile));break;default:// pass
}};/**
 * Set the tile load function of the source.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @api
 */_ol_source_UrlTile_.prototype.setTileLoadFunction=function(tileLoadFunction){this.tileCache.clear();this.tileLoadFunction=tileLoadFunction;this.changed();};/**
 * Set the tile URL function of the source.
 * @param {ol.TileUrlFunctionType} tileUrlFunction Tile URL function.
 * @param {string=} opt_key Optional new tile key for the source.
 * @api
 */_ol_source_UrlTile_.prototype.setTileUrlFunction=function(tileUrlFunction,opt_key){this.tileUrlFunction=tileUrlFunction;if(typeof opt_key!=='undefined'){this.setKey(opt_key);}else{this.changed();}};/**
 * Set the URL to use for requests.
 * @param {string} url URL.
 * @api
 */_ol_source_UrlTile_.prototype.setUrl=function(url){var urls=this.urls=_ol_TileUrlFunction_.expandUrl(url);this.setTileUrlFunction(this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):_ol_TileUrlFunction_.createFromTemplates(urls,this.tileGrid),url);};/**
 * Set the URLs to use for requests.
 * @param {Array.<string>} urls URLs.
 * @api
 */_ol_source_UrlTile_.prototype.setUrls=function(urls){this.urls=urls;var key=urls.join('\n');this.setTileUrlFunction(this.fixedTileUrlFunction?this.fixedTileUrlFunction.bind(this):_ol_TileUrlFunction_.createFromTemplates(urls,this.tileGrid),key);};/**
 * @inheritDoc
 */_ol_source_UrlTile_.prototype.useTile=function(z,x,y){var tileCoordKey=this.getKeyZXY(z,x,y);if(this.tileCache.containsKey(tileCoordKey)){this.tileCache.get(tileCoordKey);}};/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @fires ol.source.Tile.Event
 * @extends {ol.source.UrlTile}
 * @param {olx.source.TileImageOptions} options Image tile options.
 * @api
 */var _ol_source_TileImage_=function(options){_ol_source_UrlTile_.call(this,{attributions:options.attributions,cacheSize:options.cacheSize,extent:options.extent,logo:options.logo,opaque:options.opaque,projection:options.projection,state:options.state,tileGrid:options.tileGrid,tileLoadFunction:options.tileLoadFunction?options.tileLoadFunction:_ol_source_TileImage_.defaultTileLoadFunction,tilePixelRatio:options.tilePixelRatio,tileUrlFunction:options.tileUrlFunction,url:options.url,urls:options.urls,wrapX:options.wrapX});/**
   * @protected
   * @type {?string}
   */this.crossOrigin=options.crossOrigin!==undefined?options.crossOrigin:null;/**
   * @protected
   * @type {function(new: ol.ImageTile, ol.TileCoord, ol.TileState, string,
   *        ?string, ol.TileLoadFunctionType)}
   */this.tileClass=options.tileClass!==undefined?options.tileClass:_ol_ImageTile_;/**
   * @protected
   * @type {Object.<string, ol.TileCache>}
   */this.tileCacheForProjection={};/**
   * @protected
   * @type {Object.<string, ol.tilegrid.TileGrid>}
   */this.tileGridForProjection={};/**
   * @private
   * @type {number|undefined}
   */this.reprojectionErrorThreshold_=options.reprojectionErrorThreshold;/**
   * @private
   * @type {boolean}
   */this.renderReprojectionEdges_=false;};_ol_.inherits(_ol_source_TileImage_,_ol_source_UrlTile_);/**
 * @inheritDoc
 */_ol_source_TileImage_.prototype.canExpireCache=function(){if(!_ol_.ENABLE_RASTER_REPROJECTION){return _ol_source_UrlTile_.prototype.canExpireCache.call(this);}if(this.tileCache.canExpireCache()){return true;}else{for(var key in this.tileCacheForProjection){if(this.tileCacheForProjection[key].canExpireCache()){return true;}}}return false;};/**
 * @inheritDoc
 */_ol_source_TileImage_.prototype.expireCache=function(projection,usedTiles){if(!_ol_.ENABLE_RASTER_REPROJECTION){_ol_source_UrlTile_.prototype.expireCache.call(this,projection,usedTiles);return;}var usedTileCache=this.getTileCacheForProjection(projection);this.tileCache.expireCache(this.tileCache==usedTileCache?usedTiles:{});for(var id in this.tileCacheForProjection){var tileCache=this.tileCacheForProjection[id];tileCache.expireCache(tileCache==usedTileCache?usedTiles:{});}};/**
 * @inheritDoc
 */_ol_source_TileImage_.prototype.getGutter=function(projection){if(_ol_.ENABLE_RASTER_REPROJECTION&&this.getProjection()&&projection&&!_ol_proj_.equivalent(this.getProjection(),projection)){return 0;}else{return this.getGutterInternal();}};/**
 * @protected
 * @return {number} Gutter.
 */_ol_source_TileImage_.prototype.getGutterInternal=function(){return 0;};/**
 * @inheritDoc
 */_ol_source_TileImage_.prototype.getOpaque=function(projection){if(_ol_.ENABLE_RASTER_REPROJECTION&&this.getProjection()&&projection&&!_ol_proj_.equivalent(this.getProjection(),projection)){return false;}else{return _ol_source_UrlTile_.prototype.getOpaque.call(this,projection);}};/**
 * @inheritDoc
 */_ol_source_TileImage_.prototype.getTileGridForProjection=function(projection){if(!_ol_.ENABLE_RASTER_REPROJECTION){return _ol_source_UrlTile_.prototype.getTileGridForProjection.call(this,projection);}var thisProj=this.getProjection();if(this.tileGrid&&(!thisProj||_ol_proj_.equivalent(thisProj,projection))){return this.tileGrid;}else{var projKey=_ol_.getUid(projection).toString();if(!(projKey in this.tileGridForProjection)){this.tileGridForProjection[projKey]=_ol_tilegrid_.getForProjection(projection);}return(/** @type {!ol.tilegrid.TileGrid} */this.tileGridForProjection[projKey]);}};/**
 * @inheritDoc
 */_ol_source_TileImage_.prototype.getTileCacheForProjection=function(projection){if(!_ol_.ENABLE_RASTER_REPROJECTION){return _ol_source_UrlTile_.prototype.getTileCacheForProjection.call(this,projection);}var thisProj=this.getProjection();if(!thisProj||_ol_proj_.equivalent(thisProj,projection)){return this.tileCache;}else{var projKey=_ol_.getUid(projection).toString();if(!(projKey in this.tileCacheForProjection)){this.tileCacheForProjection[projKey]=new _ol_TileCache_(this.tileCache.highWaterMark);}return this.tileCacheForProjection[projKey];}};/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {string} key The key set on the tile.
 * @return {!ol.Tile} Tile.
 * @private
 */_ol_source_TileImage_.prototype.createTile_=function(z,x,y,pixelRatio,projection,key){var tileCoord=[z,x,y];var urlTileCoord=this.getTileCoordForTileUrlFunction(tileCoord,projection);var tileUrl=urlTileCoord?this.tileUrlFunction(urlTileCoord,pixelRatio,projection):undefined;var tile=new this.tileClass(tileCoord,tileUrl!==undefined?_ol_TileState_.IDLE:_ol_TileState_.EMPTY,tileUrl!==undefined?tileUrl:'',this.crossOrigin,this.tileLoadFunction);tile.key=key;_ol_events_.listen(tile,_ol_events_EventType_.CHANGE,this.handleTileChange,this);return tile;};/**
 * @inheritDoc
 */_ol_source_TileImage_.prototype.getTile=function(z,x,y,pixelRatio,projection){if(!_ol_.ENABLE_RASTER_REPROJECTION||!this.getProjection()||!projection||_ol_proj_.equivalent(this.getProjection(),projection)){return this.getTileInternal(z,x,y,pixelRatio,/** @type {!ol.proj.Projection} */projection);}else{var cache=this.getTileCacheForProjection(projection);var tileCoord=[z,x,y];var tile;var tileCoordKey=this.getKeyZXY.apply(this,tileCoord);if(cache.containsKey(tileCoordKey)){tile=/** @type {!ol.Tile} */cache.get(tileCoordKey);}var key=this.getKey();if(tile&&tile.key==key){return tile;}else{var sourceProjection=/** @type {!ol.proj.Projection} */this.getProjection();var sourceTileGrid=this.getTileGridForProjection(sourceProjection);var targetTileGrid=this.getTileGridForProjection(projection);var wrappedTileCoord=this.getTileCoordForTileUrlFunction(tileCoord,projection);var newTile=new _ol_reproj_Tile_(sourceProjection,sourceTileGrid,projection,targetTileGrid,tileCoord,wrappedTileCoord,this.getTilePixelRatio(pixelRatio),this.getGutterInternal(),function(z,x,y,pixelRatio){return this.getTileInternal(z,x,y,pixelRatio,sourceProjection);}.bind(this),this.reprojectionErrorThreshold_,this.renderReprojectionEdges_);newTile.key=key;if(tile){newTile.interimTile=tile;newTile.refreshInterimChain();cache.replace(tileCoordKey,newTile);}else{cache.set(tileCoordKey,newTile);}return newTile;}}};/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 * @protected
 */_ol_source_TileImage_.prototype.getTileInternal=function(z,x,y,pixelRatio,projection){var tile=null;var tileCoordKey=this.getKeyZXY(z,x,y);var key=this.getKey();if(!this.tileCache.containsKey(tileCoordKey)){tile=this.createTile_(z,x,y,pixelRatio,projection,key);this.tileCache.set(tileCoordKey,tile);}else{tile=this.tileCache.get(tileCoordKey);if(tile.key!=key){// The source's params changed. If the tile has an interim tile and if we
// can use it then we use it. Otherwise we create a new tile.  In both
// cases we attempt to assign an interim tile to the new tile.
var interimTile=tile;tile=this.createTile_(z,x,y,pixelRatio,projection,key);//make the new tile the head of the list,
if(interimTile.getState()==_ol_TileState_.IDLE){//the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
tile.interimTile=interimTile.interimTile;}else{tile.interimTile=interimTile;}tile.refreshInterimChain();this.tileCache.replace(tileCoordKey,tile);}}return tile;};/**
 * Sets whether to render reprojection edges or not (usually for debugging).
 * @param {boolean} render Render the edges.
 * @api
 */_ol_source_TileImage_.prototype.setRenderReprojectionEdges=function(render){if(!_ol_.ENABLE_RASTER_REPROJECTION||this.renderReprojectionEdges_==render){return;}this.renderReprojectionEdges_=render;for(var id in this.tileCacheForProjection){this.tileCacheForProjection[id].clear();}this.changed();};/**
 * Sets the tile grid to use when reprojecting the tiles to the given
 * projection instead of the default tile grid for the projection.
 *
 * This can be useful when the default tile grid cannot be created
 * (e.g. projection has no extent defined) or
 * for optimization reasons (custom tile size, resolutions, ...).
 *
 * @param {ol.ProjectionLike} projection Projection.
 * @param {ol.tilegrid.TileGrid} tilegrid Tile grid to use for the projection.
 * @api
 */_ol_source_TileImage_.prototype.setTileGridForProjection=function(projection,tilegrid){if(_ol_.ENABLE_RASTER_REPROJECTION){var proj=_ol_proj_.get(projection);if(proj){var projKey=_ol_.getUid(proj).toString();if(!(projKey in this.tileGridForProjection)){this.tileGridForProjection[projKey]=tilegrid;}}}};/**
 * @param {ol.ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */_ol_source_TileImage_.defaultTileLoadFunction=function(imageTile,src){imageTile.getImage().src=src;};/**
 * @enum {string}
 */var _ol_layer_TileProperty_={PRELOAD:'preload',USE_INTERIM_TILES_ON_ERROR:'useInterimTilesOnError'};/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */var _ol_renderer_canvas_IntermediateCanvas_=function(layer){_ol_renderer_canvas_Layer_.call(this,layer);/**
   * @protected
   * @type {ol.Transform}
   */this.coordinateToCanvasPixelTransform=_ol_transform_.create();/**
   * @private
   * @type {CanvasRenderingContext2D}
   */this.hitCanvasContext_=null;};_ol_.inherits(_ol_renderer_canvas_IntermediateCanvas_,_ol_renderer_canvas_Layer_);/**
 * @inheritDoc
 */_ol_renderer_canvas_IntermediateCanvas_.prototype.composeFrame=function(frameState,layerState,context){this.preCompose(context,frameState);var image=this.getImage();if(image){// clipped rendering if layer extent is set
var extent=layerState.extent;var clipped=extent!==undefined&&!_ol_extent_.containsExtent(extent,frameState.extent)&&_ol_extent_.intersects(extent,frameState.extent);if(clipped){this.clip(context,frameState,/** @type {ol.Extent} */extent);}var imageTransform=this.getImageTransform();// for performance reasons, context.save / context.restore is not used
// to save and restore the transformation matrix and the opacity.
// see http://jsperf.com/context-save-restore-versus-variable
var alpha=context.globalAlpha;context.globalAlpha=layerState.opacity;// for performance reasons, context.setTransform is only used
// when the view is rotated. see http://jsperf.com/canvas-transform
var dx=imageTransform[4];var dy=imageTransform[5];var dw=image.width*imageTransform[0];var dh=image.height*imageTransform[3];context.drawImage(image,0,0,+image.width,+image.height,Math.round(dx),Math.round(dy),Math.round(dw),Math.round(dh));context.globalAlpha=alpha;if(clipped){context.restore();}}this.postCompose(context,frameState,layerState);};/**
 * @abstract
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.
 */_ol_renderer_canvas_IntermediateCanvas_.prototype.getImage=function(){};/**
 * @abstract
 * @return {!ol.Transform} Image transform.
 */_ol_renderer_canvas_IntermediateCanvas_.prototype.getImageTransform=function(){};/**
 * @inheritDoc
 */_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachFeatureAtCoordinate=function(coordinate,frameState,hitTolerance,callback,thisArg){var layer=this.getLayer();var source=layer.getSource();var resolution=frameState.viewState.resolution;var rotation=frameState.viewState.rotation;var skippedFeatureUids=frameState.skippedFeatureUids;return source.forEachFeatureAtCoordinate(coordinate,resolution,rotation,hitTolerance,skippedFeatureUids,/**
       * @param {ol.Feature|ol.render.Feature} feature Feature.
       * @return {?} Callback result.
       */function(feature){return callback.call(thisArg,feature,layer);});};/**
 * @inheritDoc
 */_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachLayerAtCoordinate=function(coordinate,frameState,callback,thisArg){if(!this.getImage()){return undefined;}if(this.getLayer().getSource().forEachFeatureAtCoordinate!==_ol_.nullFunction){// for ImageVector sources use the original hit-detection logic,
// so that for example also transparent polygons are detected
return _ol_renderer_canvas_Layer_.prototype.forEachLayerAtCoordinate.apply(this,arguments);}else{var pixel=_ol_transform_.apply(this.coordinateToCanvasPixelTransform,coordinate.slice());_ol_coordinate_.scale(pixel,frameState.viewState.resolution/this.renderedResolution);if(!this.hitCanvasContext_){this.hitCanvasContext_=_ol_dom_.createCanvasContext2D(1,1);}this.hitCanvasContext_.clearRect(0,0,1,1);this.hitCanvasContext_.drawImage(this.getImage(),pixel[0],pixel[1],1,1,0,0,1,1);var imageData=this.hitCanvasContext_.getImageData(0,0,1,1).data;if(imageData[3]>0){return callback.call(thisArg,this.getLayer(),imageData);}else{return undefined;}}};// FIXME find correct globalCompositeOperation
/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.
 */var _ol_renderer_canvas_TileLayer_=function(tileLayer){_ol_renderer_canvas_IntermediateCanvas_.call(this,tileLayer);/**
   * @protected
   * @type {CanvasRenderingContext2D}
   */this.context=this.context===null?null:_ol_dom_.createCanvasContext2D();/**
   * @private
   * @type {number}
   */this.oversampling_;/**
   * @private
   * @type {ol.Extent}
   */this.renderedExtent_=null;/**
   * @protected
   * @type {number}
   */this.renderedRevision;/**
   * @protected
   * @type {!Array.<ol.Tile>}
   */this.renderedTiles=[];/**
   * @protected
   * @type {ol.Extent}
   */this.tmpExtent=_ol_extent_.createEmpty();/**
   * @private
   * @type {ol.TileRange}
   */this.tmpTileRange_=new _ol_TileRange_(0,0,0,0);/**
   * @private
   * @type {ol.Transform}
   */this.imageTransform_=_ol_transform_.create();/**
   * @protected
   * @type {number}
   */this.zDirection=0;};_ol_.inherits(_ol_renderer_canvas_TileLayer_,_ol_renderer_canvas_IntermediateCanvas_);/**
 * @private
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Tile is drawable.
 */_ol_renderer_canvas_TileLayer_.prototype.isDrawableTile_=function(tile){var tileState=tile.getState();var useInterimTilesOnError=this.getLayer().getUseInterimTilesOnError();return tileState==_ol_TileState_.LOADED||tileState==_ol_TileState_.EMPTY||tileState==_ol_TileState_.ERROR&&!useInterimTilesOnError;};/**
 * @inheritDoc
 */_ol_renderer_canvas_TileLayer_.prototype.prepareFrame=function(frameState,layerState){var pixelRatio=frameState.pixelRatio;var size=frameState.size;var viewState=frameState.viewState;var projection=viewState.projection;var viewResolution=viewState.resolution;var viewCenter=viewState.center;var tileLayer=this.getLayer();var tileSource=/** @type {ol.source.Tile} */tileLayer.getSource();var sourceRevision=tileSource.getRevision();var tileGrid=tileSource.getTileGridForProjection(projection);var z=tileGrid.getZForResolution(viewResolution,this.zDirection);var tileResolution=tileGrid.getResolution(z);var oversampling=Math.round(viewResolution/tileResolution)||1;var extent=frameState.extent;if(layerState.extent!==undefined){extent=_ol_extent_.getIntersection(extent,layerState.extent);}if(_ol_extent_.isEmpty(extent)){// Return false to prevent the rendering of the layer.
return false;}var tileRange=tileGrid.getTileRangeForExtentAndResolution(extent,tileResolution);var imageExtent=tileGrid.getTileRangeExtent(z,tileRange);var tilePixelRatio=tileSource.getTilePixelRatio(pixelRatio);/**
   * @type {Object.<number, Object.<string, ol.Tile>>}
   */var tilesToDrawByZ={};tilesToDrawByZ[z]={};var findLoadedTiles=this.createLoadedTileFinder(tileSource,projection,tilesToDrawByZ);var tmpExtent=this.tmpExtent;var tmpTileRange=this.tmpTileRange_;var newTiles=false;var tile,x,y;for(x=tileRange.minX;x<=tileRange.maxX;++x){for(y=tileRange.minY;y<=tileRange.maxY;++y){tile=tileSource.getTile(z,x,y,pixelRatio,projection);if(tile.getState()==_ol_TileState_.ERROR){if(!tileLayer.getUseInterimTilesOnError()){// When useInterimTilesOnError is false, we consider the error tile as loaded.
tile.setState(_ol_TileState_.LOADED);}else if(tileLayer.getPreload()>0){// Preloaded tiles for lower resolutions might have finished loading.
newTiles=true;}}if(!this.isDrawableTile_(tile)){tile=tile.getInterimTile();}if(this.isDrawableTile_(tile)){if(tile.getState()==_ol_TileState_.LOADED){tilesToDrawByZ[z][tile.tileCoord.toString()]=tile;if(!newTiles&&this.renderedTiles.indexOf(tile)==-1){newTiles=true;}}continue;}var fullyLoaded=tileGrid.forEachTileCoordParentTileRange(tile.tileCoord,findLoadedTiles,null,tmpTileRange,tmpExtent);if(!fullyLoaded){var childTileRange=tileGrid.getTileCoordChildTileRange(tile.tileCoord,tmpTileRange,tmpExtent);if(childTileRange){findLoadedTiles(z+1,childTileRange);}}}}var renderedResolution=tileResolution*pixelRatio/tilePixelRatio*oversampling;var hints=frameState.viewHints;var animatingOrInteracting=hints[_ol_ViewHint_.ANIMATING]||hints[_ol_ViewHint_.INTERACTING];if(!(this.renderedResolution&&Date.now()-frameState.time>16&&animatingOrInteracting)&&(newTiles||!(this.renderedExtent_&&_ol_extent_.containsExtent(this.renderedExtent_,extent))||this.renderedRevision!=sourceRevision||oversampling!=this.oversampling_||!animatingOrInteracting&&renderedResolution!=this.renderedResolution)){var context=this.context;if(context){var tilePixelSize=tileSource.getTilePixelSize(z,pixelRatio,projection);var width=Math.round(tileRange.getWidth()*tilePixelSize[0]/oversampling);var height=Math.round(tileRange.getHeight()*tilePixelSize[1]/oversampling);var canvas=context.canvas;if(canvas.width!=width||canvas.height!=height){this.oversampling_=oversampling;canvas.width=width;canvas.height=height;}else{context.clearRect(0,0,width,height);oversampling=this.oversampling_;}}this.renderedTiles.length=0;/** @type {Array.<number>} */var zs=Object.keys(tilesToDrawByZ).map(Number);zs.sort(_ol_array_.numberSafeCompareFunction);var currentResolution,currentScale,currentTilePixelSize,currentZ,i,ii;var tileExtent,tileGutter,tilesToDraw,w,h;for(i=0,ii=zs.length;i<ii;++i){currentZ=zs[i];currentTilePixelSize=tileSource.getTilePixelSize(currentZ,pixelRatio,projection);currentResolution=tileGrid.getResolution(currentZ);currentScale=currentResolution/tileResolution;tileGutter=tilePixelRatio*tileSource.getGutter(projection);tilesToDraw=tilesToDrawByZ[currentZ];for(var tileCoordKey in tilesToDraw){tile=tilesToDraw[tileCoordKey];tileExtent=tileGrid.getTileCoordExtent(tile.getTileCoord(),tmpExtent);x=(tileExtent[0]-imageExtent[0])/tileResolution*tilePixelRatio/oversampling;y=(imageExtent[3]-tileExtent[3])/tileResolution*tilePixelRatio/oversampling;w=currentTilePixelSize[0]*currentScale/oversampling;h=currentTilePixelSize[1]*currentScale/oversampling;this.drawTileImage(tile,frameState,layerState,x,y,w,h,tileGutter);this.renderedTiles.push(tile);}}this.renderedRevision=sourceRevision;this.renderedResolution=tileResolution*pixelRatio/tilePixelRatio*oversampling;this.renderedExtent_=imageExtent;}var scale=this.renderedResolution/viewResolution;var transform=_ol_transform_.compose(this.imageTransform_,pixelRatio*size[0]/2,pixelRatio*size[1]/2,scale,scale,0,(this.renderedExtent_[0]-viewCenter[0])/this.renderedResolution*pixelRatio,(viewCenter[1]-this.renderedExtent_[3])/this.renderedResolution*pixelRatio);_ol_transform_.compose(this.coordinateToCanvasPixelTransform,pixelRatio*size[0]/2-transform[4],pixelRatio*size[1]/2-transform[5],pixelRatio/viewResolution,-pixelRatio/viewResolution,0,-viewCenter[0],-viewCenter[1]);this.updateUsedTiles(frameState.usedTiles,tileSource,z,tileRange);this.manageTilePyramid(frameState,tileSource,tileGrid,pixelRatio,projection,extent,z,tileLayer.getPreload());this.scheduleExpireCache(frameState,tileSource);this.updateLogos(frameState,tileSource);return this.renderedTiles.length>0;};/**
 * @param {ol.Tile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} x Left of the tile.
 * @param {number} y Top of the tile.
 * @param {number} w Width of the tile.
 * @param {number} h Height of the tile.
 * @param {number} gutter Tile gutter.
 */_ol_renderer_canvas_TileLayer_.prototype.drawTileImage=function(tile,frameState,layerState,x,y,w,h,gutter){if(!this.getLayer().getSource().getOpaque(frameState.viewState.projection)){this.context.clearRect(x,y,w,h);}var image=tile.getImage(this.getLayer());if(image){this.context.drawImage(image,gutter,gutter,image.width-2*gutter,image.height-2*gutter,x,y,w,h);}};/**
 * @inheritDoc
 */_ol_renderer_canvas_TileLayer_.prototype.getImage=function(){var context=this.context;return context?context.canvas:null;};/**
 * @inheritDoc
 */_ol_renderer_canvas_TileLayer_.prototype.getImageTransform=function(){return this.imageTransform_;};// This file is automatically generated, do not edit
/* eslint openlayers-internal/no-missing-requires: 0 */// FIXME large resolutions lead to too large framebuffers :-(
// FIXME animated shaders! check in redraw
var _ol_renderer_webgl_TileLayer_;/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.TileOptions=} opt_options Tile layer options.
 * @api
 */var _ol_layer_Tile_=function(opt_options){var options=opt_options?opt_options:{};var baseOptions=_ol_obj_.assign({},options);delete baseOptions.preload;delete baseOptions.useInterimTilesOnError;_ol_layer_Layer_.call(this,/** @type {olx.layer.LayerOptions} */baseOptions);this.setPreload(options.preload!==undefined?options.preload:0);this.setUseInterimTilesOnError(options.useInterimTilesOnError!==undefined?options.useInterimTilesOnError:true);};_ol_.inherits(_ol_layer_Tile_,_ol_layer_Layer_);/**
 * @inheritDoc
 */_ol_layer_Tile_.prototype.createRenderer=function(mapRenderer){var renderer=null;var type=mapRenderer.getType();if(_ol_.ENABLE_CANVAS&&type===_ol_renderer_Type_.CANVAS){renderer=new _ol_renderer_canvas_TileLayer_(this);}else if(false&&type===_ol_renderer_Type_.WEBGL){renderer=new _ol_renderer_webgl_TileLayer_(mapRenderer,this);}return renderer;};/**
 * Return the level as number to which we will preload tiles up to.
 * @return {number} The level to preload tiles up to.
 * @observable
 * @api
 */_ol_layer_Tile_.prototype.getPreload=function(){return(/** @type {number} */this.get(_ol_layer_TileProperty_.PRELOAD));};/**
 * Set the level as number to which we will preload tiles up to.
 * @param {number} preload The level to preload tiles up to.
 * @observable
 * @api
 */_ol_layer_Tile_.prototype.setPreload=function(preload){this.set(_ol_layer_TileProperty_.PRELOAD,preload);};/**
 * Whether we use interim tiles on error.
 * @return {boolean} Use interim tiles on error.
 * @observable
 * @api
 */_ol_layer_Tile_.prototype.getUseInterimTilesOnError=function(){return(/** @type {boolean} */this.get(_ol_layer_TileProperty_.USE_INTERIM_TILES_ON_ERROR));};/**
 * Set whether we use interim tiles on error.
 * @param {boolean} useInterimTilesOnError Use interim tiles on error.
 * @observable
 * @api
 */_ol_layer_Tile_.prototype.setUseInterimTilesOnError=function(useInterimTilesOnError){this.set(_ol_layer_TileProperty_.USE_INTERIM_TILES_ON_ERROR,useInterimTilesOnError);};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {ol.format.Feature} subclasses provide the ability to decode and encode
 * {@link ol.Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @constructor
 * @abstract
 * @api
 */var _ol_format_Feature_=function(){/**
   * @protected
   * @type {ol.proj.Projection}
   */this.defaultDataProjection=null;/**
   * @protected
   * @type {ol.proj.Projection}
   */this.defaultFeatureProjection=null;};/**
 * Adds the data projection to the read options.
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {olx.format.ReadOptions|undefined} Options.
 * @protected
 */_ol_format_Feature_.prototype.getReadOptions=function(source,opt_options){var options;if(opt_options){options={dataProjection:opt_options.dataProjection?opt_options.dataProjection:this.readProjection(source),featureProjection:opt_options.featureProjection};}return this.adaptOptions(options);};/**
 * Sets the `defaultDataProjection` on the options, if no `dataProjection`
 * is set.
 * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options
 *     Options.
 * @protected
 * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}
 *     Updated options.
 */_ol_format_Feature_.prototype.adaptOptions=function(options){return _ol_obj_.assign({dataProjection:this.defaultDataProjection,featureProjection:this.defaultFeatureProjection},options);};/**
 * Get the extent from the source of the last {@link readFeatures} call.
 * @return {ol.Extent} Tile extent.
 */_ol_format_Feature_.prototype.getLastExtent=function(){return null;};/**
 * @abstract
 * @return {ol.format.FormatType} Format.
 */_ol_format_Feature_.prototype.getType=function(){};/**
 * Read a single feature from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 */_ol_format_Feature_.prototype.readFeature=function(source,opt_options){};/**
 * Read all features from a source.
 *
 * @abstract
 * @param {Document|Node|ArrayBuffer|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 */_ol_format_Feature_.prototype.readFeatures=function(source,opt_options){};/**
 * Read a single geometry from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Geometry.
 */_ol_format_Feature_.prototype.readGeometry=function(source,opt_options){};/**
 * Read the projection from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 */_ol_format_Feature_.prototype.readProjection=function(source){};/**
 * Encode a feature in this format.
 *
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */_ol_format_Feature_.prototype.writeFeature=function(feature,opt_options){};/**
 * Encode an array of features in this format.
 *
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */_ol_format_Feature_.prototype.writeFeatures=function(features,opt_options){};/**
 * Write a single geometry in this format.
 *
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */_ol_format_Feature_.prototype.writeGeometry=function(geometry,opt_options){};/**
 * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options
 *     Options.
 * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.
 * @protected
 */_ol_format_Feature_.transformWithOptions=function(geometry,write,opt_options){var featureProjection=opt_options?_ol_proj_.get(opt_options.featureProjection):null;var dataProjection=opt_options?_ol_proj_.get(opt_options.dataProjection):null;/**
   * @type {ol.geom.Geometry|ol.Extent}
   */var transformed;if(featureProjection&&dataProjection&&!_ol_proj_.equivalent(featureProjection,dataProjection)){if(geometry instanceof _ol_geom_Geometry_){transformed=(write?geometry.clone():geometry).transform(write?featureProjection:dataProjection,write?dataProjection:featureProjection);}else{// FIXME this is necessary because ol.format.GML treats extents
// as geometries
transformed=_ol_proj_.transformExtent(geometry,dataProjection,featureProjection);}}else{transformed=geometry;}if(write&&opt_options&&opt_options.decimals!==undefined){var power=Math.pow(10,opt_options.decimals);// if decimals option on write, round each coordinate appropriately
/**
     * @param {Array.<number>} coordinates Coordinates.
     * @return {Array.<number>} Transformed coordinates.
     */var transform=function(coordinates){for(var i=0,ii=coordinates.length;i<ii;++i){coordinates[i]=Math.round(coordinates[i]*power)/power;}return coordinates;};if(transformed===geometry){transformed=transformed.clone();}transformed.applyTransform(transform);}return transformed;};/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @constructor
 * @abstract
 * @extends {ol.format.Feature}
 */var _ol_format_JSONFeature_=function(){_ol_format_Feature_.call(this);};_ol_.inherits(_ol_format_JSONFeature_,_ol_format_Feature_);/**
 * @param {Document|Node|Object|string} source Source.
 * @private
 * @return {Object} Object.
 */_ol_format_JSONFeature_.prototype.getObject_=function(source){if(typeof source==='string'){var object=JSON.parse(source);return object?/** @type {Object} */object:null;}else if(source!==null){return source;}else{return null;}};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.getType=function(){return _ol_format_FormatType_.JSON;};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.readFeature=function(source,opt_options){return this.readFeatureFromObject(this.getObject_(source),this.getReadOptions(source,opt_options));};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.readFeatures=function(source,opt_options){return this.readFeaturesFromObject(this.getObject_(source),this.getReadOptions(source,opt_options));};/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.Feature} Feature.
 */_ol_format_JSONFeature_.prototype.readFeatureFromObject=function(object,opt_options){};/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {Array.<ol.Feature>} Features.
 */_ol_format_JSONFeature_.prototype.readFeaturesFromObject=function(object,opt_options){};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.readGeometry=function(source,opt_options){return this.readGeometryFromObject(this.getObject_(source),this.getReadOptions(source,opt_options));};/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.geom.Geometry} Geometry.
 */_ol_format_JSONFeature_.prototype.readGeometryFromObject=function(object,opt_options){};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.readProjection=function(source){return this.readProjectionFromObject(this.getObject_(source));};/**
 * @abstract
 * @param {Object} object Object.
 * @protected
 * @return {ol.proj.Projection} Projection.
 */_ol_format_JSONFeature_.prototype.readProjectionFromObject=function(object){};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.writeFeature=function(feature,opt_options){return JSON.stringify(this.writeFeatureObject(feature,opt_options));};/**
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */_ol_format_JSONFeature_.prototype.writeFeatureObject=function(feature,opt_options){};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.writeFeatures=function(features,opt_options){return JSON.stringify(this.writeFeaturesObject(features,opt_options));};/**
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */_ol_format_JSONFeature_.prototype.writeFeaturesObject=function(features,opt_options){};/**
 * @inheritDoc
 */_ol_format_JSONFeature_.prototype.writeGeometry=function(geometry,opt_options){return JSON.stringify(this.writeGeometryObject(geometry,opt_options));};/**
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */_ol_format_JSONFeature_.prototype.writeGeometryObject=function(geometry,opt_options){};/**
 * @classdesc
 * An array of {@link ol.geom.Geometry} objects.
 *
 * @constructor
 * @extends {ol.geom.Geometry}
 * @param {Array.<ol.geom.Geometry>=} opt_geometries Geometries.
 * @api
 */var _ol_geom_GeometryCollection_=function(opt_geometries){_ol_geom_Geometry_.call(this);/**
   * @private
   * @type {Array.<ol.geom.Geometry>}
   */this.geometries_=opt_geometries?opt_geometries:null;this.listenGeometriesChange_();};_ol_.inherits(_ol_geom_GeometryCollection_,_ol_geom_Geometry_);/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @private
 * @return {Array.<ol.geom.Geometry>} Cloned geometries.
 */_ol_geom_GeometryCollection_.cloneGeometries_=function(geometries){var clonedGeometries=[];var i,ii;for(i=0,ii=geometries.length;i<ii;++i){clonedGeometries.push(geometries[i].clone());}return clonedGeometries;};/**
 * @private
 */_ol_geom_GeometryCollection_.prototype.unlistenGeometriesChange_=function(){var i,ii;if(!this.geometries_){return;}for(i=0,ii=this.geometries_.length;i<ii;++i){_ol_events_.unlisten(this.geometries_[i],_ol_events_EventType_.CHANGE,this.changed,this);}};/**
 * @private
 */_ol_geom_GeometryCollection_.prototype.listenGeometriesChange_=function(){var i,ii;if(!this.geometries_){return;}for(i=0,ii=this.geometries_.length;i<ii;++i){_ol_events_.listen(this.geometries_[i],_ol_events_EventType_.CHANGE,this.changed,this);}};/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.GeometryCollection} Clone.
 * @override
 * @api
 */_ol_geom_GeometryCollection_.prototype.clone=function(){var geometryCollection=new _ol_geom_GeometryCollection_(null);geometryCollection.setGeometries(this.geometries_);return geometryCollection;};/**
 * @inheritDoc
 */_ol_geom_GeometryCollection_.prototype.closestPointXY=function(x,y,closestPoint,minSquaredDistance){if(minSquaredDistance<_ol_extent_.closestSquaredDistanceXY(this.getExtent(),x,y)){return minSquaredDistance;}var geometries=this.geometries_;var i,ii;for(i=0,ii=geometries.length;i<ii;++i){minSquaredDistance=geometries[i].closestPointXY(x,y,closestPoint,minSquaredDistance);}return minSquaredDistance;};/**
 * @inheritDoc
 */_ol_geom_GeometryCollection_.prototype.containsXY=function(x,y){var geometries=this.geometries_;var i,ii;for(i=0,ii=geometries.length;i<ii;++i){if(geometries[i].containsXY(x,y)){return true;}}return false;};/**
 * @inheritDoc
 */_ol_geom_GeometryCollection_.prototype.computeExtent=function(extent){_ol_extent_.createOrUpdateEmpty(extent);var geometries=this.geometries_;for(var i=0,ii=geometries.length;i<ii;++i){_ol_extent_.extend(extent,geometries[i].getExtent());}return extent;};/**
 * Return the geometries that make up this geometry collection.
 * @return {Array.<ol.geom.Geometry>} Geometries.
 * @api
 */_ol_geom_GeometryCollection_.prototype.getGeometries=function(){return _ol_geom_GeometryCollection_.cloneGeometries_(this.geometries_);};/**
 * @return {Array.<ol.geom.Geometry>} Geometries.
 */_ol_geom_GeometryCollection_.prototype.getGeometriesArray=function(){return this.geometries_;};/**
 * @inheritDoc
 */_ol_geom_GeometryCollection_.prototype.getSimplifiedGeometry=function(squaredTolerance){if(this.simplifiedGeometryRevision!=this.getRevision()){_ol_obj_.clear(this.simplifiedGeometryCache);this.simplifiedGeometryMaxMinSquaredTolerance=0;this.simplifiedGeometryRevision=this.getRevision();}if(squaredTolerance<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&squaredTolerance<this.simplifiedGeometryMaxMinSquaredTolerance){return this;}var key=squaredTolerance.toString();if(this.simplifiedGeometryCache.hasOwnProperty(key)){return this.simplifiedGeometryCache[key];}else{var simplifiedGeometries=[];var geometries=this.geometries_;var simplified=false;var i,ii;for(i=0,ii=geometries.length;i<ii;++i){var geometry=geometries[i];var simplifiedGeometry=geometry.getSimplifiedGeometry(squaredTolerance);simplifiedGeometries.push(simplifiedGeometry);if(simplifiedGeometry!==geometry){simplified=true;}}if(simplified){var simplifiedGeometryCollection=new _ol_geom_GeometryCollection_(null);simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);this.simplifiedGeometryCache[key]=simplifiedGeometryCollection;return simplifiedGeometryCollection;}else{this.simplifiedGeometryMaxMinSquaredTolerance=squaredTolerance;return this;}}};/**
 * @inheritDoc
 * @api
 */_ol_geom_GeometryCollection_.prototype.getType=function(){return _ol_geom_GeometryType_.GEOMETRY_COLLECTION;};/**
 * @inheritDoc
 * @api
 */_ol_geom_GeometryCollection_.prototype.intersectsExtent=function(extent){var geometries=this.geometries_;var i,ii;for(i=0,ii=geometries.length;i<ii;++i){if(geometries[i].intersectsExtent(extent)){return true;}}return false;};/**
 * @return {boolean} Is empty.
 */_ol_geom_GeometryCollection_.prototype.isEmpty=function(){return this.geometries_.length===0;};/**
 * @inheritDoc
 * @api
 */_ol_geom_GeometryCollection_.prototype.rotate=function(angle,anchor){var geometries=this.geometries_;for(var i=0,ii=geometries.length;i<ii;++i){geometries[i].rotate(angle,anchor);}this.changed();};/**
 * @inheritDoc
 * @api
 */_ol_geom_GeometryCollection_.prototype.scale=function(sx,opt_sy,opt_anchor){var anchor=opt_anchor;if(!anchor){anchor=_ol_extent_.getCenter(this.getExtent());}var geometries=this.geometries_;for(var i=0,ii=geometries.length;i<ii;++i){geometries[i].scale(sx,opt_sy,anchor);}this.changed();};/**
 * Set the geometries that make up this geometry collection.
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @api
 */_ol_geom_GeometryCollection_.prototype.setGeometries=function(geometries){this.setGeometriesArray(_ol_geom_GeometryCollection_.cloneGeometries_(geometries));};/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 */_ol_geom_GeometryCollection_.prototype.setGeometriesArray=function(geometries){this.unlistenGeometriesChange_();this.geometries_=geometries;this.listenGeometriesChange_();this.changed();};/**
 * @inheritDoc
 * @api
 */_ol_geom_GeometryCollection_.prototype.applyTransform=function(transformFn){var geometries=this.geometries_;var i,ii;for(i=0,ii=geometries.length;i<ii;++i){geometries[i].applyTransform(transformFn);}this.changed();};/**
 * Translate the geometry.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @override
 * @api
 */_ol_geom_GeometryCollection_.prototype.translate=function(deltaX,deltaY){var geometries=this.geometries_;var i,ii;for(i=0,ii=geometries.length;i<ii;++i){geometries[i].translate(deltaX,deltaY);}this.changed();};/**
 * @inheritDoc
 */_ol_geom_GeometryCollection_.prototype.disposeInternal=function(){this.unlistenGeometriesChange_();_ol_geom_Geometry_.prototype.disposeInternal.call(this);};// TODO: serialize dataProjection as crs member when writing
// see https://github.com/openlayers/openlayers/issues/2078
/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @constructor
 * @extends {ol.format.JSONFeature}
 * @param {olx.format.GeoJSONOptions=} opt_options Options.
 * @api
 */var _ol_format_GeoJSON_=function(opt_options){var options=opt_options?opt_options:{};_ol_format_JSONFeature_.call(this);/**
   * @inheritDoc
   */this.defaultDataProjection=_ol_proj_.get(options.defaultDataProjection?options.defaultDataProjection:'EPSG:4326');if(options.featureProjection){this.defaultFeatureProjection=_ol_proj_.get(options.featureProjection);}/**
   * Name of the geometry attribute for features.
   * @type {string|undefined}
   * @private
   */this.geometryName_=options.geometryName;};_ol_.inherits(_ol_format_GeoJSON_,_ol_format_JSONFeature_);/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 */_ol_format_GeoJSON_.readGeometry_=function(object,opt_options){if(!object){return null;}var geometryReader=_ol_format_GeoJSON_.GEOMETRY_READERS_[object.type];return(/** @type {ol.geom.Geometry} */_ol_format_Feature_.transformWithOptions(geometryReader(object),false,opt_options));};/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.GeometryCollection} Geometry collection.
 */_ol_format_GeoJSON_.readGeometryCollectionGeometry_=function(object,opt_options){var geometries=object.geometries.map(/**
       * @param {GeoJSONGeometry} geometry Geometry.
       * @return {ol.geom.Geometry} geometry Geometry.
       */function(geometry){return _ol_format_GeoJSON_.readGeometry_(geometry,opt_options);});return new _ol_geom_GeometryCollection_(geometries);};/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Point} Point.
 */_ol_format_GeoJSON_.readPointGeometry_=function(object){return new _ol_geom_Point_(object.coordinates);};/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.LineString} LineString.
 */_ol_format_GeoJSON_.readLineStringGeometry_=function(object){return new _ol_geom_LineString_(object.coordinates);};/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiLineString} MultiLineString.
 */_ol_format_GeoJSON_.readMultiLineStringGeometry_=function(object){return new _ol_geom_MultiLineString_(object.coordinates);};/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPoint} MultiPoint.
 */_ol_format_GeoJSON_.readMultiPointGeometry_=function(object){return new _ol_geom_MultiPoint_(object.coordinates);};/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPolygon} MultiPolygon.
 */_ol_format_GeoJSON_.readMultiPolygonGeometry_=function(object){return new _ol_geom_MultiPolygon_(object.coordinates);};/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Polygon} Polygon.
 */_ol_format_GeoJSON_.readPolygonGeometry_=function(object){return new _ol_geom_Polygon_(object.coordinates);};/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} GeoJSON geometry.
 */_ol_format_GeoJSON_.writeGeometry_=function(geometry,opt_options){var geometryWriter=_ol_format_GeoJSON_.GEOMETRY_WRITERS_[geometry.getType()];return geometryWriter(/** @type {ol.geom.Geometry} */_ol_format_Feature_.transformWithOptions(geometry,true,opt_options),opt_options);};/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @private
 * @return {GeoJSONGeometryCollection} Empty GeoJSON geometry collection.
 */_ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_=function(geometry){return(/** @type {GeoJSONGeometryCollection} */{type:'GeometryCollection',geometries:[]});};/**
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */_ol_format_GeoJSON_.writeGeometryCollectionGeometry_=function(geometry,opt_options){var geometries=geometry.getGeometriesArray().map(function(geometry){var options=_ol_obj_.assign({},opt_options);delete options.featureProjection;return _ol_format_GeoJSON_.writeGeometry_(geometry,options);});return(/** @type {GeoJSONGeometryCollection} */{type:'GeometryCollection',geometries:geometries});};/**
 * @param {ol.geom.LineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */_ol_format_GeoJSON_.writeLineStringGeometry_=function(geometry,opt_options){return(/** @type {GeoJSONGeometry} */{type:'LineString',coordinates:geometry.getCoordinates()});};/**
 * @param {ol.geom.MultiLineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */_ol_format_GeoJSON_.writeMultiLineStringGeometry_=function(geometry,opt_options){return(/** @type {GeoJSONGeometry} */{type:'MultiLineString',coordinates:geometry.getCoordinates()});};/**
 * @param {ol.geom.MultiPoint} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */_ol_format_GeoJSON_.writeMultiPointGeometry_=function(geometry,opt_options){return(/** @type {GeoJSONGeometry} */{type:'MultiPoint',coordinates:geometry.getCoordinates()});};/**
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */_ol_format_GeoJSON_.writeMultiPolygonGeometry_=function(geometry,opt_options){var right;if(opt_options){right=opt_options.rightHanded;}return(/** @type {GeoJSONGeometry} */{type:'MultiPolygon',coordinates:geometry.getCoordinates(right)});};/**
 * @param {ol.geom.Point} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */_ol_format_GeoJSON_.writePointGeometry_=function(geometry,opt_options){return(/** @type {GeoJSONGeometry} */{type:'Point',coordinates:geometry.getCoordinates()});};/**
 * @param {ol.geom.Polygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */_ol_format_GeoJSON_.writePolygonGeometry_=function(geometry,opt_options){var right;if(opt_options){right=opt_options.rightHanded;}return(/** @type {GeoJSONGeometry} */{type:'Polygon',coordinates:geometry.getCoordinates(right)});};/**
 * @const
 * @private
 * @type {Object.<string, function(GeoJSONObject): ol.geom.Geometry>}
 */_ol_format_GeoJSON_.GEOMETRY_READERS_={'Point':_ol_format_GeoJSON_.readPointGeometry_,'LineString':_ol_format_GeoJSON_.readLineStringGeometry_,'Polygon':_ol_format_GeoJSON_.readPolygonGeometry_,'MultiPoint':_ol_format_GeoJSON_.readMultiPointGeometry_,'MultiLineString':_ol_format_GeoJSON_.readMultiLineStringGeometry_,'MultiPolygon':_ol_format_GeoJSON_.readMultiPolygonGeometry_,'GeometryCollection':_ol_format_GeoJSON_.readGeometryCollectionGeometry_};/**
 * @const
 * @private
 * @type {Object.<string, function(ol.geom.Geometry, olx.format.WriteOptions=): (GeoJSONGeometry|GeoJSONGeometryCollection)>}
 */_ol_format_GeoJSON_.GEOMETRY_WRITERS_={'Point':_ol_format_GeoJSON_.writePointGeometry_,'LineString':_ol_format_GeoJSON_.writeLineStringGeometry_,'Polygon':_ol_format_GeoJSON_.writePolygonGeometry_,'MultiPoint':_ol_format_GeoJSON_.writeMultiPointGeometry_,'MultiLineString':_ol_format_GeoJSON_.writeMultiLineStringGeometry_,'MultiPolygon':_ol_format_GeoJSON_.writeMultiPolygonGeometry_,'GeometryCollection':_ol_format_GeoJSON_.writeGeometryCollectionGeometry_,'Circle':_ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_};/**
 * @inheritDoc
 */_ol_format_GeoJSON_.prototype.readFeatureFromObject=function(object,opt_options){/**
   * @type {GeoJSONFeature}
   */var geoJSONFeature=null;if(object.type==='Feature'){geoJSONFeature=/** @type {GeoJSONFeature} */object;}else{geoJSONFeature=/** @type {GeoJSONFeature} */{type:'Feature',geometry:/** @type {GeoJSONGeometry|GeoJSONGeometryCollection} */object};}var geometry=_ol_format_GeoJSON_.readGeometry_(geoJSONFeature.geometry,opt_options);var feature=new _ol_Feature_();if(this.geometryName_){feature.setGeometryName(this.geometryName_);}feature.setGeometry(geometry);if(geoJSONFeature.id!==undefined){feature.setId(geoJSONFeature.id);}if(geoJSONFeature.properties){feature.setProperties(geoJSONFeature.properties);}return feature;};/**
 * @inheritDoc
 */_ol_format_GeoJSON_.prototype.readFeaturesFromObject=function(object,opt_options){var geoJSONObject=/** @type {GeoJSONObject} */object;/** @type {Array.<ol.Feature>} */var features=null;if(geoJSONObject.type==='FeatureCollection'){var geoJSONFeatureCollection=/** @type {GeoJSONFeatureCollection} */object;features=[];var geoJSONFeatures=geoJSONFeatureCollection.features;var i,ii;for(i=0,ii=geoJSONFeatures.length;i<ii;++i){features.push(this.readFeatureFromObject(geoJSONFeatures[i],opt_options));}}else{features=[this.readFeatureFromObject(object,opt_options)];}return features;};/**
 * @inheritDoc
 */_ol_format_GeoJSON_.prototype.readGeometryFromObject=function(object,opt_options){return _ol_format_GeoJSON_.readGeometry_(/** @type {GeoJSONGeometry} */object,opt_options);};/**
 * @inheritDoc
 */_ol_format_GeoJSON_.prototype.readProjectionFromObject=function(object){var geoJSONObject=/** @type {GeoJSONObject} */object;var crs=geoJSONObject.crs;var projection;if(crs){if(crs.type=='name'){projection=_ol_proj_.get(crs.properties.name);}else if(crs.type=='EPSG'){// 'EPSG' is not part of the GeoJSON specification, but is generated by
// GeoServer.
// TODO: remove this when http://jira.codehaus.org/browse/GEOS-5996
// is fixed and widely deployed.
projection=_ol_proj_.get('EPSG:'+crs.properties.code);}else{_ol_asserts_.assert(false,36);// Unknown SRS type
}}else{projection=this.defaultDataProjection;}return(/** @type {ol.proj.Projection} */projection);};/**
 * Encode a feature as a GeoJSON Feature object.
 *
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeature} Object.
 * @override
 * @api
 */_ol_format_GeoJSON_.prototype.writeFeatureObject=function(feature,opt_options){opt_options=this.adaptOptions(opt_options);var object=/** @type {GeoJSONFeature} */{'type':'Feature'};var id=feature.getId();if(id!==undefined){object.id=id;}var geometry=feature.getGeometry();if(geometry){object.geometry=_ol_format_GeoJSON_.writeGeometry_(geometry,opt_options);}else{object.geometry=null;}var properties=feature.getProperties();delete properties[feature.getGeometryName()];if(!_ol_obj_.isEmpty(properties)){object.properties=properties;}else{object.properties=null;}return object;};/**
 * Encode an array of features as a GeoJSON object.
 *
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeatureCollection} GeoJSON Object.
 * @override
 * @api
 */_ol_format_GeoJSON_.prototype.writeFeaturesObject=function(features,opt_options){opt_options=this.adaptOptions(opt_options);var objects=[];var i,ii;for(i=0,ii=features.length;i<ii;++i){objects.push(this.writeFeatureObject(features[i],opt_options));}return(/** @type {GeoJSONFeatureCollection} */{type:'FeatureCollection',features:objects});};/**
 * Encode a geometry as a GeoJSON object.
 *
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
 * @override
 * @api
 */_ol_format_GeoJSON_.prototype.writeGeometryObject=function(geometry,opt_options){return _ol_format_GeoJSON_.writeGeometry_(geometry,this.adaptOptions(opt_options));};function loadGeoJSON(map,layerDef,data,version){var layer;try{var source=new _ol_source_Vector_({url:'data/'+version+'/'+layerDef.filename,format:new _ol_format_GeoJSON_({defaultDataProjection:layerDef.projection||pixelProj})});layer=new _ol_layer_Vector_({title:layerDef.name,projection:layerDef.projection||pixelProj,source:source,visible:!!layerDef.visible,style:layerDef.style});}catch(e){}return layer;}function loadPolygon(map,layerDef,data,layer){var features=[];features=data.data[layerDef.id].map(function(obj){var points=obj.points;var ring=points.map(function(point){return _ol_proj_.transform([point.x,point.y],dotaProj,pixelProj);});ring.push(_ol_proj_.transform([points[0].x,points[0].y],dotaProj,pixelProj));var geom=new _ol_geom_Polygon_([ring]);var feature=new _ol_Feature_(geom);obj.id=layerDef.id;feature.set('dotaProps',obj,true);return feature;});var vectorSource=new _ol_source_Vector_({defaultDataProjection:'dota',features:features});if(layer){layer.setSource(vectorSource);}else{layer=new _ol_layer_Vector_({title:layerDef.name,source:vectorSource,visible:!!layerDef.visible,style:layerDef.style});layer.set('layerId',layerDef.id,true);layer.set('layerDef',layerDef,true);layer.set('showInfo',false,true);}return layer;}function loadJSON(map,layerDef,data,layer){var features=[];features=data.data[layerDef.id].map(function(point){var unitClass=point.subType?layerDef.id+'_'+point.subType:layerDef.id;var stats=data.stats[unitClass];var bounds=layerDef.id=="ent_dota_tree"?[64,64]:stats.bounds;if(bounds&&bounds[0]>0&&bounds[1]>0){var geom=new _ol_geom_Polygon_([[_ol_proj_.transform([point.x-bounds[0],point.y-bounds[1]],dotaProj,pixelProj),_ol_proj_.transform([point.x-bounds[0],point.y+bounds[1]],dotaProj,pixelProj),_ol_proj_.transform([point.x+bounds[0],point.y+bounds[1]],dotaProj,pixelProj),_ol_proj_.transform([point.x+bounds[0],point.y-bounds[1]],dotaProj,pixelProj),_ol_proj_.transform([point.x-bounds[0],point.y-bounds[1]],dotaProj,pixelProj)]]);}else{var geom=new _ol_geom_Point_(_ol_proj_.transform([point.x,point.y],dotaProj,pixelProj));}var feature=new _ol_Feature_(geom);point.id=layerDef.id;point.unitClass=unitClass;feature.set('dotaProps',point,true);return feature;});var vectorSource=new _ol_source_Vector_({defaultDataProjection:'dota',features:features});if(layer){layer.setSource(vectorSource);}else{layer=new _ol_layer_Vector_({title:layerDef.name,source:vectorSource,visible:!!layerDef.visible,style:layerDef.style});layer.set('layerId',layerDef.id,true);layer.set('layerDef',layerDef,true);layer.set('showInfo',false,true);}return layer;}function loadNeutralPullRange(InteractiveMap,layerDef,data,layer){/*var features = InteractiveMap.getMapLayerIndex().npc_dota_neutral_spawner.getSource().getFeatures();
    var circles = features.map(function (feature) {
        var circle = InteractiveMap.getRangeCircle(feature, null, null, null, 400);
        feature.set("guard_range", circle, true);
        return circle;
    });
    circles = circles.concat(features.map(function (feature) {
        var dotaProps = feature.get("dotaProps");
        var center = worldToLatLon([dotaProps.x, dotaProps.y]);
        var pullMaxCoords = createCirclePointCoords(center[0], center[1], 400 + pullRangeTiming[dotaProps.pullType] * 350, 360);
        var pullMinCoords = createCirclePointCoords(center[0], center[1], 400 + pullRangeTiming[dotaProps.pullType] * 270, 360);
        var geom = new Polygon([pullMaxCoords]);
        geom.appendLinearRing(new ol.geom.LinearRing(pullMinCoords));
        feature.set("pull_range_min", geom, true);
        var circle = new Feature({geometry: geom, visible: false});
        circle.visible(false);
        return circle;
    }));*/var vectorSource=new _ol_source_Vector_({defaultDataProjection:'pixel',features:[]});if(layer){layer.setSource(vectorSource);}else{layer=new _ol_layer_Vector_({title:layerDef.name,source:vectorSource,visible:!!layerDef.visible,style:layerDef.style});layer.set('layerId',layerDef.id,true);layer.set('layerDef',layerDef,true);layer.set('showInfo',false,true);}return layer;}function loadLayerGroupFromData(InteractiveMap,data,version,layersIndex,layerDefs){var layers=[];for(var i=0;i<layerDefs.length;i++){var layerDef=layerDefs[i];if(!data.data[layerDef.id]&&(layerDef.type!=='pullRange'&&layerDef.type!=='GeoJSON'||version=='688'))continue;var layer;switch(layerDef.type){case'GeoJSON':layer=loadGeoJSON(InteractiveMap.map,layerDef,layersIndex[layerDef.id],version);break;case'polygon':layer=loadPolygon(InteractiveMap.map,layerDef,data,layersIndex[layerDef.id]);break;case'pullRange':layer=loadNeutralPullRange(InteractiveMap,layerDef,data,layersIndex[layerDef.id]);break;default:layer=loadJSON(InteractiveMap.map,layerDef,data,layersIndex[layerDef.id]);break;}if(layer){layersIndex[layerDef.id]=layer;layers.push(layer);}}var layerGroup=new _ol_layer_Group_({title:'Layers',layers:new _ol_Collection_(layers)});return layerGroup;}function getJSON(path,callback){var retries=3;function makeReq(){var request=new XMLHttpRequest();request.open('GET',path,true);var err;request.onload=function(){if(request.status==200){console.log(request);console.log(request.status);try{var data=JSON.parse(request.responseText);}catch(e){err=e;}}else{err=new Error("Error loading json "+request.status);}callback(err,data);};request.onerror=function(){retries--;if(retries>0){setTimeout(function(){makeReq();},1000);}else{err=new Error("Error loading json "+request.status);callback(err);}};request.send();}makeReq();}var baseLayerDefinitions=[{id:'default',name:'Default',group:'706'},{id:'autumn',name:'Autumn',group:'706'},{id:'desert',name:'Desert',group:'706'},{id:'immortalgardens',name:'Immortal Gardens',group:'706'},{id:'journey',name:'New Journey',group:'706'},{id:'reef',name:'Reef\'s Edge',group:'706'},{id:'spring',name:'Spring',group:'706'},{id:'winter',name:'Winter',group:'706'},{id:'default',name:'Default',group:'700'},{id:'default',name:'Default',group:'688'}];var layerDefinitions=[{id:'path_corner',name:'Lanes',filename:'path_corner.json',type:'GeoJSON',group:'overlay',projection:dotaProj,style:styles.teamColor},{id:'npc_dota_spawner',name:'Lane Spawns',filename:'npc_dota_spawner.json',type:'GeoJSON',group:'overlay',projection:dotaProj,style:styles.creepSpawn},{id:'ent_fow_blocker_node',name:'Vision Blocker',filename:'ent_fow_blocker_node.json',type:'GeoJSON',group:'overlay',projection:dotaProj,style:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:[0,0,255,0.3]}),stroke:new _ol_style_Stroke_({color:[0,0,255,0.8]})})},{id:'no_wards',name:'Invalid Wards',filename:'no_wards.json',type:'GeoJSON',group:'overlay',projection:dotaProj,style:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:[255,0,0,0.3]}),stroke:new _ol_style_Stroke_({color:[255,0,0,0.8]})})},{id:'trigger_multiple',name:'Spawn Boxes',type:'polygon',group:'overlay',style:new _ol_style_Style_$1({fill:new _ol_style_Fill_({color:[0,255,125,0.3]}),stroke:new _ol_style_Stroke_({color:[0,255,125,0.8]})})},{id:'npc_dota_neutral_spawner',name:'Neutral Camps',group:'object',style:function(feature,resolution){return styles.neutralCamp[parseInt(feature.get('dotaProps').neutralType)];}},{id:'ent_dota_tree',name:'Trees',group:'object',style:function(feature,resolution){if(feature.get('isCut')){return styles.tree.dead;}else{return styles.tree.alive;}},toggle:true},{id:'npc_dota_roshan_spawner',name:'Roshan',group:'object',style:styles.roshan},{id:'dota_item_rune_spawner_powerup',name:'Runes',group:'object',style:styles.rune},{id:'dota_item_rune_spawner_bounty',name:'Bounty Runes',group:'object',style:styles.bountyRune},{id:'ent_dota_fountain',name:'Fountain',group:'structure',style:styles.ent_dota_fountain,toggle:true},{id:'npc_dota_barracks',name:'Barracks',group:'structure',style:styles.npc_dota_barracks,toggle:true},{id:'npc_dota_filler',name:'Buildings',group:'structure',style:styles.npc_dota_filler,toggle:true},{id:'npc_dota_tower',name:'Towers',group:'structure',style:styles.npc_dota_tower,toggle:true},{id:'ent_dota_shop',name:'Shops',group:'structure',style:styles.ent_dota_shop},{id:'npc_dota_fort',name:'Ancients',group:'structure',style:styles.npc_dota_fort,toggle:true},{id:'npc_dota_healer',name:'Shrines',group:'structure',style:styles.npc_dota_healer,toggle:true},{id:'pullRange',name:'Pull Range',type:'pullRange',group:'overlay',style:styles.pullRange,visible:true}];//import proj from 'ol/proj';
function InteractiveMap(map_tile_path){var self=this;this.map_tile_path=map_tile_path;this.MODE='navigation';this.layerDefs=layerDefinitions;this.baseLayerDefs=baseLayerDefinitions;this.view=new _ol_View_({zoom:0,center:mapConstants.imgCenter,projection:pixelProj,resolutions:mapConstants.resolutions,extent:[0,0,mapConstants.map_w,mapConstants.map_h]});this.data={};this.layerIndex={};this.version='706';this.visionRadius=mapConstants.visionRadius.observer;this.movementSpeed=mapConstants.defaultMovementSpeed;this.isNight=false;this.isDarkness=false;this.layerFilters={marker:function(layer){var layerDef=layer.get('layerDef');return layer.getVisible()&&layerDef&&(layerDef.group=='structure'||layerDef.group=='object');}};this.map=new _ol_Map_({controls:_ol_control_.defaults({zoom:false,attribution:false,rotate:false}),interactions:_ol_interaction_.defaults({altShiftDragRotate:false,pinchRotate:false}),target:'map',view:this.view});this.highlightSource=new _ol_source_Vector_({defaultDataProjection:'pixel'});this.highlightLayer=new _ol_layer_Vector_({source:this.highlightSource,style:styles.highlight});this.selectSource=new _ol_source_Vector_({defaultDataProjection:'pixel'});this.selectLayer=new _ol_layer_Vector_({source:this.selectSource,style:styles.select});this.wardRangeSource=new _ol_source_Vector_({defaultDataProjection:'pixel'});this.wardRangeLayer=new _ol_layer_Vector_({source:this.wardRangeSource});this.rangeSources={dayVision:new _ol_source_Vector_({defaultDataProjection:'pixel'}),nightVision:new _ol_source_Vector_({defaultDataProjection:'pixel'}),trueSight:new _ol_source_Vector_({defaultDataProjection:'pixel'}),attackRange:new _ol_source_Vector_({defaultDataProjection:'pixel'})};this.rangeLayers={dayVision:new _ol_layer_Vector_({source:this.rangeSources.dayVision,style:styles.dayVision}),nightVision:new _ol_layer_Vector_({source:this.rangeSources.nightVision,style:styles.nightVision}),trueSight:new _ol_layer_Vector_({source:this.rangeSources.trueSight,style:styles.trueSight}),attackRange:new _ol_layer_Vector_({source:this.rangeSources.attackRange,style:styles.attackRange})};// setup base layers
this.baseLayers=this.baseLayerDefs.map(function(layerDef){var layer=new _ol_layer_Tile_({title:layerDef.name,type:'base',extent:pixelProj.getExtent(),//proj.pixel.getExtent()
source:new _ol_source_TileImage_({tileGrid:new _ol_tilegrid_TileGrid_({origin:[0,mapConstants.map_h],resolutions:mapConstants.resolutions}),projection:pixelProj,url:self.map_tile_path+layerDef.group+'/'+layerDef.id+'/{z}/tile_{x}_{y}.jpg'}),visible:!!layerDef.visible});layer.set('layerId',layerDef.group+'-'+layerDef.id,true);layer.set('layerDef',layerDef,true);return layer;});this.baseLayerGroup=new _ol_layer_Group_({title:'Base Layers',layers:new _ol_Collection_(this.baseLayers)});}InteractiveMap.prototype.getMapData=function(version){return this.data[version||this.version];};InteractiveMap.prototype.getData=function(version){return this.data[version||this.version].data;};InteractiveMap.prototype.getOverlayData=function(version){return this.data[version||this.version].data.data;};InteractiveMap.prototype.getStatData=function(version){return this.data[version||this.version].data.stats;};InteractiveMap.prototype.getMapLayerIndex=function(version){version=version||this.version;if(!this.layerIndex[version])this.layerIndex[version]={};return this.layerIndex[version];};InteractiveMap.prototype.getMapDataPath=function(version){version=version||this.version;return'data/'+version+'/mapdata.json';};InteractiveMap.prototype.setMapLayers=function(version,callback){var self=this;this.getDataJSON(version,function(err,data){if(!err){var currentLayerGroup=self.map.getLayerGroup();currentLayerGroup.setVisible(false);self.map.setLayerGroup(data.layerGroup);self.map.getLayerGroup().setVisible(true);}if(callback)callback(err);});};InteractiveMap.prototype.getDataJSON=function(version,callback){var self=this;if(this.data[version]){callback(null,self.data[version]);}else{getJSON(self.getMapDataPath(version),function(err,data){if(!err){self.data[version]={data:data,layerGroup:new _ol_layer_Group_({title:version+' Layers',layers:new _ol_Collection_([self.baseLayerGroup,loadLayerGroupFromData(self,data,version,self.getMapLayerIndex(version),self.layerDefs)])})};}callback(err,self.data[version]);});}};InteractiveMap.prototype.panTo=function(coordinate,duration){if(duration==null)duration=1000;this.view.animate({center:coordinate,duration:1000});};InteractiveMap.prototype.checkAndHighlightWard=function(pixel){var self=this;var feature=this.map.forEachFeatureAtPixel(pixel,function(feature,layer){return feature;},{layerFilter:self.wardControl.layerFilter});this.highlightWard(feature);return feature;};InteractiveMap.prototype.highlightWard=function(feature){if(feature!==this.highlightedWard){if(this.highlightedWard){this.highlightedWard.setStyle(styles[this.highlightedWard.get('wardType')].normal);}if(feature){feature.setStyle(styles[feature.get('wardType')][this.MODE=='navigate'?'highlight':'remove']);}this.highlightedWard=feature;}};InteractiveMap.prototype.unhighlightWard=function(){if(this.highlightedWard){this.highlightedWard.setStyle(styles[this.highlightedWard.get('wardType')].normal);}this.highlightedWard=null;};InteractiveMap.prototype.highlight=function(feature){if(feature!==this.highlightedFeature){if(this.highlightedFeature){this.highlightSource.removeFeature(this.highlightedFeature);}if(feature){this.highlightSource.addFeature(feature);}this.highlightedFeature=feature;}};InteractiveMap.prototype.unhighlight=function(){if(this.highlightedFeature){this.highlightSource.removeFeature(this.highlightedFeature);}this.highlightedFeature=null;};InteractiveMap.prototype.toggle=function(feature){if(feature){if(feature.get("clicked")){this.deselect(feature);return false;}else{this.select(feature);return true;}}};InteractiveMap.prototype.select=function(feature){if(feature&&!feature.get("clicked")){if(feature==this.highlightedFeature){this.unhighlight();}this.selectSource.addFeature(feature);feature.set("clicked",true,true);}};InteractiveMap.prototype.deselectAll=function(){this.selectSource.getFeatures().forEach(function(feature){feature.set("clicked",false,true);});this.selectSource.clear();};InteractiveMap.prototype.deselect=function(feature){if(feature&&feature.get("clicked")){if(feature==this.highlightedFeature){this.unhighlight();}this.selectSource.removeFeature(feature);feature.set("clicked",false,true);}};InteractiveMap.prototype.hasVisionRadius=function(feature){return this.getFeatureVisionRadius(feature)!=null;};InteractiveMap.prototype.getFeatureVisionRadius=function(feature,dotaProps,unitClass,rangeType){dotaProps=dotaProps||feature.get('dotaProps');unitClass=unitClass||dotaProps.unitClass;var stats=this.getStatData();var radius;if(unitClass=='observer'){radius=this.visionRadius||mapConstants.visionRadius[unitClass];if(this.isDarkness){radius=Math.min(mapConstants.visionRadius.darkness,radius);}}else if(unitClass=='sentry'){radius=mapConstants.visionRadius[unitClass];}else{if(rangeType&&!stats[unitClass].hasOwnProperty(rangeType))return null;switch(rangeType){case'dayVision':case'nightVision':radius=stats[unitClass][rangeType];if(this.isDarkness){radius=Math.min(mapConstants.visionRadius.darkness,radius);}case'trueSight':case'attackRange':radius=stats[unitClass][rangeType];break;default:if(this.isNight){radius=stats[unitClass].nightVision;}else{radius=stats[unitClass].dayVision;}if(this.isDarkness){radius=Math.min(mapConstants.visionRadius.darkness,radius);}break;}}return radius;};InteractiveMap.prototype.getRangeCircle=function(feature,coordinate,unitClass,rangeType,radius){var dotaProps=feature.get('dotaProps');var radius=radius||this.getFeatureVisionRadius(feature,dotaProps,unitClass,rangeType);if(radius==null)return null;if(!coordinate){coordinate=worldToLatLon([dotaProps.x,dotaProps.y]);}var circle=new _ol_Feature_(new _ol_geom_Circle_(coordinate,getScaledRadius(radius)));return circle;};var modeNotificationText={observer:"Ward Mode: Observer",sentry:"Ward Mode: Sentry",navigate:"Navigation Mode",line:"Measure Mode: Line",circle:"Measure Mode: Circle",treeEnable:"<span>Navigation Mode</span><span>Trees: On</span>",treeDisable:"<span>Navigation Mode</span><span>Trees: Off</span>",nightOn:"Nighttime Vision",nightOff:"Daytime Vision",darknessOn:"Darkness: On",darknessOff:"Darkness: Off"};var forEach=function(array,callback,scope){for(var i=0;i<array.length;i++){callback.call(scope,array[i],i);// passes back stuff we need
}};var commonjsGlobal=typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports;}var rollbar_umd_min$1=createCommonjsModule(function(module,exports){!function(t,e){module.exports=e();}(commonjsGlobal,function(){return function(t){function e(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports;}var r={};return e.m=t,e.c=r,e.p="",e(0);}([function(t,e,r){t.exports=r(1);},function(t,e,r){"use strict";var n=r(2),o=window&&window._rollbarConfig,i=o&&o.globalAlias||"Rollbar",a=window&&window[i]&&"function"==typeof window[i].shimId&&void 0!==window[i].shimId();if(window&&!window._rollbarStartTime&&(window._rollbarStartTime=new Date().getTime()),!a&&o){var s=new n(o);window[i]=s;}else window.rollbar=n,window._rollbarDidLoad=!0;t.exports=n;},function(t,e,r){"use strict";function n(t,e){this.options=c.extend(!0,_,t);var r=new l(this.options,h,d);this.client=e||new u(this.options,r,p,"browser"),i(this.client.notifier),a(this.client.queue),(this.options.captureUncaught||this.options.handleUncaughtExceptions)&&(f.captureUncaughtExceptions(window,this),f.wrapGlobals(window,this)),(this.options.captureUnhandledRejections||this.options.handleUnhandledRejections)&&f.captureUnhandledRejections(window,this),this.instrumenter=new b(this.options,this.client.telemeter,this,window,document),this.instrumenter.instrument();}function o(t){var e="Rollbar is not initialized";p.error(e),t&&t(new Error(e));}function i(t){t.addTransform(m.handleItemWithError).addTransform(m.ensureItemHasSomethingToSay).addTransform(m.addBaseInfo).addTransform(m.addRequestInfo(window)).addTransform(m.addClientInfo(window)).addTransform(m.addPluginInfo(window)).addTransform(m.addBody).addTransform(g.addMessageWithError).addTransform(g.addTelemetryData).addTransform(m.scrubPayload).addTransform(m.userTransform).addTransform(g.itemToPayload);}function a(t){t.addPredicate(v.checkIgnore).addPredicate(v.userCheckIgnore).addPredicate(v.urlIsWhitelisted).addPredicate(v.messageIsIgnored);}function s(t){for(var e=0,r=t.length;e<r;++e)if(c.isFunction(t[e]))return t[e];}var u=r(3),c=r(6),l=r(11),p=r(13),f=r(16),h=r(17),d=r(18),m=r(19),g=r(23),v=r(24),y=r(20),b=r(25),w=null;n.init=function(t,e){return w?w.global(t).configure(t):w=new n(t,e);},n.prototype.global=function(t){return this.client.global(t),this;},n.global=function(t){return w?w.global(t):void o();},n.prototype.configure=function(t){var e=this.options;return this.options=c.extend(!0,{},e,t),this.client.configure(t),this;},n.configure=function(t){return w?w.configure(t):void o();},n.prototype.lastError=function(){return this.client.lastError;},n.lastError=function(){return w?w.lastError():void o();},n.prototype.log=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.log(t),{uuid:e};},n.log=function(){if(w)return w.log.apply(w,arguments);var t=s(arguments);o(t);},n.prototype.debug=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.debug(t),{uuid:e};},n.debug=function(){if(w)return w.debug.apply(w,arguments);var t=s(arguments);o(t);},n.prototype.info=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.info(t),{uuid:e};},n.info=function(){if(w)return w.info.apply(w,arguments);var t=s(arguments);o(t);},n.prototype.warn=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.warn(t),{uuid:e};},n.warn=function(){if(w)return w.warn.apply(w,arguments);var t=s(arguments);o(t);},n.prototype.warning=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.warning(t),{uuid:e};},n.warning=function(){if(w)return w.warning.apply(w,arguments);var t=s(arguments);o(t);},n.prototype.error=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.error(t),{uuid:e};},n.error=function(){if(w)return w.error.apply(w,arguments);var t=s(arguments);o(t);},n.prototype.critical=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.critical(t),{uuid:e};},n.critical=function(){if(w)return w.critical.apply(w,arguments);var t=s(arguments);o(t);},n.prototype.handleUncaughtException=function(t,e,r,n,o,i){var a,s=c.makeUnhandledStackInfo(t,e,r,n,o,"onerror","uncaught exception",y);c.isError(o)?(a=this._createItem([t,o,i]),a._unhandledStackInfo=s):c.isError(e)?(a=this._createItem([t,e,i]),a._unhandledStackInfo=s):(a=this._createItem([t,i]),a.stackInfo=s),a.level=this.options.uncaughtErrorLevel,a._isUncaught=!0,this.client.log(a);},n.prototype.handleUnhandledRejection=function(t,e){var r="unhandled rejection was null or undefined!";r=t?t.message||String(t):r;var n,o=t&&t._rollbarContext||e&&e._rollbarContext;c.isError(t)?n=this._createItem([r,t,o]):(n=this._createItem([r,t,o]),n.stackInfo=c.makeUnhandledStackInfo(r,"",0,0,null,"unhandledrejection","",y)),n.level=this.options.uncaughtErrorLevel,n._isUncaught=!0,n._originalArgs=n._originalArgs||[],n._originalArgs.push(e),this.client.log(n);},n.prototype.wrap=function(t,e,r){try{var n;if(n=c.isFunction(e)?e:function(){return e||{};},!c.isFunction(t))return t;if(t._isWrap)return t;if(!t._rollbar_wrapped&&(t._rollbar_wrapped=function(){r&&c.isFunction(r)&&r.apply(this,arguments);try{return t.apply(this,arguments);}catch(r){var e=r;throw c.isType(e,"string")&&(e=new String(e)),e._rollbarContext=n()||{},e._rollbarContext._wrappedSource=t.toString(),window._rollbarWrappedError=e,e;}},t._rollbar_wrapped._isWrap=!0,t.hasOwnProperty))for(var o in t)t.hasOwnProperty(o)&&(t._rollbar_wrapped[o]=t[o]);return t._rollbar_wrapped;}catch(e){return t;}},n.wrap=function(t,e){return w?w.wrap(t,e):void o();},n.prototype.captureEvent=function(t,e){return this.client.captureEvent(t,e);},n.captureEvent=function(t,e){return w?w.captureEvent(t,e):void o();},n.prototype.captureDomContentLoaded=function(t,e){return e||(e=new Date()),this.client.captureDomContentLoaded(e);},n.prototype.captureLoad=function(t,e){return e||(e=new Date()),this.client.captureLoad(e);},n.prototype._createItem=function(t){return c.createItem(t,p,this);};var _={version:"2.2.0",scrubFields:["pw","pass","passwd","password","secret","confirm_password","confirmPassword","password_confirmation","passwordConfirmation","access_token","accessToken","secret_key","secretKey","secretToken"],logLevel:"debug",reportLevel:"debug",uncaughtErrorLevel:"error",endpoint:"api.rollbar.com/api/1/",verbose:!1,enabled:!0};t.exports=n;},function(t,e,r){"use strict";function n(t,e,r,o){this.options=u.extend(!0,{},t),this.logger=r,n.rateLimiter.setPlatformOptions(o,this.options),this.queue=new i(n.rateLimiter,e,r,this.options),this.notifier=new a(this.queue,this.options),this.telemeter=new s(this.options),this.lastError=null;}var o=r(4),i=r(5),a=r(9),s=r(10),u=r(6),c={maxItems:0,itemsPerMinute:60};n.rateLimiter=new o(c),n.prototype.global=function(t){return n.rateLimiter.configureGlobal(t),this;},n.prototype.configure=function(t){this.notifier&&this.notifier.configure(t);var e=this.options;return this.options=u.extend(!0,{},e,t),this;},n.prototype.log=function(t){var e=this._defaultLogLevel();return this._log(e,t);},n.prototype.debug=function(t){this._log("debug",t);},n.prototype.info=function(t){this._log("info",t);},n.prototype.warn=function(t){this._log("warning",t);},n.prototype.warning=function(t){this._log("warning",t);},n.prototype.error=function(t){this._log("error",t);},n.prototype.critical=function(t){this._log("critical",t);},n.prototype.wait=function(t){this.queue.wait(t);},n.prototype.captureEvent=function(t,e){return this.telemeter.captureEvent(t,e);},n.prototype.captureDomContentLoaded=function(t){return this.telemeter.captureDomContentLoaded(t);},n.prototype.captureLoad=function(t){return this.telemeter.captureLoad(t);},n.prototype._log=function(t,e){if(!this._sameAsLastError(e))try{var r=null;e.callback&&(r=e.callback,delete e.callback),e.level=e.level||t,e.telemetryEvents=this.telemeter.copyEvents(),this.telemeter._captureRollbarItem(e),this.notifier.log(e,r);}catch(t){this.logger.error(t);}},n.prototype._defaultLogLevel=function(){return this.options.logLevel||"debug";},n.prototype._sameAsLastError=function(t){return!(!this.lastError||this.lastError!==t.err)||(this.lastError=t.err,!1);},t.exports=n;},function(t,e){"use strict";function r(t){this.startTime=new Date().getTime(),this.counter=0,this.perMinCounter=0,this.platform=null,this.platformOptions={},this.configureGlobal(t);}function n(t,e,r){return!t.ignoreRateLimit&&e>=1&&r>=e;}function o(t,e,r,n,o){var a=null;return r&&(r=new Error(r)),r||n||(a=i(t,e,o)),{error:r,shouldSend:n,payload:a};}function i(t,e,r){var n=e.environment||e.payload&&e.payload.environment,o={body:{message:{body:"maxItems has been hit. Ignoring errors until reset.",extra:{maxItems:r}}},language:"javascript",environment:n,notifier:{version:e.notifier&&e.notifier.version||e.version}};return"browser"===t?(o.platform="browser",o.framework="browser-js",o.notifier.name="rollbar-browser-js"):"server"===t&&(o.framework=e.framework||"node-js",o.notifier.name=e.notifier.name),o;}r.globalSettings={startTime:new Date().getTime(),maxItems:void 0,itemsPerMinute:void 0},r.prototype.configureGlobal=function(t){void 0!==t.startTime&&(r.globalSettings.startTime=t.startTime),void 0!==t.maxItems&&(r.globalSettings.maxItems=t.maxItems),void 0!==t.itemsPerMinute&&(r.globalSettings.itemsPerMinute=t.itemsPerMinute);},r.prototype.shouldSend=function(t,e){e=e||new Date().getTime(),e-this.startTime>=6e4&&(this.startTime=e,this.perMinCounter=0);var i=r.globalSettings.maxItems,a=r.globalSettings.itemsPerMinute;if(n(t,i,this.counter))return o(this.platform,this.platformOptions,i+" max items reached",!1);if(n(t,a,this.perMinCounter))return o(this.platform,this.platformOptions,a+" items per minute reached",!1);this.counter++,this.perMinCounter++;var s=!n(t,i,this.counter);return o(this.platform,this.platformOptions,null,s,i);},r.prototype.setPlatformOptions=function(t,e){this.platform=t,this.platformOptions=e;},t.exports=r;},function(t,e,r){"use strict";function n(t,e,r,n){this.rateLimiter=t,this.api=e,this.logger=r,this.options=n,this.predicates=[],this.pendingRequests=[],this.retryQueue=[],this.retryHandle=null,this.waitCallback=null,this.waitIntervalID=null;}var o=r(6);n.prototype.configure=function(t){this.api&&this.api.configure(t);var e=this.options;return this.options=o.extend(!0,{},e,t),this;},n.prototype.addPredicate=function(t){return o.isFunction(t)&&this.predicates.push(t),this;},n.prototype.addItem=function(t,e,r){e&&o.isFunction(e)||(e=function(){});var n=this._applyPredicates(t);if(n.stop)return void e(n.err);if(this.waitCallback)return void e();this._maybeLog(t,r),this.pendingRequests.push(t);try{this._makeApiRequest(t,function(r,n){this._dequeuePendingRequest(t),e(r,n);}.bind(this));}catch(r){this._dequeuePendingRequest(t),e(r);}},n.prototype.wait=function(t){o.isFunction(t)&&(this.waitCallback=t,this._maybeCallWait()||(this.waitIntervalID&&(this.waitIntervalID=clearInterval(this.waitIntervalID)),this.waitIntervalID=setInterval(function(){this._maybeCallWait();}.bind(this),500)));},n.prototype._applyPredicates=function(t){for(var e=null,r=0,n=this.predicates.length;r<n;r++)if(e=this.predicates[r](t,this.options),!e||void 0!==e.err)return{stop:!0,err:e.err};return{stop:!1,err:null};},n.prototype._makeApiRequest=function(t,e){var r=this.rateLimiter.shouldSend(t);r.shouldSend?this.api.postItem(t,function(r,n){r?this._maybeRetry(r,t,e):e(r,n);}.bind(this)):r.error?e(r.error):this.api.postItem(r.payload,e);};var i=["ECONNRESET","ENOTFOUND","ESOCKETTIMEDOUT","ETIMEDOUT","ECONNREFUSED","EHOSTUNREACH","EPIPE","EAI_AGAIN"];n.prototype._maybeRetry=function(t,e,r){var n=!1;if(this.options.retryInterval)for(var o=0,a=i.length;o<a;o++)if(t.code===i[o]){n=!0;break;}n?this._retryApiRequest(e,r):r(t);},n.prototype._retryApiRequest=function(t,e){this.retryQueue.push({item:t,callback:e}),this.retryHandle||(this.retryHandle=setInterval(function(){for(;this.retryQueue.length;){var t=this.retryQueue.shift();this._makeApiRequest(t.item,t.callback);}}.bind(this),this.options.retryInterval));},n.prototype._dequeuePendingRequest=function(t){for(var e=this.pendingRequests.length;e>=0;e--)if(this.pendingRequests[e]==t)return this.pendingRequests.splice(e,1),void this._maybeCallWait();},n.prototype._maybeLog=function(t,e){if(this.logger&&this.options.verbose){var r=e;if(r=r||o.get(t,"body.trace.exception.message"),r=r||o.get(t,"body.trace_chain.0.exception.message"))return void this.logger.error(r);r=o.get(t,"body.message.body"),r&&this.logger.log(r);}},n.prototype._maybeCallWait=function(){return!(!o.isFunction(this.waitCallback)||0!==this.pendingRequests.length)&&(this.waitIntervalID&&(this.waitIntervalID=clearInterval(this.waitIntervalID)),this.waitCallback(),!0);},t.exports=n;},function(t,e,r){"use strict";function n(){if(!C&&(C=!0,s(JSON)&&(a(JSON.stringify)&&(L.stringify=JSON.stringify),a(JSON.parse)&&(L.parse=JSON.parse)),!a(L.stringify)||!a(L.parse))){var t=r(8);t(L);}}function o(t,e){return e===i(t);}function i(t){var e=typeof t;return"object"!==e?e:t?t instanceof Error?"error":{}.toString.call(t).match(/\s([a-zA-Z]+)/)[1].toLowerCase():"null";}function a(t){return o(t,"function");}function s(t){return!o(t,"undefined");}function u(t){var e=i(t);return"object"===e||"array"===e;}function c(t){return o(t,"error");}function l(t,e){var r,n,i,a=o(t,"object"),s=o(t,"array"),u=[];if(a)for(r in t)Object.prototype.hasOwnProperty.call(t,r)&&u.push(r);else if(s)for(i=0;i<t.length;++i)u.push(i);for(i=0;i<u.length;++i)r=u[i],n=t[r],t[r]=e(r,n);return t;}function p(){return"********";}function f(){var t=O(),e="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var r=(t+16*Math.random())%16|0;return t=Math.floor(t/16),("x"===e?r:7&r|8).toString(16);});return e;}function h(t){var e=d(t);return""===e.anchor&&(e.source=e.source.replace("#","")),t=e.source.replace("?"+e.query,"");}function d(t){if(!o(t,"string"))throw new Error("received invalid input");for(var e=A,r=e.parser[e.strictMode?"strict":"loose"].exec(t),n={},i=e.key.length;i--;)n[e.key[i]]=r[i]||"";return n[e.q.name]={},n[e.key[12]].replace(e.q.parser,function(t,r,o){r&&(n[e.q.name][r]=o);}),n;}function m(t,e,r){r=r||{},r.access_token=t;var n,o=[];for(n in r)Object.prototype.hasOwnProperty.call(r,n)&&o.push([n,r[n]].join("="));var i="?"+o.sort().join("&");e=e||{},e.path=e.path||"";var a,s=e.path.indexOf("?"),u=e.path.indexOf("#");s!==-1&&(u===-1||u>s)?(a=e.path,e.path=a.substring(0,s)+i+"&"+a.substring(s+1)):u!==-1?(a=e.path,e.path=a.substring(0,u)+i+a.substring(u)):e.path=e.path+i;}function g(t,e){if(e=e||t.protocol,!e&&t.port&&(80===t.port?e="http:":443===t.port&&(e="https:")),e=e||"https:",!t.hostname)return null;var r=e+"//"+t.hostname;return t.port&&(r=r+":"+t.port),t.path&&(r+=t.path),r;}function v(t,e){var r,n;try{r=L.stringify(t);}catch(o){if(e&&a(e))try{r=e(t);}catch(t){n=t;}else n=o;}return{error:n,value:r};}function y(t){var e,r;try{e=L.parse(t);}catch(t){r=t;}return{error:r,value:e};}function b(t,e,r,n,o,i,a,s){var u={url:e||"",line:r,column:n};u.func=s.guessFunctionName(u.url,u.line),u.context=s.gatherContext(u.url,u.line);var c=document&&document.location&&document.location.href,l=window&&window.navigator&&window.navigator.userAgent;return{mode:i,message:o?String(o):t||a,url:c,stack:[u],useragent:l};}function w(t,e){return function(r,n){try{e(r,n);}catch(e){t.error(e);}};}function _(t,e,r,n){for(var o,a,s,u,c,l,p=[],h=0,d=t.length;h<d;++h){l=t[h];var m=i(l);switch(m){case"undefined":break;case"string":o?p.push(l):o=l;break;case"function":u=w(e,l);break;case"date":p.push(l);break;case"error":case"domexception":a?p.push(l):a=l;break;case"object":case"array":if(l instanceof Error||"undefined"!=typeof DOMException&&l instanceof DOMException){a?p.push(l):a=l;break;}if(n&&"object"===m&&!c){for(var g=0,v=n.length;g<v;++g)if(void 0!==l[n[g]]){c=l;break;}if(c)break;}s?p.push(l):s=l;break;default:if(l instanceof Error||"undefined"!=typeof DOMException&&l instanceof DOMException){a?p.push(l):a=l;break;}p.push(l);}}p.length>0&&(s=N(!0,{},s),s.extraArgs=p);var y={message:o,err:a,custom:s,timestamp:O(),callback:u,uuid:f()};return s&&void 0!==s.level&&(y.level=s.level,delete s.level),n&&c&&(y.request=c),y._originalArgs=t,y;}function x(t,e){if(t){var r=e.split("."),n=t;try{for(var o=0,i=r.length;o<i;++o)n=n[r[o]];}catch(t){n=void 0;}return n;}}function k(t,e,r){if(t){var n=e.split("."),o=n.length;if(!(o<1)){if(1===o)return void(t[n[0]]=r);try{for(var i=t[n[0]]||{},a=i,s=1;s<o-1;s++)i[n[s]]=i[n[s]]||{},i=i[n[s]];i[n[o-1]]=r,t[n[0]]=a;}catch(t){return;}}}}function E(t,e){function r(t,e,r,n,o,i){return e+p(i);}function n(t){var e;if(o(t,"string"))for(e=0;e<u.length;++e)t=t.replace(u[e],r);return t;}function i(t,e){var r;for(r=0;r<s.length;++r)if(s[r].test(t)){e=p(e);break;}return e;}function a(t,e){var r=i(t,e);return r===e?o(e,"object")||o(e,"array")?l(e,a):n(r):r;}e=e||[];var s=I(e),u=T(e);return l(t,a),t;}function I(t){for(var e,r=[],n=0;n<t.length;++n)e="\\[?(%5[bB])?"+t[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",r.push(new RegExp(e,"i"));return r;}function T(t){for(var e,r=[],n=0;n<t.length;++n)e="\\[?(%5[bB])?"+t[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",r.push(new RegExp("("+e+"=)([^&\\n]+)","igm"));return r;}function S(t){var e,r,n,o=[];for(e=0,r=t.length;e<r;e++)n=t[e],"object"==typeof n?(n=v(n),n=n.error||n.value,n.length>500&&(n=n.substr(0,500)+"...")):"undefined"==typeof n&&(n="undefined"),o.push(n);return o.join(" ");}function O(){return Date.now?Date.now():+new Date();}var N=r(7),L={},C=!1;n();var j={debug:0,info:1,warning:2,error:3,critical:4},A={strictMode:!1,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}};t.exports={isType:o,typeName:i,isFunction:a,isIterable:u,isError:c,extend:N,traverse:l,redact:p,uuid4:f,LEVELS:j,sanitizeUrl:h,addParamsAndAccessTokenToPath:m,formatUrl:g,stringify:v,jsonParse:y,makeUnhandledStackInfo:b,createItem:_,get:x,set:k,scrub:E,formatArgsAsString:S,now:O};},function(t,e){"use strict";var r=Object.prototype.hasOwnProperty,n=Object.prototype.toString,o=function(t){return"function"==typeof Array.isArray?Array.isArray(t):"[object Array]"===n.call(t);},i=function(t){if(!t||"[object Object]"!==n.call(t))return!1;var e=r.call(t,"constructor"),o=t.constructor&&t.constructor.prototype&&r.call(t.constructor.prototype,"isPrototypeOf");if(t.constructor&&!e&&!o)return!1;var i;for(i in t);return"undefined"==typeof i||r.call(t,i);};t.exports=function t(){var e,r,n,a,s,u,c=arguments[0],l=1,p=arguments.length,f=!1;for("boolean"==typeof c?(f=c,c=arguments[1]||{},l=2):("object"!=typeof c&&"function"!=typeof c||null==c)&&(c={});l<p;++l)if(e=arguments[l],null!=e)for(r in e)n=c[r],a=e[r],c!==a&&(f&&a&&(i(a)||(s=o(a)))?(s?(s=!1,u=n&&o(n)?n:[]):u=n&&i(n)?n:{},c[r]=t(f,u,a)):"undefined"!=typeof a&&(c[r]=a));return c;};},function(t,e){var r=function(t){function e(t){return t<10?"0"+t:t;}function r(){return this.valueOf();}function n(t){return i.lastIndex=0,i.test(t)?'"'+t.replace(i,function(t){var e=u[t];return"string"==typeof e?e:"\\u"+("0000"+t.charCodeAt(0).toString(16)).slice(-4);})+'"':'"'+t+'"';}function o(t,e){var r,i,u,l,p,f=a,h=e[t];switch(h&&"object"==typeof h&&"function"==typeof h.toJSON&&(h=h.toJSON(t)),"function"==typeof c&&(h=c.call(e,t,h)),typeof h){case"string":return n(h);case"number":return isFinite(h)?String(h):"null";case"boolean":case"null":return String(h);case"object":if(!h)return"null";if(a+=s,p=[],"[object Array]"===Object.prototype.toString.apply(h)){for(l=h.length,r=0;r<l;r+=1)p[r]=o(r,h)||"null";return u=0===p.length?"[]":a?"[\n"+a+p.join(",\n"+a)+"\n"+f+"]":"["+p.join(",")+"]",a=f,u;}if(c&&"object"==typeof c)for(l=c.length,r=0;r<l;r+=1)"string"==typeof c[r]&&(i=c[r],u=o(i,h),u&&p.push(n(i)+(a?": ":":")+u));else for(i in h)Object.prototype.hasOwnProperty.call(h,i)&&(u=o(i,h),u&&p.push(n(i)+(a?": ":":")+u));return u=0===p.length?"{}":a?"{\n"+a+p.join(",\n"+a)+"\n"+f+"}":"{"+p.join(",")+"}",a=f,u;}}var i=/[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;"function"!=typeof Date.prototype.toJSON&&(Date.prototype.toJSON=function(){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+e(this.getUTCMonth()+1)+"-"+e(this.getUTCDate())+"T"+e(this.getUTCHours())+":"+e(this.getUTCMinutes())+":"+e(this.getUTCSeconds())+"Z":null;},Boolean.prototype.toJSON=r,Number.prototype.toJSON=r,String.prototype.toJSON=r);var a,s,u,c;"function"!=typeof t.stringify&&(u={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},t.stringify=function(t,e,r){var n;if(a="",s="","number"==typeof r)for(n=0;n<r;n+=1)s+=" ";else"string"==typeof r&&(s=r);if(c=e,e&&"function"!=typeof e&&("object"!=typeof e||"number"!=typeof e.length))throw new Error("JSON.stringify");return o("",{"":t});}),"function"!=typeof t.parse&&(t.parse=function(){function t(t){return t.replace(/\\(?:u(.{4})|([^u]))/g,function(t,e,r){return e?String.fromCharCode(parseInt(e,16)):a[r];});}var e,r,n,o,i,a={"\\":"\\",'"':'"',"/":"/",t:"\t",n:"\n",r:"\r",f:"\f",b:"\b"},s={go:function(){e="ok";},firstokey:function(){o=i,e="colon";},okey:function(){o=i,e="colon";},ovalue:function(){e="ocomma";},firstavalue:function(){e="acomma";},avalue:function(){e="acomma";}},u={go:function(){e="ok";},ovalue:function(){e="ocomma";},firstavalue:function(){e="acomma";},avalue:function(){e="acomma";}},c={"{":{go:function(){r.push({state:"ok"}),n={},e="firstokey";},ovalue:function(){r.push({container:n,state:"ocomma",key:o}),n={},e="firstokey";},firstavalue:function(){r.push({container:n,state:"acomma"}),n={},e="firstokey";},avalue:function(){r.push({container:n,state:"acomma"}),n={},e="firstokey";}},"}":{firstokey:function(){var t=r.pop();i=n,n=t.container,o=t.key,e=t.state;},ocomma:function(){var t=r.pop();n[o]=i,i=n,n=t.container,o=t.key,e=t.state;}},"[":{go:function(){r.push({state:"ok"}),n=[],e="firstavalue";},ovalue:function(){r.push({container:n,state:"ocomma",key:o}),n=[],e="firstavalue";},firstavalue:function(){r.push({container:n,state:"acomma"}),n=[],e="firstavalue";},avalue:function(){r.push({container:n,state:"acomma"}),n=[],e="firstavalue";}},"]":{firstavalue:function(){var t=r.pop();i=n,n=t.container,o=t.key,e=t.state;},acomma:function(){var t=r.pop();n.push(i),i=n,n=t.container,o=t.key,e=t.state;}},":":{colon:function(){if(Object.hasOwnProperty.call(n,o))throw new SyntaxError("Duplicate key '"+o+'"');e="ovalue";}},",":{ocomma:function(){n[o]=i,e="okey";},acomma:function(){n.push(i),e="avalue";}},true:{go:function(){i=!0,e="ok";},ovalue:function(){i=!0,e="ocomma";},firstavalue:function(){i=!0,e="acomma";},avalue:function(){i=!0,e="acomma";}},false:{go:function(){i=!1,e="ok";},ovalue:function(){i=!1,e="ocomma";},firstavalue:function(){i=!1,e="acomma";},avalue:function(){i=!1,e="acomma";}},null:{go:function(){i=null,e="ok";},ovalue:function(){i=null,e="ocomma";},firstavalue:function(){i=null,e="acomma";},avalue:function(){i=null,e="acomma";}}};return function(n,o){var a,l=/^[\u0020\t\n\r]*(?:([,:\[\]{}]|true|false|null)|(-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)|"((?:[^\r\n\t\\\"]|\\(?:["\\\/trnfb]|u[0-9a-fA-F]{4}))*)")/;e="go",r=[];try{for(;;){if(a=l.exec(n),!a)break;a[1]?c[a[1]][e]():a[2]?(i=+a[2],u[e]()):(i=t(a[3]),s[e]()),n=n.slice(a[0].length);}}catch(t){e=t;}if("ok"!==e||/[^\u0020\t\n\r]/.test(n))throw e instanceof SyntaxError?e:new SyntaxError("JSON");return"function"==typeof o?function t(e,r){var n,a,s=e[r];if(s&&"object"==typeof s)for(n in i)Object.prototype.hasOwnProperty.call(s,n)&&(a=t(s,n),void 0!==a?s[n]=a:delete s[n]);return o.call(e,r,s);}({"":i},""):i;};}());};t.exports=r;},function(t,e,r){"use strict";function n(t,e){this.queue=t,this.options=e,this.transforms=[];}var o=r(6);n.prototype.configure=function(t){this.queue&&this.queue.configure(t);var e=this.options;return this.options=o.extend(!0,{},e,t),this;},n.prototype.addTransform=function(t){return o.isFunction(t)&&this.transforms.push(t),this;},n.prototype.log=function(t,e){if(e&&o.isFunction(e)||(e=function(){}),!this.options.enabled)return e(new Error("Rollbar is not enabled"));var r=t.err;this._applyTransforms(t,function(t,n){return t?e(t,null):void this.queue.addItem(n,e,r);}.bind(this));},n.prototype._applyTransforms=function(t,e){var r=-1,n=this.transforms.length,o=this.transforms,i=this.options,a=function(t,s){return t?void e(t,null):(r++,r===n?void e(null,s):void o[r](s,i,a));};a(null,t);},t.exports=n;},function(t,e,r){"use strict";function n(t){this.queue=[],this.options=i.extend(!0,{},t);var e=this.options.maxTelemetryEvents||a;this.maxQueueSize=Math.max(0,Math.min(e,a));}function o(t,e){if(e)return e;var r={error:"error",manual:"info"};return r[t]||"info";}var i=r(6),a=100;n.prototype.copyEvents=function(){return Array.prototype.slice.call(this.queue,0);},n.prototype.capture=function(t,e,r,n,a){var s={level:o(t,r),type:t,timestamp_ms:a||i.now(),body:e,source:"client"};return n&&(s.uuid=n),this.push(s),s;},n.prototype.captureEvent=function(t,e,r){return this.capture("manual",t,e,r);},n.prototype.captureError=function(t,e,r,n){var o={message:t.message||String(t)};return t.stack&&(o.stack=t.stack),this.capture("error",o,e,r,n);},n.prototype.captureLog=function(t,e,r,n){return this.capture("log",{message:t},e,r,n);},n.prototype.captureNetwork=function(t,e,r){e=e||"xhr",t.subtype=t.subtype||e;var n=this.levelFromStatus(t.status_code);return this.capture("network",t,n,r);},n.prototype.levelFromStatus=function(t){return t>=200&&t<400?"info":0===t||t>=400?"error":"info";},n.prototype.captureDom=function(t,e,r,n,o){var i={subtype:t,element:e};return void 0!==r&&(i.value=r),void 0!==n&&(i.checked=n),this.capture("dom",i,"info",o);},n.prototype.captureNavigation=function(t,e,r){return this.capture("navigation",{from:t,to:e},"info",r);},n.prototype.captureDomContentLoaded=function(t){return this.capture("navigation",{subtype:"DOMContentLoaded"},"info",void 0,t&&t.getTime());},n.prototype.captureLoad=function(t){return this.capture("navigation",{subtype:"load"},"info",void 0,t&&t.getTime());},n.prototype.captureConnectivityChange=function(t,e){return this.captureNetwork({change:t},"connectivity",e);},n.prototype._captureRollbarItem=function(t){return t.err?this.captureError(t.err,t.level,t.uuid,t.timestamp):t.message?this.captureLog(t.message,t.level,t.uuid,t.timestamp):t.custom?this.capture("log",t.custom,t.level,t.uuid,t.timestamp):void 0;},n.prototype.push=function(t){this.queue.push(t),this.queue.length>this.maxQueueSize&&this.queue.shift();},t.exports=n;},function(t,e,r){"use strict";function n(t,e,r,n){this.options=t,this.transport=e,this.url=r,this.jsonBackup=n,this.accessToken=t.accessToken,this.transportOptions=o(t,r);}function o(t,e){return a.getTransportFromOptions(t,s,e);}var i=r(6),a=r(12),s={hostname:"api.rollbar.com",path:"/api/1",search:null,version:"1",protocol:"https:",port:443};n.prototype.postItem=function(t,e){var r=a.transportOptions(this.transportOptions,"/item/","POST"),n=a.buildPayload(this.accessToken,t,this.jsonBackup);this.transport.post(this.accessToken,r,n,e);},n.prototype.configure=function(t){var e=this.oldOptions;return this.options=i.extend(!0,{},e,t),this.transportOptions=o(this.options,this.url),void 0!==this.options.accessToken&&(this.accessToken=this.options.accessToken),this;},t.exports=n;},function(t,e,r){"use strict";function n(t,e,r){if(s.isType(e.context,"object")){var n=s.stringify(e.context,r);n.error?e.context="Error: could not serialize 'context'":e.context=n.value||"",e.context.length>255&&(e.context=e.context.substr(0,255));}return{access_token:t,data:e};}function o(t,e,r){var n=e.hostname,o=e.protocol,i=e.port,a=e.path,s=e.search,u=t.proxy;if(t.endpoint){var c=r.parse(t.endpoint);n=c.hostname,o=c.protocol,i=c.port,a=c.pathname,s=c.search;}return{hostname:n,protocol:o,port:i,path:a,search:s,proxy:u};}function i(t,e,r){var n=t.protocol||"https:",o=t.port||("http:"===n?80:"https:"===n?443:void 0),i=t.hostname;return e=a(t.path,e),t.search&&(e+=t.search),t.proxy&&(e=n+"//"+i+e,i=t.proxy.host||t.proxy.hostname,o=t.proxy.port,n=t.proxy.protocol||n),{protocol:n,hostname:i,path:e,port:o,method:r};}function a(t,e){var r=/\/$/.test(t),n=/^\//.test(e);return r&&n?e=e.substring(1):r||n||(e="/"+e),t+e;}var s=r(6);t.exports={buildPayload:n,getTransportFromOptions:o,transportOptions:i,appendPathToPath:a};},function(t,e,r){"use strict";function n(){var t=Array.prototype.slice.call(arguments,0);t.unshift("Rollbar:"),a.ieVersion()<=8?console.error(s.formatArgsAsString(t)):console.error.apply(console,t);}function o(){var t=Array.prototype.slice.call(arguments,0);t.unshift("Rollbar:"),a.ieVersion()<=8?console.info(s.formatArgsAsString(t)):console.info.apply(console,t);}function i(){var t=Array.prototype.slice.call(arguments,0);t.unshift("Rollbar:"),a.ieVersion()<=8?console.log(s.formatArgsAsString(t)):console.log.apply(console,t);}r(14);var a=r(15),s=r(6);t.exports={error:n,info:o,log:i};},function(t,e){!function(t){"use strict";t.console||(t.console={});for(var e,r,n=t.console,o=function(){},i=["memory"],a="assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn".split(",");e=i.pop();)n[e]||(n[e]={});for(;r=a.pop();)n[r]||(n[r]=o);}("undefined"==typeof window?this:window);},function(t,e){"use strict";function r(){var t;if(!document)return t;for(var e=3,r=document.createElement("div"),n=r.getElementsByTagName("i");r.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->",n[0];);return e>4?e:t;}var n={ieVersion:r};t.exports=n;},function(t,e){"use strict";function r(t,e,r){if(t){var o;"function"==typeof e._rollbarOldOnError?o=e._rollbarOldOnError:t.onerror&&!t.onerror.belongsToShim&&(o=t.onerror,e._rollbarOldOnError=o);var i=function(){var r=Array.prototype.slice.call(arguments,0);n(t,e,o,r);};i.belongsToShim=r,t.onerror=i;}}function n(t,e,r,n){t._rollbarWrappedError&&(n[4]||(n[4]=t._rollbarWrappedError),n[5]||(n[5]=t._rollbarWrappedError._rollbarContext),t._rollbarWrappedError=null),e.handleUncaughtException.apply(e,n),r&&r.apply(t,n);}function o(t,e,r){if(t){"function"==typeof t._rollbarURH&&t._rollbarURH.belongsToShim&&t.removeEventListener("unhandledrejection",t._rollbarURH);var n=function(t){var r=t.reason,n=t.promise,o=t.detail;!r&&o&&(r=o.reason,n=o.promise),e&&e.handleUnhandledRejection&&e.handleUnhandledRejection(r,n);};n.belongsToShim=r,t._rollbarURH=n,t.addEventListener("unhandledrejection",n);}}function i(t,e,r){if(t){var n,o,i="EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(",");for(n=0;n<i.length;++n)o=i[n],t[o]&&t[o].prototype&&a(e,t[o].prototype,r);}}function a(t,e,r){if(e.hasOwnProperty&&e.hasOwnProperty("addEventListener")){for(var n=e.addEventListener;n._rollbarOldAdd&&n.belongsToShim;)n=n._rollbarOldAdd;var o=function(e,r,o){n.call(this,e,t.wrap(r),o);};o._rollbarOldAdd=n,o.belongsToShim=r,e.addEventListener=o;for(var i=e.removeEventListener;i._rollbarOldRemove&&i.belongsToShim;)i=i._rollbarOldRemove;var a=function(t,e,r){i.call(this,t,e&&e._rollbar_wrapped||e,r);};a._rollbarOldRemove=i,a.belongsToShim=r,e.removeEventListener=a;}}t.exports={captureUncaughtExceptions:r,captureUnhandledRejections:o,wrapGlobals:i};},function(t,e,r){"use strict";function n(t,e,r,n,o){n&&l.isFunction(n)||(n=function(){}),l.addParamsAndAccessTokenToPath(t,e,r);var a="GET",s=l.formatUrl(e);i(t,s,a,null,n,o);}function o(t,e,r,n,o){if(n&&l.isFunction(n)||(n=function(){}),!r)return n(new Error("Cannot send empty request"));var a=l.stringify(r);if(a.error)return n(a.error);var s=a.value,u="POST",c=l.formatUrl(e);i(t,c,u,s,n,o);}function i(t,e,r,n,o,i){var f;if(f=i?i():a(),!f)return o(new Error("No way to send a request"));try{try{var h=function(){try{if(h&&4===f.readyState){h=void 0;var t=l.jsonParse(f.responseText);if(s(f))return void o(t.error,t.value);if(u(f)){if(403===f.status){var e=t.value&&t.value.message;p.error(e);}o(new Error(String(f.status)));}else{var r="XHR response had no status code (likely connection failure)";o(c(r));}}}catch(t){var n;n=t&&t.stack?t:new Error(t),o(n);}};f.open(r,e,!0),f.setRequestHeader&&(f.setRequestHeader("Content-Type","application/json"),f.setRequestHeader("X-Rollbar-Access-Token",t)),f.onreadystatechange=h,f.send(n);}catch(t){if("undefined"!=typeof XDomainRequest){if(!window||!window.location)return o(new Error("No window available during request, unknown environment"));"http:"===window.location.href.substring(0,5)&&"https"===e.substring(0,5)&&(e="http"+e.substring(5));var d=new XDomainRequest();d.onprogress=function(){},d.ontimeout=function(){var t="Request timed out",e="ETIMEDOUT";o(c(t,e));},d.onerror=function(){o(new Error("Error during request"));},d.onload=function(){var t=l.jsonParse(d.responseText);o(t.error,t.value);},d.open(r,e,!0),d.send(n);}else o(new Error("Cannot find a method to transport a request"));}}catch(t){o(t);}}function a(){var t,e,r=[function(){return new XMLHttpRequest();},function(){return new ActiveXObject("Msxml2.XMLHTTP");},function(){return new ActiveXObject("Msxml3.XMLHTTP");},function(){return new ActiveXObject("Microsoft.XMLHTTP");}],n=r.length;for(e=0;e<n;e++)try{t=r[e]();break;}catch(t){}return t;}function s(t){return t&&t.status&&200===t.status;}function u(t){return t&&l.isType(t.status,"number")&&t.status>=400&&t.status<600;}function c(t,e){var r=new Error(t);return r.code=e||"ENOTFOUND",r;}var l=r(6),p=r(13);t.exports={get:n,post:o};},function(t,e){"use strict";function r(t){var e,r,n={protocol:null,auth:null,host:null,path:null,hash:null,href:t,hostname:null,port:null,pathname:null,search:null,query:null};if(e=t.indexOf("//"),e!==-1?(n.protocol=t.substring(0,e),r=e+2):r=0,e=t.indexOf("@",r),e!==-1&&(n.auth=t.substring(r,e),r=e+1),e=t.indexOf("/",r),e===-1){if(e=t.indexOf("?",r),e===-1)return e=t.indexOf("#",r),e===-1?n.host=t.substring(r):(n.host=t.substring(r,e),n.hash=t.substring(e)),n.hostname=n.host.split(":")[0],n.port=n.host.split(":")[1],n.port&&(n.port=parseInt(n.port,10)),n;n.host=t.substring(r,e),n.hostname=n.host.split(":")[0],n.port=n.host.split(":")[1],n.port&&(n.port=parseInt(n.port,10)),r=e;}else n.host=t.substring(r,e),n.hostname=n.host.split(":")[0],n.port=n.host.split(":")[1],n.port&&(n.port=parseInt(n.port,10)),r=e;if(e=t.indexOf("#",r),e===-1?n.path=t.substring(r):(n.path=t.substring(r,e),n.hash=t.substring(e)),n.path){var o=n.path.split("?");n.pathname=o[0],n.query=o[1],n.search=n.query?"?"+n.query:null;}return n;}t.exports={parse:r};},function(t,e,r){"use strict";function n(t,e,r){if(t.data=t.data||{},t.err)try{t.stackInfo=t.err._savedStackTrace||m.parse(t.err);}catch(e){g.error("Error while parsing the error object.",e),t.message=t.err.message||t.err.description||t.message||String(t.err),delete t.err;}r(null,t);}function o(t,e,r){t.message||t.stackInfo||t.custom||r(new Error("No message, stack info, or custom data"),null),r(null,t);}function i(t,e,r){var n=e.payload&&e.payload.environment||e.environment;t.data=d.extend(!0,{},t.data,{environment:n,level:t.level,endpoint:e.endpoint,platform:"browser",framework:"browser-js",language:"javascript",server:{},uuid:t.uuid,notifier:{name:"rollbar-browser-js",version:e.version}}),r(null,t);}function a(t){return function(e,r,n){return t&&t.location?(d.set(e,"data.request",{url:t.location.href,query_string:t.location.search,user_ip:"$remote_ip"}),void n(null,e)):n(null,e);};}function s(t){return function(e,r,n){return t?(d.set(e,"data.client",{runtime_ms:e.timestamp-t._rollbarStartTime,timestamp:Math.round(e.timestamp/1e3),javascript:{browser:t.navigator.userAgent,language:t.navigator.language,cookie_enabled:t.navigator.cookieEnabled,screen:{width:t.screen.width,height:t.screen.height}}}),void n(null,e)):n(null,e);};}function u(t){return function(e,r,n){if(!t||!t.navigator)return n(null,e);for(var o,i=[],a=t.navigator.plugins||[],s=0,u=a.length;s<u;++s)o=a[s],i.push({name:o.name,description:o.description});d.set(e,"data.client.javascript.plugins",i),n(null,e);};}function c(t,e,r){t.stackInfo?p(t,e,r):l(t,e,r);}function l(t,e,r){var n=t.message,o=t.custom;if(!n)if(o){var i=e.scrubFields,a=d.stringify(d.scrub(o,i));n=a.error||a.value||"";}else n="";var s={body:n};o&&(s.extra=d.extend(!0,{},o)),d.set(t,"data.body",{message:s}),r(null,t);}function p(t,e,r){var n=t.data.description,o=t.stackInfo,i=t.custom,a=m.guessErrorClass(o.message),s=o.name||a[0],u=a[1],c={exception:{class:s,message:u}};n&&(c.exception.description=n);var p=o.stack;if(p&&0===p.length&&t._unhandledStackInfo&&t._unhandledStackInfo.stack&&(p=t._unhandledStackInfo.stack),p){var f,h,g,v,y,b,w,_;for(c.frames=[],w=0;w<p.length;++w)f=p[w],h={filename:f.url?d.sanitizeUrl(f.url):"(unknown)",lineno:f.line||null,method:f.func&&"?"!==f.func?f.func:"[anonymous]",colno:f.column},h.method&&h.method.endsWith&&h.method.endsWith("._rollbar_wrapped")||(g=v=y=null,b=f.context?f.context.length:0,b&&(_=Math.floor(b/2),v=f.context.slice(0,_),g=f.context[_],y=f.context.slice(_)),g&&(h.code=g),(v||y)&&(h.context={},v&&v.length&&(h.context.pre=v),y&&y.length&&(h.context.post=y)),f.args&&(h.args=f.args),c.frames.push(h));c.frames.reverse(),i&&(c.extra=d.extend(!0,{},i)),d.set(t,"data.body",{trace:c}),r(null,t);}else t.message=s+": "+u,l(t,e,r);}function f(t,e,r){var n=e.scrubFields;d.scrub(t.data,n),r(null,t);}function h(t,e,r){var n=d.extend(!0,{},t);try{d.isFunction(e.transform)&&e.transform(n.data);}catch(n){return e.transform=null,g.error("Error while calling custom transform() function. Removing custom transform().",n),void r(null,t);}r(null,n);}var d=r(6),m=r(20),g=r(13);t.exports={handleItemWithError:n,ensureItemHasSomethingToSay:o,addBaseInfo:i,addRequestInfo:a,addClientInfo:s,addPluginInfo:u,addBody:c,scrubPayload:f,userTransform:h};},function(t,e,r){"use strict";function n(){return l;}function o(){return null;}function i(t){var e={};return e._stackFrame=t,e.url=t.fileName,e.line=t.lineNumber,e.func=t.functionName,e.column=t.columnNumber,e.args=t.args,e.context=o(e.url,e.line),e;}function a(t){function e(){var e=[];try{e=c.parse(t);}catch(t){e=[];}for(var r=[],n=0;n<e.length;n++)r.push(new i(e[n]));return r;}return{stack:e(),message:t.message,name:t.name};}function s(t){return new a(t);}function u(t){if(!t)return["Unknown error. There was no error message to display.",""];var e=t.match(p),r="(unknown)";return e&&(r=e[e.length-1],t=t.replace((e[e.length-2]||"")+r+":",""),t=t.replace(/(^[\s]+|[\s]+$)/g,"")),[r,t];}var c=r(21),l="?",p=new RegExp("^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ");t.exports={guessFunctionName:n,guessErrorClass:u,gatherContext:o,parse:s,Stack:a,Frame:i};},function(t,e,r){var n,o,i;!function(a,s){"use strict";o=[r(22)],n=s,i="function"==typeof n?n.apply(e,o):n,!(void 0!==i&&(t.exports=i));}(this,function(t){"use strict";function e(t,e,r){if("function"==typeof Array.prototype.map)return t.map(e,r);for(var n=new Array(t.length),o=0;o<t.length;o++)n[o]=e.call(r,t[o]);return n;}function r(t,e,r){if("function"==typeof Array.prototype.filter)return t.filter(e,r);for(var n=[],o=0;o<t.length;o++)e.call(r,t[o])&&n.push(t[o]);return n;}var n=/(^|@)\S+\:\d+/,o=/^\s*at .*(\S+\:\d+|\(native\))/m,i=/^(eval@)?(\[native code\])?$/;return{parse:function(t){if("undefined"!=typeof t.stacktrace||"undefined"!=typeof t["opera#sourceloc"])return this.parseOpera(t);if(t.stack&&t.stack.match(o))return this.parseV8OrIE(t);if(t.stack)return this.parseFFOrSafari(t);throw new Error("Cannot parse given Error object");},extractLocation:function(t){if(t.indexOf(":")===-1)return[t];var e=t.replace(/[\(\)\s]/g,"").split(":"),r=e.pop(),n=e[e.length-1];if(!isNaN(parseFloat(n))&&isFinite(n)){var o=e.pop();return[e.join(":"),o,r];}return[e.join(":"),r,void 0];},parseV8OrIE:function(n){var i=r(n.stack.split("\n"),function(t){return!!t.match(o);},this);return e(i,function(e){e.indexOf("(eval ")>-1&&(e=e.replace(/eval code/g,"eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g,""));var r=e.replace(/^\s+/,"").replace(/\(eval code/g,"(").split(/\s+/).slice(1),n=this.extractLocation(r.pop()),o=r.join(" ")||void 0,i="eval"===n[0]?void 0:n[0];return new t(o,void 0,i,n[1],n[2],e);},this);},parseFFOrSafari:function(n){var o=r(n.stack.split("\n"),function(t){return!t.match(i);},this);return e(o,function(e){if(e.indexOf(" > eval")>-1&&(e=e.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g,":$1")),e.indexOf("@")===-1&&e.indexOf(":")===-1)return new t(e);var r=e.split("@"),n=this.extractLocation(r.pop()),o=r.shift()||void 0;return new t(o,void 0,n[0],n[1],n[2],e);},this);},parseOpera:function(t){return!t.stacktrace||t.message.indexOf("\n")>-1&&t.message.split("\n").length>t.stacktrace.split("\n").length?this.parseOpera9(t):t.stack?this.parseOpera11(t):this.parseOpera10(t);},parseOpera9:function(e){for(var r=/Line (\d+).*script (?:in )?(\S+)/i,n=e.message.split("\n"),o=[],i=2,a=n.length;i<a;i+=2){var s=r.exec(n[i]);s&&o.push(new t(void 0,void 0,s[2],s[1],void 0,n[i]));}return o;},parseOpera10:function(e){for(var r=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,n=e.stacktrace.split("\n"),o=[],i=0,a=n.length;i<a;i+=2){var s=r.exec(n[i]);s&&o.push(new t(s[3]||void 0,void 0,s[2],s[1],void 0,n[i]));}return o;},parseOpera11:function(o){var i=r(o.stack.split("\n"),function(t){return!!t.match(n)&&!t.match(/^Error created at/);},this);return e(i,function(e){var r,n=e.split("@"),o=this.extractLocation(n.pop()),i=n.shift()||"",a=i.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^\)]*\)/g,"")||void 0;i.match(/\(([^\)]*)\)/)&&(r=i.replace(/^[^\(]+\(([^\)]*)\)$/,"$1"));var s=void 0===r||"[arguments not available]"===r?void 0:r.split(",");return new t(a,s,o[0],o[1],o[2],e);},this);}};});},function(t,e,r){var n,o,i;!function(r,a){"use strict";o=[],n=a,i="function"==typeof n?n.apply(e,o):n,!(void 0!==i&&(t.exports=i));}(this,function(){"use strict";function t(t){return!isNaN(parseFloat(t))&&isFinite(t);}function e(t,e,r,n,o){void 0!==t&&this.setFunctionName(t),void 0!==e&&this.setArgs(e),void 0!==r&&this.setFileName(r),void 0!==n&&this.setLineNumber(n),void 0!==o&&this.setColumnNumber(o);}return e.prototype={getFunctionName:function(){return this.functionName;},setFunctionName:function(t){this.functionName=String(t);},getArgs:function(){return this.args;},setArgs:function(t){if("[object Array]"!==Object.prototype.toString.call(t))throw new TypeError("Args must be an Array");this.args=t;},getFileName:function(){return this.fileName;},setFileName:function(t){this.fileName=String(t);},getLineNumber:function(){return this.lineNumber;},setLineNumber:function(e){if(!t(e))throw new TypeError("Line Number must be a Number");this.lineNumber=Number(e);},getColumnNumber:function(){return this.columnNumber;},setColumnNumber:function(e){if(!t(e))throw new TypeError("Column Number must be a Number");this.columnNumber=Number(e);},toString:function(){var e=this.getFunctionName()||"{anonymous}",r="("+(this.getArgs()||[]).join(",")+")",n=this.getFileName()?"@"+this.getFileName():"",o=t(this.getLineNumber())?":"+this.getLineNumber():"",i=t(this.getColumnNumber())?":"+this.getColumnNumber():"";return e+r+n+o+i;}},e;});},function(t,e,r){"use strict";function n(t,e,r){var n=e.payload||{};n.body&&delete n.body;var o=a.extend(!0,{},t.data,n);t._isUncaught&&(o._isUncaught=!0),r(null,o);}function o(t,e,r){t.telemetryEvents&&a.set(t,"data.body.telemetry",t.telemetryEvents),r(null,t);}function i(t,e,r){if(!t.message)return void r(null,t);var n="data.body.trace_chain.0",o=a.get(t,n);if(o||(n="data.body.trace",o=a.get(t,n)),o){if(!o.exception||!o.exception.description)return a.set(t,n+".exception.description",t.message),void r(null,t);var i=a.get(t,n+".extra")||{},s=a.extend(!0,{},i,{message:t.message});a.set(t,n+".extra",s);}r(null,t);}var a=r(6);t.exports={itemToPayload:n,addTelemetryData:o,addMessageWithError:i};},function(t,e,r){"use strict";function n(t,e){var r=t.level,n=c.LEVELS[r]||0,o=c.LEVELS[e.reportLevel]||0;return!(n<o)&&(!c.get(e,"plugins.jquery.ignoreAjaxErrors")||!c.get(t,"body.message.extra.isAjax"));}function o(t,e){var r=!!t._isUncaught;delete t._isUncaught;var n=t._originalArgs;delete t._originalArgs;try{if(c.isFunction(e.checkIgnore)&&e.checkIgnore(r,n,t))return!1;}catch(t){e.checkIgnore=null,l.error("Error while calling custom checkIgnore(), removing",t);}return!0;}function i(t,e){return s(t,e,"blacklist");}function a(t,e){return s(t,e,"whitelist");}function s(t,e,r){var n=!1;"blacklist"===r&&(n=!0);var o,i,a,s,u,p,f,h,d,m;try{if(o=n?e.hostBlackList:e.hostWhiteList,f=o&&o.length,i=c.get(t,"body.trace"),!o||0===f)return!0;if(!i||!i.frames)return!0;for(u=i.frames.length,d=0;d<u;d++){if(a=i.frames[d],s=a.filename,!c.isType(s,"string"))return!0;for(m=0;m<f;m++)if(p=o[m],h=new RegExp(p),h.test(s))return!n;}}catch(t){n?e.hostBlackList=null:e.hostWhiteList=null;var g=n?"hostBlackList":"hostWhiteList";return l.error("Error while reading your configuration's "+g+" option. Removing custom "+g+".",t),!0;}return n;}function u(t,e){var r,n,o,i,a,s,u,p,f;try{if(a=!1,o=e.ignoredMessages,!o||0===o.length)return!0;if(u=t.body,p=c.get(u,"trace.exception.message"),f=c.get(u,"message.body"),r=p||f,!r)return!0;for(i=o.length,n=0;n<i&&(s=new RegExp(o[n],"gi"),!(a=s.test(r)));n++);}catch(t){e.ignoredMessages=null,l.error("Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.");}return!a;}var c=r(6),l=r(13);t.exports={checkIgnore:n,userCheckIgnore:o,urlIsBlacklisted:i,urlIsWhitelisted:a,messageIsIgnored:u};},function(t,e,r){"use strict";function n(t,e,r,n){var o=t[e];t[e]=r(o),n&&n.push([t,e,o]);}function o(t){for(var e;t.length;)e=t.shift(),e[0][e[1]]=e[2];}function i(t,e,r,n,o){var i=t.autoInstrument;return i===!1?void(this.autoInstrument={}):(h.isType(i,"object")||(i=m),this.autoInstrument=h.extend(!0,{},m,i),this.telemeter=e,this.rollbar=r,this._window=n||{},this._document=o||{},this.replacements=[],this._location=this._window.location,void(this._lastHref=this._location&&this._location.href));}function a(t){return(t.getAttribute("type")||"").toLowerCase();}function s(t,e,r){if(t.tagName.toLowerCase()!==e.toLowerCase())return!1;if(!r)return!0;t=a(t);for(var n=0;n<r.length;n++)if(r[n]===t)return!0;return!1;}function u(t,e){return t.target?t.target:e&&e.elementFromPoint?e.elementFromPoint(t.clientX,t.clientY):void 0;}function c(t){for(var e,r=5,n=[],o=0;t&&o<r&&(e=f(t),"html"!==e.tagName);o++)n.push(e),t=t.parentNode;return n.reverse();}function l(t){for(var e,r,n=80,o=" > ",i=o.length,a=[],s=0,u=0;u<t.length&&(e=p(t[u]),r=s+a.length*i+e.length,!(u>0&&r>=n));u++)a.push(e),s+=e.length;return a.join(o);}function p(t){if(!t||!t.tagName)return"";var e=[t.tagName];t.id&&e.push("#"+t.id),t.classes&&e.push("."+t.classes.join("."));for(var r=0;r<t.attributes.length;r++)e.push("["+t.attributes[r].key+'="'+t.attributes[r].value+'"]');return e.join("");}function f(t){if(!t||!t.tagName)return null;var e,r,n,o,i={};i.tagName=t.tagName.toLowerCase(),t.id&&(i.id=t.id),e=t.className,e&&h.isType(e,"string")&&(i.classes=e.split(/\s+/));var a=["type","name","title","alt"];for(i.attributes=[],o=0;o<a.length;o++)r=a[o],n=t.getAttribute(r),n&&i.attributes.push({key:r,value:n});return i;}var h=r(6),d=r(18),m={network:!1,log:!0,dom:!0,navigation:!0,connectivity:!0};i.prototype.instrument=function(){this.autoInstrument.network&&this.instrumentNetwork(),this.autoInstrument.log&&this.instrumentConsole(),this.autoInstrument.dom&&this.instrumentDom(),this.autoInstrument.navigation&&this.instrumentNavigation(),this.autoInstrument.connectivity&&this.instrumentConnectivity();},i.prototype.instrumentNetwork=function(){function t(t,r){t in r&&h.isFunction(r[t])&&n(r,t,function(t){return e.rollbar.wrap(t);},e.replacements);}var e=this;if("XMLHttpRequest"in this._window){var r=this._window.XMLHttpRequest.prototype;n(r,"open",function(t){return function(e,r){return h.isType(r,"string")&&(this.__rollbar_xhr={method:e,url:r,status_code:null,start_time_ms:h.now(),end_time_ms:null}),t.apply(this,arguments);};},this.replacements),n(r,"send",function(r){return function(o){function i(){if(a.__rollbar_xhr&&(1===a.readyState||4===a.readyState)){null===a.__rollbar_xhr.status_code&&(a.__rollbar_xhr.status_code=0,a.__rollbar_event=e.telemeter.captureNetwork(a.__rollbar_xhr,"xhr")),1===a.readyState?a.__rollbar_xhr.start_time_ms=h.now():a.__rollbar_xhr.end_time_ms=h.now();try{var t=a.status;t=1223===t?204:t,a.__rollbar_xhr.status_code=t,a.__rollbar_event.level=e.telemeter.levelFromStatus(t);}catch(t){}}}var a=this;return t("onload",a),t("onerror",a),t("onprogress",a),"onreadystatechange"in a&&h.isFunction(a.onreadystatechange)?n(a,"onreadystatechange",function(t){e.rollbar.wrap(t,void 0,i);}):a.onreadystatechange=i,r.apply(this,arguments);};},this.replacements);}"fetch"in this._window&&n(this._window,"fetch",function(t){return function(r,n){for(var o=new Array(arguments.length),i=0,a=o.length;i<a;i++)o[i]=arguments[i];var s,u=o[0],c="GET";h.isType(u,"string")?s=u:(s=u.url,u.method&&(c=u.method)),o[1]&&o[1].method&&(c=o[1].method);var l={method:c,url:s,status_code:null,start_time_ms:h.now(),end_time_ms:null};return e.telemeter.captureNetwork(l,"fetch"),t.apply(this,o).then(function(t){return l.end_time_ms=h.now(),l.status_code=t.status,t;});};},this.replacements);},i.prototype.instrumentConsole=function(){function t(t){var n=r[t],o=r,i="warn"===t?"warning":t;r[t]=function(){var t=Array.prototype.slice.call(arguments),r=h.formatArgsAsString(t);e.telemeter.captureLog(r,i),n&&Function.prototype.apply.call(n,o,t);};}if("console"in this._window&&this._window.console.log)for(var e=this,r=this._window.console,n=["debug","info","warn","error","log"],o=0,i=n.length;o<i;o++)t(n[o]);},i.prototype.instrumentDom=function(){if("addEventListener"in this._window||"attachEvent"in this._window){var t=this.handleClick.bind(this),e=this.handleBlur.bind(this);this._window.addEventListener?(this._window.addEventListener("click",t,!0),this._window.addEventListener("blur",e,!0)):(this._window.attachEvent("click",t),this._window.attachEvent("onfocusout",e));}},i.prototype.handleClick=function(t){try{var e=u(t,this._document),r=e&&e.tagName,n=s(e,"a")||s(e,"button");r&&(n||s(e,"input",["button","submit"]))?this.captureDomEvent("click",e):s(e,"input",["checkbox","radio"])&&this.captureDomEvent("input",e,e.value,e.checked);}catch(t){}},i.prototype.handleBlur=function(t){try{var e=u(t,this._document);e&&e.tagName&&(s(e,"textarea")?this.captureDomEvent("input",e,e.value):s(e,"select")&&e.options&&e.options.length?this.handleSelectInputChanged(e):s(e,"input")&&!s(e,"input",["button","submit","hidden","checkbox","radio"])&&this.captureDomEvent("input",e,e.value));}catch(t){}},i.prototype.handleSelectInputChanged=function(t){if(t.multiple)for(var e=0;e<t.options.length;e++)t.options[e].selected&&this.captureDomEvent("input",t,t.options[e].value);else t.selectedIndex>=0&&t.options[t.selectedIndex]&&this.captureDomEvent("input",t,t.options[t.selectedIndex].value);},i.prototype.captureDomEvent=function(t,e,r,n){"password"===a(e)&&(r=void 0);var o=l(c(e));this.telemeter.captureDom(t,o,r,n);},i.prototype.instrumentNavigation=function(){var t=this._window.chrome,e=t&&t.app&&t.app.runtime,r=!e&&this._window.history&&this._window.history.pushState;if(r){var o=this,i=this._window.onpopstate;this._window.onpopstate=function(){var t=o._location.href;o.handleUrlChange(o._lastHref,t),i&&i.apply(this,arguments);},n(this._window.history,"pushState",function(t){return function(){var e=arguments.length>2?arguments[2]:void 0;return e&&o.handleUrlChange(o._lastHref,e+""),t.apply(this,arguments);};},this.replacements);}},i.prototype.handleUrlChange=function(t,e){var r=d.parse(this._location.href),n=d.parse(e),o=d.parse(t);this._lastHref=e,r.protocol===n.protocol&&r.host===n.host&&(e=n.path+(n.hash||"")),r.protocol===o.protocol&&r.host===o.host&&(t=o.path+(o.hash||"")),this.telemeter.captureNavigation(t,e);},i.prototype.instrumentConnectivity=function(){("addEventListener"in this._window||"body"in this._document)&&(this._window.addEventListener?(this._window.addEventListener("online",function(){this.telemeter.captureConnectivityChange("online");}.bind(this),!0),this._window.addEventListener("offline",function(){this.telemeter.captureConnectivityChange("offline");}.bind(this),!0)):(this._document.body.ononline=function(){this.telemeter.captureConnectivityChange("online");}.bind(this),this._document.body.onoffline=function(){this.telemeter.captureConnectivityChange("offline");}.bind(this)));},i.prototype.restore=function(){o(this.replacements),this.replacements=[];},t.exports=i;}]);});});var rollbarConfig={accessToken:"fe7cf327f2b24bb8991e252239f6200f",captureUncaught:true,ignoredMessages:["Error:  DOM Exception 18","SecurityError: DOM Exception 18: An attempt was made to break through the security policy of the user agent.","SecurityError:  An attempt was made to break through the security policy of the user agent.","Script error."],payload:{environment:"development",client:{javascript:{source_map_enabled:true,code_version:"527b37e813ef904b8832f68bdb7b32ced2c6cf0a",// Optionally have Rollbar guess which frames the error was thrown from
// when the browser does not provide line and column numbers.
guess_uncaught_frames:true}}}};var rollbar=new rollbar_umd_min$1(rollbarConfig);function ModalControl(id,openBtnId,closeBtnId){this.modal=document.getElementById(id);this.openBtn=document.getElementById(openBtnId);this.closeBtn=document.getElementById(closeBtnId);this.openHandler=this.open.bind(this);this.closeHandler=this.close.bind(this);this.openBtn.addEventListener('click',this.openHandler,false);this.closeBtn.addEventListener('click',this.closeHandler,false);window.addEventListener('click',this.closeHandler,false);}ModalControl.prototype.open=function(){this.modal.classList.add('modal-open');this.modal.classList.remove('modal-close');};ModalControl.prototype.close=function(event){if(event.target==this.modal||event.target==this.closeBtn){this.modal.classList.add('modal-close');this.modal.classList.remove('modal-open');}};var VisionSimulation=require("dota-vision-simulation");var worlddata=require("dota-vision-simulation/src/worlddata.json");var aboutModal=new ModalControl('about','about-open','about-close');var helpModal=new ModalControl('help','help-open','help-close');var buildDate="2017-08-19 14:05:35 UTC";document.getElementById('buildDate').innerHTML=buildDate;var releaseTag="4.4.3";document.getElementById('releaseTag').innerHTML=releaseTag;function App(map_tile_path,vision_data_image_path){var InteractiveMap$$1=new InteractiveMap(map_tile_path);InteractiveMap$$1.toggleLayerMenuOption=function(layerId,state){var element=document.querySelector('input[data-layer-id="'+layerId+'"]');if(state!=null)element.checked=state;updateLayerAndQueryString(element,layerId);};InteractiveMap$$1.vs=new VisionSimulation(worlddata,vision_data_image_path,initialize);InteractiveMap$$1.menuControl=new MenuControl(InteractiveMap$$1);InteractiveMap$$1.menuControl.initialize(layerToggleHandler,baseLayerToggleHandler);InteractiveMap$$1.infoControl=new InfoControl(InteractiveMap$$1);InteractiveMap$$1.infoControl.initialize('info');InteractiveMap$$1.notificationControl=new NotificationControl();InteractiveMap$$1.notificationControl.initialize('notification');InteractiveMap$$1.visionControl=new VisionControl(InteractiveMap$$1);InteractiveMap$$1.wardControl=new WardControl(InteractiveMap$$1);InteractiveMap$$1.treeControl=new TreeControl(InteractiveMap$$1);InteractiveMap$$1.cursorControl=new CursorControl(InteractiveMap$$1);InteractiveMap$$1.coordinateControl=new CoordinateControl(InteractiveMap$$1,'coordinates');InteractiveMap$$1.measureControl=new MeasureControl(InteractiveMap$$1);InteractiveMap$$1.creepControl=new CreepControl(InteractiveMap$$1);InteractiveMap$$1.creepControl.initialize('timer');//var DrawCurveControl = require('./controls/drawCurve');
//InteractiveMap.drawCurveControl = new DrawCurveControl(InteractiveMap);
function changeMode(mode){switch(mode){case'observer':case'sentry':document.querySelector('input[name="ward-type"][value="'+mode+'"]').checked=true;case'ward':document.querySelector('input[name="mode"][value="ward"]').checked=true;InteractiveMap$$1.MODE=document.querySelector('input[name="ward-type"]:checked').value;document.getElementById('btn-ward').setAttribute('ward-type',InteractiveMap$$1.MODE);document.getElementById('btn-ward').classList.add('active');document.getElementById('btn-tree').classList.remove('active');document.getElementById('btn-measure').classList.remove('active');setQueryString('mode',InteractiveMap$$1.MODE);InteractiveMap$$1.measureControl.deactivate();InteractiveMap$$1.wardControl.activate();InteractiveMap$$1.infoControl.deactivate();break;case'line':case'circle':document.querySelector('input[name="measure-type"][value="'+mode+'"]').checked=true;case'measure':document.querySelector('input[name="mode"][value="measure"]').checked=true;InteractiveMap$$1.MODE=document.querySelector('input[name="measure-type"]:checked').value;document.getElementById('btn-ward').classList.remove('active');document.getElementById('btn-tree').classList.remove('active');document.getElementById('btn-measure').classList.add('active');document.getElementById('btn-measure').setAttribute('measure-type',InteractiveMap$$1.MODE);setQueryString('mode',InteractiveMap$$1.MODE);InteractiveMap$$1.measureControl.change(InteractiveMap$$1.MODE);InteractiveMap$$1.wardControl.deactivate();InteractiveMap$$1.infoControl.deactivate();break;default:document.querySelector('input[name="mode"][value="navigate"]').checked=true;InteractiveMap$$1.MODE=mode||"navigate";document.getElementById('btn-ward').classList.remove('active');document.getElementById('btn-tree').classList.add('active');document.getElementById('btn-measure').classList.remove('active');setQueryString('mode',InteractiveMap$$1.MODE=='navigate'?null:InteractiveMap$$1.MODE);InteractiveMap$$1.measureControl.deactivate();InteractiveMap$$1.wardControl.deactivate();InteractiveMap$$1.infoControl.activate();break;}InteractiveMap$$1.notificationControl.show(modeNotificationText[InteractiveMap$$1.MODE]);}function updateLayerAndQueryString(element,layerId){layerId=layerId||element.getAttribute('data-layer-id');var layer=InteractiveMap$$1.getMapLayerIndex()[layerId];if(layer){layer.setVisible(element.checked);var param=layer.get("title").replace(/ /g,'');setQueryString(param,element.checked?true:null);if(layerId=='ent_dota_tree'){document.getElementById('btn-tree').setAttribute('trees-enabled',element.checked?"yes":"no");}}}function layerToggleHandler(){updateLayerAndQueryString(this);}function baseLayerToggleHandler(){var layerId=this.getAttribute('data-layer-id');InteractiveMap$$1.baseLayers.forEach(function(layer){layer.setVisible(layer.get('layerId')===layerId);});setQueryString('BaseLayer',layerId);}// updates element visibility based on map layer index
// updates layer visibility based on element state
function updateOverlayMenu(){forEach(document.querySelectorAll('.data-layer > input'),function(element){var label=element.nextSibling;var layerId=element.getAttribute('data-layer-id');var layerIndex=InteractiveMap$$1.getMapLayerIndex();var layer=layerIndex[layerId];if(!layer){label.style.display="none";}else{label.style.display="block";layer.setVisible(element.checked);}},this);}function setDefaults(){var x=getParameterByName('x');var y=getParameterByName('y');var zoom=getParameterByName('zoom');if(zoom){InteractiveMap$$1.view.setZoom(zoom);}if(x&&y){var coordinate=_ol_proj_.transform([x,y],dotaProj,pixelProj);if(_ol_extent_.containsXY([-100,-100,mapConstants.map_w+100,mapConstants.map_h+100],coordinate[0],coordinate[1])){InteractiveMap$$1.panTo(coordinate);}}document.getElementById('btn-ward').setAttribute('ward-type','observer');var mode=getParameterByName('mode');changeMode(mode);var baseLayerName=getParameterByName('BaseLayer');var element;if(baseLayerName){element=document.querySelector('input[name="base-layer"][value="'+baseLayerName+'"]');if(element){element.checked=true;InteractiveMap$$1.baseLayers.filter(function(layer){return layer.get("layerId")==baseLayerName;})[0].setVisible(true);}}if(!element){setQueryString('BaseLayer',null);InteractiveMap$$1.baseLayers[0].setVisible(true);document.querySelector('input[name="base-layer"][value="'+InteractiveMap$$1.baseLayers[0].get("layerId")+'"]').checked=true;}InteractiveMap$$1.layerDefs.forEach(function(layerDef){var param=layerDef.name.replace(/ /g,'');var value=getParameterByName(param);if(value&&value!=="false"){layerDef.visible=true;document.querySelector('input[data-layer-id="'+layerDef.id+'"]').checked=true;setQueryString(param,true);}else{setQueryString(param,null);}if(layerDef.id=='ent_dota_tree'){document.getElementById('btn-tree').setAttribute('trees-enabled',layerDef.visible?"yes":"no");}});}function onMoveEnd(evt){var map=evt.map;var ext=map.getView().calculateExtent(map.getSize());var center=_ol_extent_.getCenter(ext);var worldXY=_ol_proj_.transform(center,pixelProj,dotaProj);var coordinate=[Math.round(worldXY[0]),Math.round(worldXY[1])];setQueryString('x',coordinate[0]);setQueryString('y',coordinate[1]);setQueryString('zoom',Math.round(InteractiveMap$$1.view.getZoom()));}function initialize(err){InteractiveMap$$1.infoControl.activate();setDefaults();InteractiveMap$$1.setMapLayers(InteractiveMap$$1.version,function(err){if(!err){updateOverlayMenu();InteractiveMap$$1.map.addLayer(InteractiveMap$$1.measureControl.layer);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.cursorControl.layer);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.visionControl.layer);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.wardControl.layer);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.highlightLayer);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.selectLayer);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.wardRangeLayer);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.rangeLayers.dayVision);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.rangeLayers.nightVision);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.rangeLayers.trueSight);InteractiveMap$$1.map.addLayer(InteractiveMap$$1.rangeLayers.attackRange);InteractiveMap$$1.treeControl.parseQueryString();InteractiveMap$$1.wardControl.parseQueryString();}else{rollbar.log("Vision simulation load error.",err);}});InteractiveMap$$1.map.on('moveend',onMoveEnd);forEach(document.querySelectorAll('input[name="mode"], input[name="ward-type"], input[name="measure-type"]'),function(element){element.addEventListener("change",function(){changeMode(this.value);},false);},this);document.getElementById('nightControl').addEventListener('change',function(){InteractiveMap$$1.isNight=this.checked;if(this.checked){InteractiveMap$$1.notificationControl.show(modeNotificationText.nightOn);}else{InteractiveMap$$1.notificationControl.show(modeNotificationText.nightOff);}});document.getElementById('darknessControl').addEventListener('change',function(){InteractiveMap$$1.isDarkness=this.checked;if(this.checked){InteractiveMap$$1.notificationControl.show(modeNotificationText.darknessOn);}else{InteractiveMap$$1.notificationControl.show(modeNotificationText.darknessOff);}});document.getElementById('creepControl').addEventListener('change',function(){if(this.checked){InteractiveMap$$1.creepControl.activate();}else{InteractiveMap$$1.creepControl.deactivate();}});document.getElementById('vision-radius').addEventListener('change',function(){InteractiveMap$$1.visionRadius=this.value;});document.getElementById('movementSpeed').addEventListener('change',function(){InteractiveMap$$1.movementSpeed=this.value;});document.getElementById('option-dayVision').addEventListener('change',function(){InteractiveMap$$1.rangeLayers.dayVision.setVisible(this.checked);});document.getElementById('option-nightVision').addEventListener('change',function(){InteractiveMap$$1.rangeLayers.nightVision.setVisible(this.checked);});document.getElementById('option-trueSight').addEventListener('change',function(){InteractiveMap$$1.rangeLayers.trueSight.setVisible(this.checked);});document.getElementById('option-attackRange').addEventListener('change',function(){InteractiveMap$$1.rangeLayers.attackRange.setVisible(this.checked);});document.getElementById('version-select').addEventListener('change',function(){var self=this;InteractiveMap$$1.setMapLayers(this.value,function(err){if(!err){InteractiveMap$$1.version=self.value;}else{self.value=InteractiveMap$$1.version;alert('Version change failed.');}});});document.getElementById('btn-zoom-in').addEventListener('click',function(){InteractiveMap$$1.view.animate({zoom:InteractiveMap$$1.view.getZoom()+1});});document.getElementById('btn-zoom-out').addEventListener('click',function(){InteractiveMap$$1.view.animate({zoom:InteractiveMap$$1.view.getZoom()-1});});document.getElementById('reset').addEventListener('click',function(){if(history&&history.replaceState)history.replaceState(null,"",window.location.href.split("?")[0]);setDefaults();updateOverlayMenu();InteractiveMap$$1.treeControl.toggleAllTrees(false,true);InteractiveMap$$1.treeControl.parseQueryString();InteractiveMap$$1.wardControl.clearWards();InteractiveMap$$1.wardControl.parseQueryString();});document.getElementById('btn-tree').addEventListener('click',function(){if(this.classList.contains('active')){this.setAttribute('trees-enabled',this.getAttribute('trees-enabled')=="yes"?"no":"yes");}this.classList.add('active');document.getElementById('btn-ward').classList.remove('active');document.getElementById('btn-measure').classList.remove('active');InteractiveMap$$1.toggleLayerMenuOption("ent_dota_tree",this.getAttribute('trees-enabled')=="yes");changeMode('navigate');InteractiveMap$$1.notificationControl.show(this.getAttribute('trees-enabled')=="yes"?modeNotificationText.treeEnable:modeNotificationText.treeDisable);});document.getElementById('btn-ward').addEventListener('click',function(){if(this.classList.contains('active')){this.setAttribute('ward-type',this.getAttribute('ward-type')=='observer'?'sentry':'observer');}if(this.getAttribute('ward-type')=='sentry'){document.querySelector('input[name="mode"][value="ward"]').checked=true;document.querySelector('input[name="ward-type"][value="sentry"]').checked=true;}else{document.querySelector('input[name="mode"][value="ward"]').checked=true;document.querySelector('input[name="ward-type"][value="observer"]').checked=true;}this.classList.add('active');document.getElementById('btn-tree').classList.remove('active');document.getElementById('btn-measure').classList.remove('active');changeMode('ward');});document.getElementById('btn-measure').addEventListener('click',function(){if(this.classList.contains('active')){this.setAttribute('measure-type',this.getAttribute('measure-type')=='line'?'circle':'line');}if(this.getAttribute('measure-type')=='circle'){document.querySelector('input[name="mode"][value="measure"]').checked=true;document.querySelector('input[name="measure-type"][value="circle"]').checked=true;}else{document.querySelector('input[name="mode"][value="measure"]').checked=true;document.querySelector('input[name="measure-type"][value="line"]').checked=true;}this.classList.add('active');document.getElementById('btn-tree').classList.remove('active');document.getElementById('btn-ward').classList.remove('active');changeMode('measure');});}}module.exports=App;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"dota-vision-simulation":5,"dota-vision-simulation/src/worlddata.json":6}]},{},[7])(7)
});
//# sourceMappingURL=bundle.js.map
